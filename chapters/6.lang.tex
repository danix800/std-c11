\chptr{语言}{lang}

\sect{记号}{lang.notation}
\paragraph{}
本章中所用语法记号中，语法类别（非结束符）由\textit{斜体}表示，字面单词和字符集
成员（结束符）由\tm{粗体}表示。跟在非结束符后的冒号（\texttt{:}）引入其定义。可
选定义在独立行上列出，除非前加``one of''。可选符号由下标``opt''表示，如       \\
\synprd{\tm{\{} \nt{expression$_{opt}$} \tm{\}}}
表示括号括起来的可选表达式。

\paragraph{}
在主文本中引用语法类型时不再使用斜体且单词使用空格而不是连字符分隔。

\paragraph{}
附录\ref{synsum}给出语法总结。

\sect{概念}{lang.concept}

\ssect{标识符作用域}{lang.concept.scope}
\paragraph{}
标识符可以表示对象；函数；结构，联合或枚举标签或成员；类型定义名；标号名；宏名或
宏参数。同一标识符可以在程序中不同点表示不同实体。枚举成员称作\textit{枚举常量}。
宏名和宏参数不再考虑，因为在程序分析的语义阶段源文件中任何宏名已经被构成宏定义的
预处理标记替换掉。

\paragraph{}
对一个标识符所代表的不同实体，该标识符仅在程序的一个文本段内\textit{可见}（即可
用），该文本段称作标识符的\textit{作用域}。由同一标识符所表示的不同实体要么具有
不同作用域，要么处于不同命名空间中。存在四种作用域：函数、文件、块和函数原型。
（\textit{函数原型}指定义函数类型的函数声明。）

\paragraph{}
标号名是唯一一种具有\textit{函数作用域}的标识符。它可以用于（\tm{goto}语句中）其
出现的函数中任一位置，由其语法形态（跟上\tm{:}和语句）隐式声明。

\paragraph{}
任何其他标识符由其声明（声明子或类型说明符）所处位置确定作用域。如果声明该标识符
的声明子或类型说明符处理任何块或参数列表之外，则标识符具有\textit{文件作用域}，
在翻译单元结束处结束。如果声明标识符的声明符或类型说明符出现在块内或函数定义中的
参数声明列表中，则该标识符具有\textit{块作用域}，终止于关联块的末尾。如果声明标
识符的声明符或类型说明符出现在函数原型（不是函数定义的一部分）中的参数声明列表
中，则该标识符具有\textit{函数原型作用域}，终止于函数声明符的末尾。如果标识符在
同一命名空间中指定了两个不同的实体，则作用域可能会重叠。如果是这样，一个实体的作
用域（\textit{内作用域}）将严格结束在另一个实体的作用域（\textit{外作用域}）之
前。在内作用域中，标识符指代内作用域内声明的实体；在外作用域内声明的实体在内作用
域内被\textit{隐藏}（且不可见）。

\paragraph{}
除非另有明确规定，否则本国际标准使用``标识符''一词指某个实体（与句法结构相反），
它指相关命名空间中的实体，其声明在标识符出现时可见。

\paragraph{}
当且仅当两个标识符的作用域在同一点终止时，它们才具有\textit{相同的作用域}。

\paragraph{}
结构、联合和枚举标记的作用域在声明标记的类型说明符中的标记出现之后开始。每个枚举
常量的作用域在枚举子列表中的定义枚举子出现之后开始。任何其他标识符的作用域都在其
声明符完成之后开始。

\paragraph{}
作为一种特殊情况，类型名（不是标识符的声明）被认为具有一个作用域，该作用域如同从
类型名中出现如果未被省略标识符的位置之后开始。

\fwdref{6.7，6.5.2.2，6.9.1，6.4.2，6.10.3，6.2.3，6.10.2，6.8}

\ssect{标识符链接}{lang.concept.link}
\paragraph{}
可以使在不同作用域或同一作用域中声明多次的标识符通过称为\textit{链接}的过程引用
同一对象或函数。\footnote{不同的标识符之间没有链接。} 存在三种链接：外部、内部和
无链接。

\paragraph{}
在构成整个程序的一组翻译单元和库中，具有\textit{外部链接}的特定标识符的每个声明
都表示相同的对象或函数。在一个翻译单元中，具有\textit{内部链接}的标识符的每个声
明都表示相同的对象或函数。\textit{没有链接}的标识符的每个声明都表示一个唯一的实
体。

\paragraph{}
如果对象或函数的文件作用域标识符的声明包含存储类说明符\tm{static}，则该标识符具
有内部链接。\footnote{仅当函数声明在文件作用域内时，它才能包含静态存储类说明符；
请参见\ref{lang.dcl.stc}。}

\paragraph{}
对于用存储类说明符\tm{extern}声明的标识符，在该标识符的先前声明可见的作用域内，
\footnote{如\ref{lang.concept.scope}所述，后一个声明可能隐藏前一个声明。} 如果先
前声明指定内部或外部链接，则后面声明中标识符的链接与先前声明中指定的链接相同。如
果前面的声明不可见，或者前面的声明没有指定链接，那么标识符具有外部链接。

\paragraph{}
如果函数的标识符声明没有存储类说明符，则其链接的确定与使用存储类说明符
\tm{extern}声明的链接完全相同。如果对象的标识符声明具有文件作用域，并且没有存储
类说明符，则其链接是外部的。

\paragraph{}
以下标识符没有链接：声明为对象或函数以外的任何对象的标识符；声明为函数参数的标识
符；声明为没有存储类说明符\tm{extern}的对象的块作用域标识符。

\paragraph{}
如果在翻译单元中，相同的标识符同时具有内部链接和外部链接，则行为未定义。

\ssect{标识符命名空间}{lang.concept.namespace}
\paragraph{}
如果在翻译单元的任何位置都可以看到特定标识符的多个声明，那么语法上下文将对引用不
同实体的使用消除歧义。因此不同类别的标识符具有不同\textit{命名空间}，如下所示：
\begin{itemize}
  \item{\textit{标号名}（由标号声明和使用的语法来消除歧义）；}
  \item{结构，联合和枚举\textit{标记}（\textit{tags}）（由跟在关键字\tm{struct}，
    \tm{union}或\tm{enum}\footnote{尽管存在三种可能，实际只有一种命名空间。}后面
    来消除歧义）；}
  \item{结构或联合成员；每个结构或联合成员都有单独的命名空间（由通过\tm{.}或
    \tm{->}运算符访问成员的表达式类型来消除歧义）；}
  \item{所有其他标识符，称为\textit{普通标识符}（\textit{ordinary identifiers}）
    （在普通声明子中声明或声明为枚举常量）。}
\end{itemize}

\fwdref{6.7.2.2，6.8.1，6.7.2.1，6.5.2.3，6.7.2.3，6.8.6.1}

\ssect{对象存储期}{lang.concept.storage}
\paragraph{}
对象具有\textit{存储期}，以确定其生存期。有四种存储期：静态、线程、自动和分配。
分配存储期在第\ref{lib.util.mem}节描述。

\paragraph{}
对象的生存期指程序执行的一段期间，该期间内保证为对象保留存储。在生命期内，对象存
在，有一个常量地址\footnote{术语``常量地址''意味着在不同时间创建的两个对象的指针
可能相等。同一程序的两个不同执行期间内的地址可能不同。}，并保留其最后存储的值。
\footnote{易失性对象不需要显式的最后存储值。} 如果对象在其生存期之外被引用，则行
为未定义。当指针指向的对象（或刚刚指向的对象）到达其生命周期的末尾时，指针的值将
变得不确定。

\paragraph{}
标识符声明时没有存储类说明符\tm{\_\_Thread\_local}且具有外部或内部链接或存储类说
明符\tm{static}的对象，具有\textit{静态存储期}。它的生存期是程序的整个执行过程，
它的存储值在程序启动之前仅初始化一次。

\paragraph{}
用存储类说明符\tm{\_\_Thread\_local}声明其标识符的对象具有\textit{线程存储期}。
它的生存期是创建该对象的线程的整个执行过程，其存储值在线程启动时初始化。每个线程
有一个不同的对象，在表达式中声明名称的使用指向计算该表达式的线程关联的对象。试图
从与对象关联的线程以外的线程间接访问具有线程存储期的对象的结果由实现定义。

\paragraph{}
标识符声明为不带链接且不带存储类说明符\tm{static}的对象具有\textit{自动存储期}，
某些复合字面值也是如此。试图从与对象关联的线程以外的线程间接访问具有自动存储期对
象的结果由实现定义。

\paragraph{}
对于不是变长数组类型的对象，其生存期从进入与之关联的块开始，直到该块的执行以任何
方式结束为止。（进入一个包含的块或调用一个函数会挂起但不会结束当前块的执行。）如
果以递归方式进入块，则每次都会创建一个新的对象实例。对象的初始值不确定。如果为对
象指定了初始化，则每次在块的执行中到达声明或复合字面值时都会执行初始化；否则，每
次达到声明时，值都会变得不确定。

\paragraph{}
对于具有变长数组类型的对象，它的生存期从对象的声明直到程序的执行离开声明作用域。
\footnote{离开包含声明的最内块，或者在声明之前跳到该块或嵌入块中的某个点，将离开
声明的作用域。} 如果以递归方式进入作用域，则每次都会创建对象的新实例。对象的初始
值不确定。

\paragraph{}
具有结构或联合类型的非左值表达式，其中结构或联合包含具有数组类型的成员（递归地包
括所有包含的结构和联合的成员）指向一个具有自动存储期和\textit{临时生存期}的对象。
\footnote{访问数组成员时隐式获取此类对象的地址。} 其生存期从计算表达式时开始，其
初始值为表达式的值。它的生存期在包含全表达式或完整声明子的计算结束时结束。任何修
改临时生存期对象的尝试都会导致未定义行为。

\fwdref{6.7.6.2，6.5.2.5，6.7.6，6.5.2.2，6.7.9，6.8}

\ssect{类型}{lang.concept.type}
\paragraph{}
存储在对象中或由函数返回的值的含义由用于访问该值的表达式的类型决定。（声明为对象
的标识符是最简单的此类表达式；类型在标识符声明中指定。）类型分为对象类型（描述对
象的类型）和函数类型（描述函数的类型）。在翻译单元的不同点上，对象类型可能不完整
（缺乏足够的信息来确定该类型对象的大小）或完整（具有足够的信息）。\footnote{类型
在整个翻译单元中可能是不完整的或完整的，也可能在翻译单元中的不同点改变状态。}

\paragraph{}
声明为\tm{\_Bool}类型的对象存储值$0$和$1$。

\paragraph{}
声明为\tm{char}类型的对象足够存储基本执行字符集的任何成员。如果基本执行字符集的
成员存储在\tm{char}对象中，则其值保证为非负。如果\tm{char}对象中存储了任何其他字
符，则其值由实现定义，但应在该类型可以表示的值范围内。

\paragraph{}
有五种\textit{标准有符号整型}，分别被指定为\tm{signed char}、\tm{short int}、
\tm{int}、\tm{long int}和\tm{long long int}。（这些类型和其他类型可以用其他几种
方式指定，如\ref{lang.dcl.type}所述。）也可能存在实现定义的\textit{扩展有符号整
型}。\footnote{实现定义的关键字应具有\ref{lib.intro.reserved}节所述的保留用于任
何用途的标识符形式。} 标准和扩展有符号整型统称为\textit{有符号整型}。
\footnote{因此，本标准中关于有符号整型的任何语句也适用于扩展有符号整型。}

\paragraph{}
声明为\tm{signed char}类型的对象与``普通''\tm{char}对象占用相同的存储量。
``普通''\tm{int}对象具有执行环境体系结构建议的自然大小（足够存储头
\tm{<limits.h>}中定义的\tm{INT\_MIN}到\tm{INT\_MAX}范围内的任何值）。

\paragraph{}
对于每个有符号整型，都有一个对应的（但不同的）无符号整型（用关键字\tm{unsigned}
指定），它使用相同的存储量（包括符号信息），并且具有相同的对齐要求。与标准有符号
整型相对应的\tm{\_Bool}类型和无符号整型是\textit{标准无符号整型}。与扩展有符号整
型相对应的无符号整型是\textit{扩展无符号整型}。标准和扩展无符号整数类型统称为
\textit{无符号整型}。\footnote{因此，本标准中关于无符号整型的任何语句也适用于扩
展无符号整型。}

\paragraph{}
标准有符号整型和标准无符号整型统称为\textit{标准整型}；扩展有符号整型和扩展无符
号整型统称为\textit{扩展整型}。

\paragraph{}
对具有相同符号性和不同整数转换秩的任意两个整型（见\ref{lang.conv.arith.rank}），
整数转换秩较小的类型的值范围是另一类型值的子范围。

\paragraph{}
有符号整型的非负值范围是对应无符号整型的子范围，并且每种类型中相同值的表示形式相
同。\footnote{相同的表示和对齐要求意味着作为函数参数、函数返回值和联合成员的可互
换性。} 涉及无符号操作数的计算永远不会溢出，因为如果结果不能用无符号整型表示，则
结果取比结果类型可表示最大值加一之后的模。

\paragraph{}
存在三种实浮点类型：\tm{float}、\tm{double}和\tm{long double}。\footnote{见``未
来语言方向''（\ref{lang.dir.float}）。 } \tm{float}类型的值集是\tm{double}类型值
集的子集；\tm{double}类型的值集是\tm{long double}类型值集的子集。

\paragraph{}
存在三种\textit{复类型}，分别是\tm{float \_Complex}、\tm{double \_Complex}和
\tm{long double \_Complex}。\footnote{虚数类型规范见附录\ref{comparith}。}（复类
型是条件特性，不要求实现支持；请参见\ref{lang.ppdir.predef.cond}。）实浮点类型和
复类型统称为\textit{浮点类型}。

\paragraph{}
每个浮点类型都有一个对应的实类型，它始终是一个实浮点类型。对于实浮点类型，它是相
同的类型。对于复类型，它是通过从类型名称中删除关键字\tm{\_Complex}后的类型。

\paragraph{}
复类型具有与正好包含两个对应实类型元素的数组类型相同的表示和对齐要求；第一个元素
等于复数的实数部分，第二个元素等于复数的虚数部分。

\paragraph{}
\tm{char}类型、有符号和无符号整型以及浮点类型统称为\textit{基本类型}。基本类型是
完整的对象类型。即使实现将两个或多个基本类型定义为具有相同的表示，它们仍然是不同
的类型。\footnote{ 实现可以定义新的关键字，这些关键字提供了指定基本（或任何其他）
类型的可选方法；这不会违反所有基本类型都不同的要求。实现定义的关键字应具有
\ref{lib.intro.reserved}中所述的保留用于任何用途的标识符形式。}

\paragraph{}
三种类型\tm{char}、\tm{signed char}和\tm{unsigned char}统称为\textit{字符类型}。
实现应将\tm{char}定义为与\tm{signed char}或\tm{unsigned char}具有相同的范围、表
示和行为。\footnote{\tm{<limits.h>}中定义的\tm{CHAR\_MIN}将具有值$0$或
\tm{SCHAR\_MIN}中的一个，这可用于区分这两个选项。无论做出什么选择，\tm{char}都是
与其他两个类型不同的类型，并且两者都不兼容。}

\paragraph{}
\textit{枚举}由一组命名的整型常量值组成。每个不同的枚举构成不同的\textit{枚举类
型}。

\paragraph{}
类型\tm{char}、有符号和无符号整型以及枚举类型统称为\textit{整型}。整型和实浮点类
型统称为\textit{实类型}。

\paragraph{}
整型和浮点类型统称为\textit{算术类型}。每个算术类型属于一个\textit{类型域}：
\textit{实类型域}包含实类型，\textit{复类型域}包含复类型。

\paragraph{}
\tm{void}类型值集为空；它是无法完整的不完整对象类型。

\paragraph{}
可以从对象和函数类型构造任意数量的\textit{派生类型}，如下所示：
\begin{itemize}
  \item{\textit{数组类型}描述一组连续分配的非空对象，对象具有特定成员对象类型
    （称为\textit{元素类型}）。每当指定数组类型时，元素类型应完整。数组类型由其
    元素类型和数组中的元素个数刻画。数组类型说成是从它的元素类型派生，如果它的元
    素类型是$T$，则数组类型有时称为``$T$的数组''。从元素类型构造数组类型称为``数
    组类型派生''。}
  \item{\textit{结构类型}描述了一组顺序分配的非空成员对象（在某些情况下还有一
    个不完整的数组），每个对象都有一个可选的指定名称和可能不同的类型。}
  \item{\textit{联合类型}描述了一组重叠的非空成员对象，每个成员对象都有一个可选
    的指定名称和可能不同的类型。}
  \item{\textit{函数类型}描述具有指定返回类型的函数。函数类型由其返回类型及其参
    数的数量和类型刻画。函数类型说成是从其返回类型派生，如果它的返回类型是$T$，
    则该函数类型有时称为``返回$T$的函数''。从返回类型构造函数类型称为``函数类型
    派生''。}
  \item{\textit{指针类型}可以派生自函数类型或对象类型，称为\textit{引用类型}。指
    针类型描述一个对象，该对象的值提供对被引用类型的实体的引用。从引用类型$T$派
    生的指针类型有时称为``指向$T$的指针''。从引用类型构造指针类型称为``指针类型
    派生''。指针类型是完整的对象类型。}
  \item{\textit{原子类型}描述由\tm{\_Atomic(typename)}结构指定的类型。
    （原子类型是条件特性，不要求实现支持；参见\ref{lang.ppdir.predef.cond}。）}
\end{itemize}
这些构造派生类型的方法可以递归应用。

\paragraph{}
算术类型与指针类型统称\textit{标量类型}。数组和结构类型统称\textit{聚合类型}。
\footnote{注意聚合类型不包括联合类型，因为联合类型的对象一次只能包含一个成员。}

\paragraph{}
未知大小的数组类型是不完整的类型。对于该类型的标识符，可以通过在后面的声明中指定
大小（具有内部或外部链接）来完成。未知内容的结构或联合类型（如
\ref{lang.dcl.type.tag}所述）是不完整的类型。对于该类型的所有声明，通过稍后在同
一作用域内声明具有其定义内容的同一结构或联合标记来完成。

\paragraph{}
如果类型不完整且不是可变长度数组类型，则该类型具有\textit{已知的常量大小}。

\paragraph{}
数组、函数和指针类型统称为\textit{派生声明子类型}。类型$T$的\textit{声明子类型派
生}是通过应用从$T$的数组类型、函数类型或指向$T$的指针类型派生的派生声明子类型的
构造。

\paragraph{}
类型由其\textit{类型范畴}刻画，类型范畴是派生类型的最外层派生（如上文派生类型构造
中所述），或如果类型不包含派生类型，则是类型本身。

\paragraph{}
到目前为止提到的任何类型都是\textit{未限定类型}。每个未限定类型都有其类型
\footnote{见\ref{lang.dcl.qual}中关于限定数组和函数类型。}的几个\textit{限定版
本}，对应于\tm{const}、\tm{volatile}和\tm{restrict}限定符中的一个、两个或全部三
个的组合。类型的限定或未限定版本是属于同一类型范畴且具有相同表示和对齐要求的不同
类型。\footnote{相同的表示和对齐要求意味着作为函数参数、函数返回值和联合成员的可
互换性。\label{interchg}} 派生类型不由派生它的类型的限定符（如果有）限定。

\paragraph{}
此外，还有\tm{\_Atomic}限定符。使用\tm{\_Atomic}限定符表示原子类型。原子类型的大
小、表示和对齐方式不必与相应的非限定类型相同。因此，只要允许类型的原子版本以及类
型的其他限定版本，本标准就显式使用短语``原子、限定或非限定类型''。短语``限定或非
限定类型''，未特别提及原子时，不包括原子类型。

\paragraph{}
指向\tm{void}的指针应与指向字符类型的指针具有相同的表示和对齐要求。
\textsuperscript{\ref{interchg}} 同样，指向兼容类型的限定或未限定版本的指针应具
有相同的表示和对齐要求。结构类型的所有指针应具有彼此相同的表示和对齐要求。联合类
型的所有指针应具有彼此相同的表示和对齐要求。指向其他类型的指针不需要具有相同的表
示或对齐要求。

\paragraph{}
\ex ``\tm{float *}''指类型``指向\tm{float}的指针''。其类型范畴为指针而不是浮点类
型。该类型的const限定版本为``\tm{float * const}''，而``\tm{const float *}''不是
一个限定类型 --- 其类型为``指向const限定的\tm{float}的指针''，是限定类型的指针。

\paragraph{}
\ex ``\tm{struct tag (*[5])(float)}''指类型``指向返回\tm{struct tag}的函数的指针
的数组''。数组长度为$5$，函数有一个\tm{float}类型的参数。其类型范畴为数组。

\fwdref{6.2.7，6.7}

\ssect{类型表示}{lang.concept.repr}
\sssect{概论}{lang.concept.repr.general}
\paragraph{}
除本节说明外，所有类型的表示都未指明。

\paragraph{}
除了位字段之外，对象由一个或多个连续的字节序列组成，其字节数、顺序和编码为显式指
定，或由实现定义。

\paragraph{}
存储在无符号位字段中的值和\tm{unsigned char}类型的对象应使用纯二进制记号表示。
\footnote{一种使用二进制数字$0$和$1$的整数的位置表示法，其中用连续位表示的值是相
加的，以$1$开头，并乘以$2$的连续整数幂，可能最高位除外。（改编自\textit{American
National Dictionary for Information Processing Systems}。）一个字节包含
\tm{CHAR\_BIT}位，\tm{unsigned char}类型的值在$0$到$2^{CHAR\_BIT-1}$之间。}

\paragraph{}
存储在任何其他对象类型的非位字段对象中的值包含$n\times$\texttt{CHAR\_BIT}位组成，
其中$n$是该类型对象的以字节为单位的大小。该值可以复制到
\tm{unsigned char[}$n$\tm{]}类型的对象中（例如，通过\tm{memcpy}）；生成的字节集
称为该值的\textit{对象表示}。位域中存储的值由$m$位组成，其中$m$是为位域指定的大
小。对象表示是位域包含在可寻址存储单元中的一组$m$个位。具有相同对象表示形式的两
个值（NaN除外）相等，但相等的值可能具有不同的对象表示形式。

\paragraph{}
某些对象表示不需要表示对象类型的值。如果对象的存储值具有这样的表示形式，并且由非
字符类型的左值表达式读取，则行为未定义。如果这样的表示是由一个副作用产生的，该副
作用通过非字符类型的左值表达式修改对象的全部或任何部分，则行为未定义。
\footnote{因此，可以将自动变量初始化为陷阱表示，而不会导致未定义的行为，但只有将
适当的值存储在该变量中，才能使用该变量的值。} 这种表示称为陷阱表示。

\paragraph{}
当一个值存储在一个结构或联合类型的对象（包括成员对象）中时，对应于任何填充字节的
对象表示形式的字节值未指定。\footnote{因此，例如结构分配不需要复制任何填充位。}
结构或联合对象的值绝不是陷阱表示，即使结构或联合对象的成员的值可能是陷阱表示。

\paragraph{}
当一个值存储在联合类型的对象的成员中时，不对应于该成员但确实对应于其他成员的对象
表示形式的字节值未指定。

\paragraph{}
如果一个运算符应用于具有多个对象表示的值，则该对象表示将不会影响结果的值。
\footnote{当作为有效类型\tm{T}的对象时，具有相同有效类型\tm{T}的对象\tm{x}和
\tm{y}可能具有相同的值，但在其他上下文中具有不同的值。特别是，如果为T类型定义了
\tm{==}，那么\tm{x == y}并不意味着\tm{memcmp(\&x，\&y，sizeof(T)) == 0}。此外，
\tm{x == y}不一定意味着\tm{x}和\tm{y}具有相同的值；对\tm{T}类型值的其他操作可能
会区分它们。} 如果一个值存储在一个对象中，而该对象使用的类型对此值具有多个对象表
示，则未指定使用哪种表示，但不应生成陷阱表示。

\paragraph{}
原子类型对象的存取在\tm{memory\_order\_seq\_cst}语义下进行。

\fwdref{6.7，6.5，6.3.2.1，7.17.3}

\sssect{整型}{lang.concept.repr.int}
\paragraph{}
对于\tm{unsigned char}以外的无符号整型，对象表示的位应分为两组：值位和填充位（后
者不是必须）。如果有$N$个值位，则每个位应表示$1$到$2^{N−1}$之间的$2$的不同幂，使
得该类型的对象能够使用纯二进制表示法表示$0$到$2^{N−1}$之间的值；这称为值的表示。
任何填充位的值未指定。\footnote{填充位的某些组合可能会生成陷阱表示，例如填充位是
一个奇偶校验位。无论如何，有效值的任何算术运算都不能生成除作为异常条件的一部分之
外的陷阱表示，比如溢出，而无符号类型不会发生溢出。填充位的所有其他组合都是值位指
定的值的可选对象表示形式。}

\paragraph{}
对于有符号整型，对象表示的位应分为三组：值位、填充位和符号位。填充位不是必须；
\tm{signed char}不应该有任何填充位。只有一个符号位。每个值位的值应与相应无符号类
型的对象表示中的相同位具有相同的值（如果有符号类型中有$M$个值位，无符号类型中有
$N$个值位，则$M \le N$）。如果符号位为零，则不会影响结果值。如果符号位为$1$，则
应以下列方式修改该值：
\begin{itemize}
  \item{符号位为$0$的对应值取反（\textit{符号和量值}（\textit{sign and
    magnitude}））；}
  \item{符号位值为$-(2^M)$（\textit{二补码}（\textit{two's complement}））；}
  \item{符号位值为$-(2^M-1)$（\textit{一补码}（\textit{ones' complement}））；}
\end{itemize}
应用哪一个由实现定义，如符号位为$1$和所有值位为零的值（前两个），或带符号位和所
有值位为$1$（一补码）的值是陷阱表示还是正常值。在符号、量值和一补码的情况下，如
果该表示是一个正常值，则称为\textit{负零}。

\paragraph{}
如果实现支持负零，其应该仅能通过以下生成：
\begin{itemize}
  \item{运算符\tm{\&，|，\^，~，\textless{}\textless{}}和
    \tm{\textgreater{}\textgreater{}}，具有产生该值的操作数；}
  \item{运算符\tm{+，-，*，/}和\tm{\%}，其中一个操作数为负零，结果为零；}
  \item{基于以上情形的复合赋值运算符；}
\end{itemize}
未指明这些情况产生负零还是正常的零，以及当存于对象中时负零是否变成正常的零。

\paragraph{}
如果实现不支持负零，具有产生该值的操作数的运算符\tm{\&，|，\^，~，
\textless{}\textless{}}和\tm{\textgreater{}\textgreater{}}的行为未定义。

\paragraph{}
填充位的值未指定。\footnote{填充位的某些组合可能会生成陷阱表示，例如填充位是
一个奇偶校验位。无论如何，有效值的任何算术运算都不能生成除作为异常条件的一部分之
外的陷阱表示，比如溢出。填充位的所有其他组合都是值位指定的值的可选的对象表示。}
符号位为零的有符号整型的有效（非陷阱）对象表示是对应无符号类型的有效对象表示，且
应该表示相同值。对任何整型，所有位为零的对象表示应该是该类型的值零的表示。

\paragraph{}
整型的\textit{精度}指其用于表示值的位数，不包括符号位和填充位。整型的
\textit{宽度}与精度一样，但包括符号位；因此对无符号类型这两个值一样，而有符号类
型宽度比精度多一。

\ssect{兼容类型与合成类型}{lang.concept.compat}
\paragraph{}
两个相同类型为\textit{兼容类型}。额外的确定两个类型是否兼容的规则在类型说明
\ref{lang.dcl.type}，类型限定\ref{lang.dcl.qual}和声明子\ref{lang.dcl.decl}中描
述。\footnote{两个类型不需要完全等价才能兼容。} 另外，不同翻译单元中声明的两
个结构、联合或枚举类型的标记和成员满足以下要求，则它们是兼容的：如果一个声明了标
记，则另一个应使用相同的标记声明。如果在各自的翻译单元内的某个地方是完整的，则适
用以下附加要求：成员之间应存在一一对应的关系，使得每对对应的成员声明为兼容类型；
如果配对中的一个成员使用对齐说明符来声明，则另一个成员应用等效的对齐说明符声明；
如果配对中的一个成员使用名称声明，则另一个成员应该使用相同的名称声明。对于两个结
构，对应成员应该以相同的顺序声明。对于两个结构或联合体，对应的位域应该具有相同的
宽度。对于两个枚举，对应的成员应具有相同的值。

\paragraph{}
引用同一对象或函数的所有声明都应具有兼容类型；否则行为未定义。

\paragraph{}
\textit{合成类型}可以由两种兼容的类型构造；它是一种与这两种类型都兼容并满足以下
条件的类型：
\begin{itemize}
  \item{如两个类型均为数组类型，以下规则适用：
    \begin{itemize}
      \item{如其中一个是已知常量大小的数组，合成类型为该大小的数组。}
      \item{否则，如其中一个是变长数组，大小由未求值表达式指定，则行为未定义。}
      \item{否则，如其中一个是指定大小的变长数组，合成类型为该大小的变长数组。}
      \item{否则，如其中一个是未指定大小的变长数组，合成类型为未指定大小的变长数
        组。}
      \item{否则，两个类型均为未知大小的数组，合成类型为未知大小的数组。}
    \end{itemize}
    合成类型的元素类型为两个元素类型的合成类型。}
  \item{如果仅有一个是带参数类型列表（函数原型）的函数类型，则合成类型为带参数类
    型列表的函数原型。}
  \item{如果两个类型均为带参数类型列表的函数类型，合成参数类型列表中的参数类型为
    对应参数的合成类型。}
\end{itemize}
这些规则可以递归应用于两个类型派生自的类型。

\paragraph{}
对于具有内部或外部链接的标识符，其所在作用域中该标识符一个之前的声明可见，
\footnote{如\ref{lang.concept.scope}所述，后一个声明可能隐藏前一个声明。} 如果前
面的声明指定了内部或外部链接，则后面声明中的标识符类型将成为合成类型。

\fwdref{6.7.6.2}

\paragraph{}
\ex* 给定以下两个文件作用域声明：
\begin{lstlisting}
    int f(int (*)(), double (*)[3]);
    int f(int (*)(char*), double (*)[]);
\end{lstlisting}
为函数产生的合成类型为：
\begin{lstlisting}
    int f(int (*)(char*), double (*)[3]);
\end{lstlisting}

\ssect{对象对齐}{lang.concept.align}
\paragraph{}
完整的对象类型具有对齐要求，这些要求对可分配该类型对象的地址进行了限制。对齐是一
个实现定义的整数值，表示可以分配给定对象的连续地址之间的字节数。对象类型对该类型
的每个对象都施加对齐要求：可以使用\tm{\_Alignas}关键字请求更严格的对齐。

\paragraph{}
\textit{基本对齐}表示为小于或等于所有上下文中实现所支持的最大对齐的对齐，该对齐
等于\tm{\_Alignof(max\_align\_t)}。

\paragraph{}
\textit{扩展对齐}大于\tm{\_Alignof(max\_align\_t)}。是否支持任何扩展对齐以及支持
上下文由实现定义。具有扩展对齐要求的类型是\textit{过度对齐的类型}。
\footnote{每个过度对齐的类型都是或包含一个结构或联合类型，该结构或联合类型具有应
用扩展对齐的成员。}

\paragraph{}
对齐以\tm{size\_t}类型的值表示。有效的对齐仅包括由基本类型的\tm{\_Alignof}表达式
返回的所有值，以及附加的实现定义的一组值，可能为空。每个有效值应该为二的非负整数
幂。

\paragraph{}
对齐具有从\textit{弱}到\textit{强}或\textit{更严格}的顺序。更严格的对齐具有较大
的对齐值。满足对齐要求的地址也满足任何较弱的有效对齐要求。

\paragraph{}
完整类型的对齐要求可以使用\tm{\_AlignOf}表达式查询。类型\tm{char}、
\tm{signed char}和\tm{unsigned char}的对齐要求最低。

\paragraph{}
比较对齐是有意义的且提供了明显的结果：
\begin{itemize}
  \item{数值相等的两个对齐也相等。}
  \item{数值不等的两个对齐也不等。}
  \item{较大的对齐表示更严格的对齐。}
\end{itemize}

\sect{转换}{lang.conv}
\paragraph{}
一些运算符自动将操作数值从一种类型转换为另一种类型。本章节指定此类\textit{隐式转
换}所需的结果，以及由强制转换操作（显式转换）产生的结果。第
\ref{lang.conv.arith.usualarith}节中的列表总结了大多数普通运算符执行的转换；由第
\ref{lang.expr}节中对每个运算符的讨论进行补充。

\paragraph{}
除非另有明确说明，否则将操作数值转换为兼容类型不会导致值或表示形式发生更改。

\fwdref{6.5.4}

\ssect{算术操作数}{lang.conv.arith}
\sssect{布尔，字符与整数}{lang.conv.arith.rank}
\paragraph{}
每一个整型具有\textit{整型转换阶}，定义如下：
\begin{itemize}
  \item{两个有符号整型即使表示相同，其转换阶也不一样。}
  \item{有符号整型的阶应大于精度较低的有符号整型的阶。}
  \item{阶（\tm{long long int}）$>$阶（\tm{long int}）$>$阶（\tm{int}）$>$
    阶（\tm{short int}）$>$阶（\tm{signed char}）。}
  \item{任何无符号整型的阶应等于相应有符号整型的阶（如果有）。}
  \item{任何标准整型的阶应大于任何宽度相同的扩展整型的阶。}
  \item{阶（\tm{char}）$=$阶（\tm{signed char}）$=$阶（\tm{unsigned char}）。}
  \item{\tm{\_Bool}的阶小于所有其他标准整型的阶。}
  \item{枚举类型的阶等于兼容整型的阶（见\ref{lang.dcl.type.enum}）。}
  \item{扩展有符号整型相对于另一个具有相同精度的扩展有符号整型的阶由实现定义，但
    仍受用于确定整数转换阶的其他规则的约束。}
  \item{对于所有整型\tm{T1}、\tm{T2}和\tm{T3}，如果\tm{T1}的阶大于\tm{T2}，
    \tm{T2}的阶大于\tm{T3}，则\tm{T1}的阶大于\tm{T3}。}
\end{itemize}

\paragraph{}
在可以使用\tm{int}或\tm{unsigned int}的表达式中，可以使用以下内容：
\begin{itemize}
  \item{整型（\tm{int}或\tm{unsigned int}除外）对象或表达式，其整数转换阶小于或
    等于\tm{int}和\tm{unsigned int}的阶。}
  \item{\tm{\_Bool}，\tm{int}，\tm{signed int}或\tm{unsigned int}类型的位域。}
\end{itemize}
如果\tm{int}可以表示原始类型的所有值（如同宽度受限的位域），则该值将转换为
\tm{int}；否则将转换为\tm{unsigned int}。这些称为\textit{整型提升}。\footnote{整
型提升仅适用于：作为常规算术转换的一部分，应用于某些参数表达式、一元\tm{+}、
\tm{-}、和\tm{\~}运算符的操作数以及位移运算符的两个操作数，由各自的章节指定。}
所有其他类型都不受整型提升的影响。

\paragraph{}
整型提升保留值和符号。如前所述，``普通''\tm{char}是否被视为有符号由实现定义。

\fwdref{6.7.2.2，6.7.2.1}

\sssect{布尔类型}{lang.conv.arith.bool}
\paragraph{}
任何标量值转换为\tm{\_Bool}时，如果值等于$0$，则结果为$0$；否则结果为$1$。
\footnote{NaN不等于$0$，所以转换成$1$。}

\sssect{有符号和无符号整数}{lang.conv.arith.signed}
\paragraph{}
当一个整型的值被转换为除\tm{\_Bool}的另一个整型时，如果该值可以用新类型表示，则
该值不变。

\paragraph{}
否则，如果新类型为无符号，则通过重复加或减新类型可表示的最大值加一来转换该值，直
至该值在新类型的范围内。\footnote{该规则描述数学上而不是表达类型值的算术。}

\paragraph{}
否则，新类型为有符号，且值不能在其中表示；则结果或者由实现定义，或者产生实现定义
信号。

\sssect{实浮点与整型}{lang.conv.arith.fpint}
\paragraph{}
当实浮点类型的有限值转换为除\tm{\_Bool}以外的整型时，小数部分将被丢弃（即向零截
断）。如果整型不能表示整数部分的值，则行为未定义。\footnote{当实浮点类型的值转换
为无符号类型时，整型的值转换为无符号类型时执行的剩余操作不需要执行。因此，可移植
的实浮点值范围是$(-1,$\tm{U}\textit{type}\tm{\_MAX}$+1)$。}

\paragraph{}
当整型的值转换为实浮点类型时，如果要转换的值可以在新类型中精确表示，则该值不变。
如果要转换的值在可以表示的值范围内但不能精确表示，则结果是以实现定义的方式选择的
最接近的更高或最接近的较低可表示值。如果要转换的值超出了可以表示的值的范围，则行
为未定义。某些隐式转换的结果可能比新类型所要求的范围和精度更大（见
\ref{lang.conv.arith.usualarith}和\ref{lang.stmt.jmp.ret}）。

\sssect{实浮点类型}{lang.conv.arith.double}
\paragraph{}
当实浮点类型的值转换为实浮点类型时，如果要转换的值可以在新类型中精确表示，则该值
不变。如果要转换的值在可以表示的值范围内但不能精确表示，则结果是以实现定义的方式
选择的最接近的更高或最接近的较低可表示值。如果要转换的值超出可以表示的值的范围，
则行为未定义。某些隐式转换的结果可能比新类型所要求的范围和精度更大（见
\ref{lang.conv.arith.usualarith}和\ref{lang.stmt.jmp.ret}）。

\sssect{复类型}{lang.conv.arith.cmpl}
\paragraph{}
当复类型的值转换为另一个复类型时，实部和虚部都遵循对应实类型的转换规则。

\sssect{实数与复数}{lang.conv.arith.rcmpl}
\paragraph{}
当实类型的值转换为复类型时，复数结果值的实数部分由转换为相应实数类型的规则确定，
复数结果值的虚部为正零或无符号零。

\paragraph{}
当复类型的值转换为实类型时，将丢弃复数值的虚部，并根据对应实类型的转换规则转换实
数部分的值。

\sssect{常规算术转换}{lang.conv.arith.usualarith}
\paragraph{}
许多期望算术类型的操作数的运算符以类似的方式进行转换并产生结果类型。目的是确定操
作数和结果的通用\textit{实类型}。对于指定的操作数，每个操作数都会在不改变类型域
的情况下转换为其对应的实类型是公共实类型的类型。除非另有明确说明，否则公共实类型
也是结果的对应实类型，如果它们相同，则其类型域是操作数的类型域，否则是复类型。
这种模式称为\textit{常规算术转换}：
\begin{itemize}
  \item{首先，如果其中任一操作数的对应实类型为\tm{long double}，则另一个操作数将
    在不改变类型域的情况下转换为对应实类型为\tm{long double}类型。}
  \item{否则，如果其中一个操作数的对应实类型为\tm{double}，则另一个操作数将在不
    改变类型域的情况下转换为其对应实类型为\tm{double}的类型。}
  \item{否则，如果其中任一操作数的对应实类型为\tm{float}，则另一个操作数奖在不改
    变类型域的情况下转换为其对应实类型为\tm{float}的类型。\footnote{例如，
    \tm{double \_Complex}和\tm{float}的加法只需要将\tm{float}操作数转换为
    \tm{double}（并产生\tm{double \_Complex}结果）。}}
  \item{否则，对两个操作数执行整型提升。那么以下规则将适用于提升的操作数：
    \begin{itemize}
      \item{如果两个操作数具有相同类型则不再进行转换。}
      \item{否则，如果两个操作数都为有符号整型或都为无符号整型，则具有较小整型转
        换阶类型的操作数将转换为具有较大阶的操作数类型。}
      \item{否则，如果无符号整型的操作数的阶大于或等于另一个操作数类型的阶，则有
        符号整型的操作数将转换为无符号整型的操作数类型。}
      \item{否则，如果有符号整型的操作数类型可以表示无符号整型的操作数类型的所有
        值，则无符号整型的操作将转换为有符号整型的操作数类型。}
      \item{否则，两个操作数都转换为无符号整型，对应于有符号整型的操作数类型。}
    \end{itemize}}
\end{itemize}

\paragraph{}
浮点操作数的值和浮点表达式的结果可以表示在比类型所需的范围和精度更大的范围和精度
上；因此不改变类型。\footnote{转换和赋值操作符仍然需要删除额外的范围和精度。}

\ssect{其他操作数}{lang.conv.other}
\sssect{左值，数组和函数}{lang.conv.other.desig}
\paragraph{}
\textit{左值}是一个表达式（对象类型不是\tm{void}），可能指定一个对象；
\footnote{名称``左值''最初来自赋值表达式\tm{E1 = E2}，其中左操作数\tm{E1}需要是
（可修改的）左值。把它视为表示对象的``定位器''可能更好。有时被称为``右值''的东西
在本国际标准中被描述为``表达式的值''。\linebreak
左值的一个明显示例是对象的标识符。另一示例是，如果\tm{E}是作为指向对象的指针的一
元表达式，则\tm{*E}是指代\tm{E}所指向的对象的左值。} 如果左值在求值时没有指代对
象，则行为未定义。当一个对象被称为具有特定类型时，该类型由用于指定该对象的左值指
定。\textit{可修改左值}指非数组类型，非不完整的类型，非const限定类型，且如果是结
构或联合，则没有任何成员（递归地包括所包含聚合或联合的任何成员或元素）具有常限定
类型。

\paragraph{}
除作为\tm{sizeof}运算符的操作数，一元\tm{\&}运算符，\tm{++}运算符，\tm{-}运算符
或作为\tm{.}运算符或赋值运算符的左操作数，非数组类型的左值被转换为存储在指定对象
中的值（并且不再是左值）；称为\textit{左值转换}。如果左值具有限定类型，则该值具
有左值类型的非限定版本；另外，如果左值具有原子类型，则该值具有左值类型的非原子版
本；否则，该值具有左值的类型。如果左值具有不完整类型且不是数组类型则行为未定义。
如果左值指定了一个自动存储期的对象，该对象可以使用\tm{register}存储类声明（从不
使用其地址），并且该对象未初始化（未使用初始化声明，并且在使用之前未对其进行任何
赋值）），则行为未定义。

\paragraph{}
除作为\tm{sizeof}运算符或一元\tm{\&}运算符的操作数，或者是用于初始化数组的字符串
文字，否则将类型为``...类型的数组''的表达式转换成类型为``指向...类型的指针''的表
达式，指向数组对象的初始元素，且不是左值。如果数组对象具有寄存器存储类，则行为未
定义。

\paragraph{}
\textit{函数指示符}指具有函数类型的表达式。除作为\tm{sizeof}运算符\footnote{由于
不会发生此转换，因此\tm{sizeof}运算符的操作数仍然是函数指示符，并且违反了
\ref{lang.expr.unary.sizeof}中的约束。} 或一元\tm{\&}运算符的操作数，类型为``返
回...类型的函数''的函数指示符将转换成类型为``指向返回...类型的函数的指针''的表达
式。

\fwdref{6.5.3.2，6.5.16，7.19，6.7.9，6.5.2.4，6.5.3.1，6.5.3.4，6.5.2.3}

\sssect{void}{lang.conv.other.void}
\paragraph{}
\textit{void表达式}（具有\tm{void}类型的表达式）的（不存在）值不得以任何方式使用
，并且隐式或显式转换（除转换成\tm{void}）不应用于此类表达式。如果将任何其他类型
的表达式计算为\tm{void}表达式，则会丢弃其值或指示符。（\tm{void}表达式为其副作用
而求值。）

\sssect{指针}{lang.conv.other.ptr}
\paragraph{}
指向\tm{void}的指针可以转换为指向任何对象类型的指针。指向任何对象类型的指针可以
转换为指向\tm{void}的指针，然后再转回；结果应该等于原指针。

\paragraph{}
对于任何限定符$q$，指向非$q$限定类型的指针可以转换为指向该类型的$q$限定版本的指
针；存储在原指针和转换指针中的值应相等。

\paragraph{}
值为$0$的整型常量表达式或转换为\tm{void *}类型的这种表达式，称为\textit{空指针常
量}。\footnote{\tm{stddef.h}（或其他头）中的宏\tm{NULL}定义为零指针常量；见
\ref{lib.def}。} 如果将零指针常量转换为指针类型，则结果指针，称为\textit{零指针}
，与指向任何对象或函数的指针进行比较将保证不等。

\paragraph{}
将零指针转换为另一种指针类型会产生该类型的零指针。任何两个零指针都应该相等。

\paragraph{}
整数可以转换为任何指针类型。除之前指定，结果由实现定义，可能未正确对齐，可能不指
向引用类型的实体，或者可能是陷阱表示。\footnote{用于将指针转换为整数或整数到指针
的映射函数旨在与执行环境的寻址结构一致。}

\paragraph{}
任何指针类型都可以转换为整数类型。除之前指定外，结果由实现定义。如果结果无法以整
数类型表示，则行为未定义。结果不必在任何整数类型的值范围内。

\paragraph{}
指向对象类型的指针可以转换为指向不同对象类型的指针。如果对于引用的类型，结果指针
未正确对齐\footnote{通常，``正确对齐''这个概念是传递性的：如果指向类型A的指针正
确对齐地指向类型B的指针，而B指针又指向类型C的指针，则指向类型A的指针是正确对齐指
向类型C的指针}，则行为未定义。否则，当再次转换回时，结果将等于原指针。当指向对象
的指针转换为指向字符类型的指针时，结果指向对象的最低寻址字节。结果的连续增量（直
到对象的大小）产生指向对象的剩余字节的指针。

\paragraph{}
指向一种类型的函数的指针可以被转换为指向另一种类型的函数的指针并且再次返回；结果
应该等于原指针。如果转换的指针用于调用类型与引用类型不兼容的函数，则行为未定义。

\fwdref{6.5.4，6.5.9，7.20.1.4，6.5.16.1}

\sect{词法元素}{lang.lex}
\syntax
\paragraph{}
\synsym{token}
  \synprd{\nt{keyword}}
  \synprd{\nt{identifier}}
  \synprd{\nt{constant}}
  \synprd{\nt{string-literal}}
  \synprd{\nt{punctuator}}
\synsym{preprocessing-token}
  \synprd{\nt{header-name}}
  \synprd{\nt{identifier}}
  \synprd{\nt{pp-number}}
  \synprd{\nt{character-constant}}
  \synprd{\nt{string-literal}}
  \synprd{\nt{punctuator}}
  \synprd[]{除以上所列的每一个非空白字符}

\constraint
\paragraph{}
转换为标记的每个预处理标记应具有关键字，标识符，常量，字符串文本或标点符号的词法
形式。

\semantic
\paragraph{}
\textit{标记}（\textit{token}）是翻译阶段\ref{tpit7}和\ref{tpit8}中语言的最小词
法元素。标记的类别是包括关键字，标识符，常量，字符串文本和标点符号。预处理标记是
翻译阶段\ref{tpit3}到\ref{tpit6}中语言最小的词法元素。预处理标记的类别是包括头名
称，标识符，预处理数字，字符常量，字符串文本，标点符号和词法上不匹配其他预处理标
记类别的单个非空白字符。\footnote{在翻译阶段\ref{tpit4}内部使用了另一类别，即占
位标记（见\ref{lang.ppdir.macro.concat}）；它不能出现在源文件中。} 如果\tm{\sq}
或\tm{\dq}字符匹配最后一个类别，则行为未定义。预处理标记可以用\textit{空格}分隔
；这包括注释（稍后描述）或\textit{空白字符}（空格，水平制表符，换行符，垂直制表
符或换页符）或两者均有。如\ref{lang.ppdir}所述，在翻译阶段\ref{tpit4}的某些情况
下，空格（或不存在）不仅仅是预处理标记分隔。空格可能只出现在预处理标记中作为头名
称的一部分或在字符常量或字符串文本中的引号字符之间。

\paragraph{}
如果输入流到达某个的字符被解析为预处理标记，下一个预处理标记是可能构成一个预处理
标记的最长序列。此规则有一个例外：头名称预处理标记仅在\tm{\#include}预处理指令
和\tm{\#pragma}指令内的实现定义位置中被识别。在这样的上下文中，可以是头名称或字
符串文字的字符序列被识别为前者。

\paragraph{}
\ex 程序片段\tm{1Ex}被解析为预处理数字标记（不是一个有效的浮点或整型常量标记），
即使解析为预处理标记\tm{1}和\tm{Ex}可能产生有效表达式（例如，如果\tm{Ex}是定义为
\tm{+1}的宏。类似地，程序片段\tm{1E1}被解析为预处理数字（一个是有效的浮点常量标
记），无论\tm{E}是否是宏名。

\paragraph{}
\ex 程序片断\tm{x+++++y}被分析成\tm{x ++ ++ + y}，违背了自增运算符约束，即使分析
成\tm{x ++ + ++ y}可以产生正确的表达式。

\fwdref{6.4.4.4，6.4.9，6.5，6.4.4.2，6.4.7，6.10.3，6.5.2.4，6.5.3.1，6.10，
6.4.8，6.4.5}

\ssect{关键字}{lang.lex.keyword}
\syntax
\paragraph{}
\synsym[one of]{keyword}
\bgroup
\newcommand{\kwgrp}[4][\linebreak]{\synprd[#1]{\makebox[24em]{
      \makebox[8em][l]{\tm{#2}}
      \makebox[8em][l]{\tm{#3}}
      \makebox[8em][l]{\tm{#4}}}}}
  \kwgrp{auto}      {if}        {unsigned}
  \kwgrp{break}     {inline}    {void}
  \kwgrp{case}      {int}       {volatile}
  \kwgrp{char}      {long}      {while}
  \kwgrp{const}     {register}  {\_Alignas}
  \kwgrp{continue}  {restrict}  {\_Alignof}
  \kwgrp{default}   {return}    {\_Atomic}
  \kwgrp{do}        {short}     {\_Bool}
  \kwgrp{double}    {signed}    {\_Complex}
  \kwgrp{else}      {sizeof}    {\_Generic}
  \kwgrp{enum}      {static}    {\_Imaginary}
  \kwgrp{extern}    {struct}    {\_Noreturn}
  \kwgrp{float}     {switch}    {\_Static\_assert}
  \kwgrp{for}       {typedef}   {\_Thread\_local}
  \kwgrp[]{goto}    {union}     {}
\egroup

\semantic
\paragraph{}
上述标记（大小写敏感）保留用作关键字（翻译阶段\ref{tpit7}和\ref{tpit8}），不得另
行使用。关键字\tm{\_Imaginary}为指定虚类型而保留。\footnote{虚类型的一种可能的规
范见附录\ref{comparith}。}

\ssect{标识符}{lang.lex.id}
\sssect{概论}{lang.lex.id.general}
\syntax
\paragraph{}
\synsym{identifier}
\synprd{\nt{identifier-nondigit}}
\synprd{\nt{identifier identifier-nondigit}}
\synprd{\nt{identifier digit}}
\synsym{identifier-nondigit}
\synprd{\nt{nondigit}}
\synprd{\nt{universal-character-name}}
\synprd{其他实现定义字符}
\synsym[one of]{nondigit}
\synprd{\tm{\_  a b c d e f g h i j k l m}}
\synprd{\tm{\ \ n o p q r s t u v w x y z}}
\synprd{\tm{\ \ A B C D E F G H I J K L M}}
\synprd{\tm{\ \ N O P Q R S T U V W X Y Z}}
\synsym[one of]{digit}
\synprd[]{\tm{0 1 2 3 4 5 6 7 8 9}}

\semantic
\paragraph{}
标识符是由非数字字符（包括下划线\tm{\_}、小写和大写拉丁字母以及其他字符）和数字
组成的序列，用于指定\ref{lang.concept.scope}中所述的一个或多个实体。小写和大写字
母是不同的。标识符的最大长度没有特定限制。

\paragraph{}
标识符中的每个通用字符名称应指定一个字符，其ISO/IEC 10646中的编码属于
\ref{uchar.range}中规定的范围之一。\footnote{在链接器不能接受扩展字符的系统上，
可以使用通用字符名的编码来形成有效的外部标识符。例如，某些未使用的字符或字符序列
可用于将\tm{\bs{}u}编码为通用字符名。扩展字符可能产生一个长的外部标识符。} 初始
字符不应是表示字符编码属于\ref{uchar.disallowed}规定范围之一的通用字符名。实现可
能允许不属于基本源字符集的多字节字符出现在标识符中；允许哪些字符及其与通用字符名
的对应关系由实现定义。

\paragraph{}
当预处理标记在翻译阶段\ref{tpit7}转换为标记时，如果预处理标记可以转换为关键字或
标识符，则它将转换为关键字。

\implimit
\paragraph{}
如\ref{env.env.limit.trans}中所讨论的，实现可以限制标识符中有意义的初始字符的数
量；\textit{外部名称}（具有外部链接的标识符）的限制可能比\textit{内部名称}（宏名
称或没有外部链接的标识符）的限制更严格。标识符中有意义的字符数由实现定义。

\paragraph{}
任何有意义字符不同的标识符都是不同的标识符。如果两个标识符仅在无意义字符上不同，
则行为未定义。

\fwdref{6.4.3，6.10.3}

\sssect{预定义标识符}{lang.lex.id.predef}
\semantic
\paragraph{}
翻译器应该隐式声明标识符\tm{\_\_func\_\_}，如同每一个函数定义的起始花括号紧跟上
声明
\begin{lstlisting}
    static const char __func__[] = "function-name";
\end{lstlisting}
这里\textit{function-name}为词法包含函数名。\footnote{由于名称\tm{\_\_func\_\_}
保留给实现（\ref{lib.intro.reserved}）使用，如果使用名称\tm{\_\_func\_\_}显式声
明任何其他标识符，则行为未定义。}

\paragraph{}
此名称如同隐式声明用源字符集书写然后转换为执行字符集进行编码，如翻译阶段
\ref{tpit5}所示。

\paragraph{}
\ex* 考虑代码段：
\begin{lstlisting}
    #include <stdio.h>
    void myfunc(void) {
      printf("%s\n", __func__);
      /* ... */
    }
\end{lstlisting}
每次调用函数将向标准输出流打印：
\begin{lstlisting}
    myfunc
\end{lstlisting}

\fwdref{6.9.1}

\ssect{通用字符名}{lang.lex.univ}
\syntax
\paragraph{}
\synsym{universal-character-name}
  \synprd{\tm{\bs{}u} \nt{hex-quad}}
  \synprd{\tm{\bs{}U} \nt{hex-quad hex-quad}}
\synsym{hex-quad}
  \synprd[]{\nt{hexadecimal-digit hexadecimal-digit hexadecimal-digit
                hexadecimal-digit}}

\constraint
\paragraph{}
通用字符名不应指定短标识符小于00A0的字符，除0024（\tm{\$}）、0040（\tm{@}）或
0060（\tm{\sq}）外，也不应指定D800到DFFF范围内的字符。\footnote{这些禁止的字符是
基本字符集中的字符以及ISO/IEC 10646为控制字符、DELETE字符和S区域（保留供UTF-16使
用）保留的代码位置。}

\desc
\paragraph{}
通用字符名可用于标识符，字符常量和字符串文本中，以表示不属于基本字符集中的字符。

\semantic
\paragraph{}
通用字符名\tm{\bs{}U}\textit{nnnnnnnn}表示8位数字短标识符（由ISO/IEC 10646指定）
为\linebreak\textit{nnnnnnnn}\footnote{字符的短标识符首次在ISO/IEC
10646-1:1993/Amd.9:1997中指定。}的字符。类似的，通用字符名
\tm{\bs{}u}\textit{nnnn}表示4位数字短标识符为\textit{nnnn}的字符（其8位数字短标
识符为0000\textit{nnnn}）。

\ssect{常量}{lang.lex.const}
\syntax
\paragraph{}
\synsym{constant}
  \synprd{\nt{integer-constant}}
  \synprd{\nt{floating-constant}}
  \synprd{\nt{enumeration-constant}}
  \synprd[]{\nt{character-constant}}

\constraint
\paragraph{}
每个常量应具有类型且常量值应在其类型可表示值范围内。

\semantic
\paragraph{}
每个常量具有类型，由其形式和值确定，如后文详述。

\sssect{整数常量}{lang.lex.const.int}
\syntax
\paragraph{}
\synsym{integer-constant}
  \synprd{\nt{decimal-constant integer-suffix$_{opt}$}}
  \synprd{\nt{octal-constant integer-suffix$_{opt}$}}
  \synprd{\nt{hexadecimal-constant integer-suffix$_{opt}$}}
\synsym{decimal-constant}
  \synprd{\nt{nonzero-digit}}
  \synprd{\nt{decimal-constant digit}}
\synsym{octal-constant}
  \synprd{\tm{0}}
  \synprd{\nt{octal-constant octal-digit}}
\synsym{hexadecimal-constant}
  \synprd{\nt{hexadecimal-prefix hexadecimal-digit}}
  \synprd{\nt{hexadecimal-constant hexadecimal-digit}}
\synsym[one of]{hexadecimal-prefix}
  \synprd{\tm{0x 0X}}
\synsym[one of]{nonzero-digit}
  \synprd{\tm{0 1 2 3 4 5 6 7 8 9}}
\synsym[one of]{octal-digit}
  \synprd{\tm{0 1 2 3 4 5 6 7}}
\synsym[one of]{hexadecimal-digit}
  \synprd{\tm{0 1 2 3 4 5 6 7 8 9}}
  \synprd{\tm{a b c d e f}}
  \synprd{\tm{A B C D E F}}
\synsym{integer-suffix}
  \synprd{\nt{unsigned-suffix long-suffix$_{opt}$}}
  \synprd{\nt{unsigned-suffix long-long-suffix}}
  \synprd{\nt{long-suffix unsigned-suffix$_{opt}$}}
  \synprd{\nt{long-long-suffix unsigned-suffix$_{opt}$}}
\synsym[one of]{unsigned-suffix}
  \synprd{\tm{u U}}
\synsym[one of]{long-suffix}
  \synprd{\tm{l L}}
\synsym[one of]{long-long-suffix}
  \synprd[]{\tm{ll LL}}

\desc
\paragraph{}
整数常量以数字开始，但没有小数点或指数部分。可能有前缀指定其基和后缀指定其类型。

\paragraph{}
十进制常数以非零数字开头，由一系列十进制数字组成。八进制常量由前缀\tm{0}（可选）
和数字\tm{0}到\tm{7}的序列组成。十六进制常量由前缀\tm{0x}或\tm{0X}后跟十进制数字
序列和字母\tm{a}（或\tm{A}）到\tm{f}（或\tm{F}）组成，分别具有值10到15。

\semantic
\paragraph{}
十进制常量的值以10为基数计算；八进制常量的值以8为基数计算；十六进制常量的值以16
为基数计算。词法上第一个数字是最高位。

\paragraph{}
整数常量的类型是对应列表中可以表示其值的第一个。
\begin{table}
  \newcommand{\li}{\tm{long int}}
  \newcommand{\lli}{\tm{long long int}}
  \newcommand{\ui}{\tm{unsigned int}}
  \newcommand{\uli}{\tm{unsigned long int}}
  \newcommand{\ulli}{\tm{unsigned long long int}}
  \centering
  \begin{tabular}{l||l|l}
    后缀 & 十进制常量 & 八进制或十六进制常量                                  \\
    \hline\hline
    无 & \tm{int} & \tm{int}                                                  \\
       & \li      & \lli                                                      \\
       & \lli     & \li                                                       \\
       &          & \uli                                                      \\
       &          & \lli                                                      \\
       &          & \ulli                                                     \\
    \hline
    \tm{u}或\tm{U} & \ui   & \ui                                              \\
                   & \uli  & \uli                                             \\
                   & \ulli & \ulli                                            \\
    \hline
    \tm{l}或\tm{L} & \li  & \li                                               \\
                   & \lli & \uli                                              \\
                   &      & \lli                                              \\
                   &      & \ulli                                             \\
    \hline
    \tm{u}或\tm{U}和 & \uli  & \uli                                           \\
    \tm{l}或\tm{L}   & \ulli & \ulli                                          \\
    \hline
    \tm{ll}或\tm{LL} & \lli & \lli                                            \\
                     &      & \ulli                                           \\
    \hline
    \tm{u}或\tm{U}和 & \ulli & \ulli                                          \\
    \tm{ll}或\tm{LL} &       &
  \end{tabular}
\end{table}

\paragraph{}
如果整数常量不能由其列表中的任何类型表示，它可能具有扩展整型，如果扩展整型可以表
示其值的话。如果常量列表中的所有类型都有符号，则扩展整型应有符号。如果常量列表中
的所有类型都是无符号的，则扩展整型应是无符号的。如果列表同时包含有符号和无符号类
型，则扩展整型可以是有符号或无符号类型。如果整数常量不能由其列表中的任何类型表示
且没有扩展的整型，则整数常量没有类型。

\pagebreak

\sssect{浮点常量}{lang.lex.const.float}
\syntax
\paragraph{}
\synsym{floating-constant}
  \synprd{\nt{decimal-floating-constant}}
  \synprd{\nt{hexadecimal-floating-constant}}
\synsym{decimal-floating-constant}
  \synprd{\nt{fractional-constant exponent-part$_{opt}$
              floating-suffix$_{opt}$}}
  \synprd{\nt{digit-sequence exponent-part floating-suffix$_{opt}$}}
\synsym{hexadecimal-floating-constant}
  \synprd{\nt{hexadecimal-prefix hexadecimal-fractional-constant}}
    \synprd{\hspace{6em}\nt{binary-exponent-part floating-suffix$_{opt}$}}
  \synprd{\nt{hexadecimal-prefix hexadecimal-digit-sequence}}
    \synprd{\hspace{6em}\nt{binary-exponent-part floating-suffix$_{opt}$}}
\synsym{fractional-constant}
  \synprd{\nt{digit-sequence$_{opt}$} \tm{.} \nt{digit-sequence}}
  \synprd{\nt{digit-sequence} \tm{.}}
\synsym{exponent-part}
  \synprd{\tm{e} \nt{sign$_{opt}$ digit-sequence}}
  \synprd{\tm{E} \nt{sign$_{opt}$ digit-sequence}}
\synsym[one of]{sign}
  \synprd{\tm{+ -}}
\synsym{digit-sequence}
  \synprd{\nt{digit}}
  \synprd{\nt{digit-sequence digit}}
\synsym{hexadecimal-fractional-constant}
  \synprd{\nt{hexadecimal-digit-sequence$_{opt}$} \tm{.}
          \nt{hexadecimal-digit-sequence}}
  \synprd{\nt{hexadecimal-digit-sequence$_{opt}$} \tm{.}}
\synsym{binary-exponent-part}
  \synprd{\tm{p} \nt{sign$_{opt}$ digit-sequence}}
  \synprd{\tm{P} \nt{sign$_{opt}$ digit-sequence}}
\synsym{hexadecimal-digit-sequence}
  \synprd{\nt{hexadecimal-digit}}
  \synprd{\nt{hexadecimal-digit-sequence hexadecimal-digit}}
\synsym[one of]{floating-suffix}
  \synprd{\tm{f l F L}}

\desc
\paragraph{}
浮点常量有一个\textit{有效位部分}，后面可能跟一个\textit{指数部分}和一个指定其类
型的后缀。有效位部分的组成可以包括表示整数部分的数字序列，后跟句点（\tm{.}），后
跟表示小数部分的数字序列。指数部分的组成由一个\tm{e}、\tm{E}、\tm{p}或\tm{P}后跟
一个由可选有符号数字序列组成的指数。整数部分或小数部分必须存在；对于十进制浮点常
量，句点部分或指数部分必须存在。

\semantic
\paragraph{}
有效位部分被解释为（十进制或十六进制）有理数；指数部分中的数字序列被解释为十进制
整数。对于十进制浮点常量，指数表示有效位部分的10次幂。对于十六进制浮点常量，指数
表示有效位部分的2的幂。对于十进制浮点常量，以及十六进制浮点常量（当
\textit{FLT\_RADIX}不是2的幂时），结果要么是最近的可表示值，要么是以实现定义的方
式选择紧邻最近的可表示值的较大或较小的可表示值。对于十六进制浮点常量，当
\textit{FLT\_RADIX}为2的幂时，结果正确四舍五入。

\paragraph{}
无后缀浮点常量具有类型\tm{double}。如有后缀\tm{f}或\tm{F}，则有类型\tm{float}。
如有后缀\tm{l}或\tm{L}，则具有类型\tm{long double}。

\paragraph{}
浮点常量在翻译时转换为内部格式。浮点常量的转换在执行时不应引发异常情况或浮点异常
。同一源形式\footnote{\tm{1.23, 1.230, 123e-2, 123e-02}和\tm{1.23L}都是不同源形
式，因此不需要转换成相同内部格式和值。}的所有浮动常量应转换为具有相同值的相同内
部格式。

\recprac
\paragraph{}
如果十六进制常量不能以其求值格式准确表示，则实现应生成诊断消息；然后应继续转换程
序。

\paragraph{}
给定适用于两种转换，相同的结果格式和默认的执行时舍入的匹配输入，浮点常量的转换时
间应与库函数（如\tm{strtod}）对字符串的执行时转换相匹配。\footnote{库函数的规范
建议比浮点常量更精确的转换（见7.22.1.3）。}

\sssect{枚举常量}{lang.lex.const.enum}
\syntax
\paragraph{}
\synsym{enumeration-constant}
  \synprd[]{\nt{identifier}}

\semantic
\paragraph{}
声明为枚举常量的标识符具有类型\tm{int};

\fwdref{6.7.2.2}

\sssect{字符常量}{lang.lex.const.char}
\syntax
\paragraph{}
\synsym{character-constant}
\synprd{\tm{\sq} \nt{c-char-sequence} \tm{\sq}}
\synprd{\tm{L\sq} \nt{c-char-sequence} \tm{\sq}}
\synprd{\tm{u\sq} \nt{c-char-sequence} \tm{\sq}}
\synprd{\tm{U\sq} \nt{c-char-sequence} \tm{\sq}}
\synsym{c-char-sequence}
  \synprd{\nt{c-char}}
  \synprd{\nt{c-char-sequence c-char}}
\synsym{c-char}
  \synprd{源字符集中除单引号\tm{\sq}，反斜杠\tm{\bs}或新行字符外的任何成员}
  \synprd{\nt{escape-sequence}}
\synsym{escape-sequence}
  \synprd{\nt{simple-escape-sequence}}
  \synprd{\nt{octal-escape-sequence}}
  \synprd{\nt{hexadecimal-escape-sequence}}
  \synprd{\nt{universal-character-name}}
\synsym[one of]{simple-escape-sequence}
  \synprd{\tm{\bs\sq\ \bs\dq\ \bs{}?\ \bs\bs}}
  \synprd{\tm{\bs{}a \bs{}b \bs{}f \bs{}n \bs{}r \bs{}t \bs{}v}}
\synsym{octal-escape-sequence}
  \synprd{\tm{\bs} \nt{octal-digit}}
  \synprd{\tm{\bs} \nt{octal-digit octal-digit}}
  \synprd{\tm{\bs} \nt{octal-digit octal-digit octal-digit}}
\synsym{hexadecimal-escape-sequence}
  \synprd{\tm{\bs{}x} \nt{hexadecimal-digit}}
  \synprd[]{\nt{hexadecimal-escape-sequence hexadecimal-digit}}

\desc
\paragraph{}
整型字符常量是一个或多个多字节字符的序列，用单引号括起来，如\tm{\sq{}x\sq}。宽字
符常量是相同的，除前缀字母\tm{L}、\tm{u}或\tm{U}之外。除后面详细介绍的一些例外，
序列的元素是源字符集的任何成员；它们以实现定义的方式映射到执行字符集的成员。

\paragraph{}
根据以下转义表，单引号\tm{\sq}，双引号\tm{\dq}，问号\tm{?}，反斜杠\tm{\bs}和任意
整数值都可以表示：
\begin{table}[h!]
  \centering
  \begin{tabular}{ll}
    单引号\tm{\sq} & \tm{\bs\sq}                                              \\
    双引号\tm{\dq} & \tm{\bs\dq}                                              \\
    问号\tm{?}     & \tm{\bs ?}                                               \\
    反斜杠\tm{\bs} & \tm{\bs\bs}                                              \\
    八进制字符     & \tm{\bs}\textit{八进制数字}                              \\
    十六进制字符   & \tm{\bs{}x}\textit{十六进制数字}
  \end{tabular}
\end{table}

\paragraph{}
双引号\tm{\dq}和问号\tm{?}或可用其自身或可用转义序列\tm{\bs\dq}和\tm{\bs ?}对应
的表示，但单引号\tm{\sq}和反斜杠\tm{\bs}应使用转义序列\tm{\bs\sq}和\tm{\bs\bs}对
应的表示。

\paragraph{}
在八进制转义序列中，跟在反斜杠后面的八进制数字被视为整数字符常量的单个字符或宽字
符常量的单个宽字符构造的一部分。这样形成的八进制整数的数值指定所需字符或宽字符的
值。

\paragraph{}
十六进制转义序列中反斜杠后面的十六进制数字和字母\tm{x}被视为整数字符常量的单个字
符或宽字符常量的单个宽字符构造的一部分。这样形成的十六进制整数的数值指定所需字符
或宽字符的值。

\paragraph{}
每个八进制或十六进制转义序列是构成转义序列的最长字符序列。

\paragraph{}
此外，不在基本字符集中的字符可以用通用字符名表示，某些非图形字符可以用转义序列表
示，转义序列由反斜杠\tm{\bs}后跟小写字母\tm{\bs a}、\tm{\bs b}、\tm{\bs f}、
\tm{\bs n}、\tm{\bs r}、\tm{\bs t}和\tm{\bs v}组成。\footnote{这些字符的语义在
\ref{env.env.display}中进行了讨论。如果反斜杠后面有任何其他字符，则结果不是标记，
需要进行诊断。见``未来语言方向''（\ref{lang.dir.escape}）。}

\constraint
\paragraph{}
八进制或十六进制转义序列的值应在相应类型的可表示值范围内：
\begin{table}[h!]
  \centering
  \begin{tabular}{l|l}
    前缀   & 对应类型                                                         \\
    \hline
    无     & \tm{unsigned char}                                               \\
    \tm{L} & 对应\tm{wchar\_t}的无符号类型                                    \\
    \tm{u} & \tm{char16\_t}                                                   \\
    \tm{U} & \tm{char32\_t}
  \end{tabular}
\end{table}

\semantic
\paragraph{}
整数字符常量具有\tm{int}类型。包含映射到单字节执行字符的单个字符的整数字符常量的
值是被解释为整数的映射字符表示的数值。包含多个字符（例如\tm{\sq ab\sq}）或包含不
映射到单字节执行字符的字符或转义序列的整型字符常量的值由实现定义。如果整型字符常
量包含单个字符或转义序列，则其值是将值为单个字符或转义序列的\tm{char}类型的对象
转换为\tm{int}类型时的结果。

\paragraph{}
以字母\tm{L}为前缀的宽字符常量具有\tm{wchar\_t}类型，这是在\tm{<stddef.h>}头中定
义的整型；以字母\tm{u}或\tm{U}为前缀的宽字符常量具有\tm{char16\_t}或
\tm{char32\_t}类型，分别是在\tm{<uchar.h>}头中定义的无符号整型。包含映射到扩展执
行字符集的单个成员的单个多字节字符的宽字符常量的值是与该多字节字符对应的宽字符，
由\tm{mbtowc}、\tm{mbrtoc16}或\tm{mbrtoc32}函数根据其类型定义，由实现定义了当前
的区域设置。实现定义了包含多个多字节字符的宽字符常量的值，或映射到扩展执行字符集
的多个成员的单个多字节字符的值，或包含扩展执行字符集中未表示的多字节字符或转义序
列的值。

\paragraph{}
\ex 结构\tm{\sq\bs 0\sq}通常用于表示零字符。

\paragraph{}
\ex 考虑整数使用二补码，\tm{char}类型对象为八位表示的实现。在类型\tm{char}的值范
围与\tm{signed char}相同的实现中，整型字符常量\tm{\sq\bs xFF\sq}的值为$-1$；如果
类型\tm{char}的值范围与\tm{unsigned char}相同，则字符常量\tm{\sq\bs xFF\sq}的值
为$+255$。

\paragraph{}
\ex 即使8位用于\tm{char}类型的对象，构造\tm{\sq\bs x123\sq}也指定只包含一个字符
的整型字符常量，因为十六进制转义序列仅由非十六进制字符终止。要指定一个包含值为
\tm{\sq\bs x12\sq}和\tm{\sq3\sq}的两字符的整型字符常量，可以使用构造\tm{\sq\b
0223\sq}，因为八进制转义序列在三个八进制数字后终止。（此双字符整型字符常量的值由
实现定义。）

\paragraph{}
\ex 即使12位或更多位用于具有\tm{wchar\_t}类型的对象，构造\tm{L\sq\bs 1234\sq}指
定由值\tm{0123}和\tm{\sq 4\sq}组合产生的实现定义值。

\fwdref{7.19，7.22.7.2，7.28}

\ssect{字符串字面值}{lang.lex.str}
\syntax
\paragraph{}
\synsym{string-literal}
  \synprd{\nt{encoding-prefix$_{opt}$}\tm{\dq}
          \nt{s-char-sequence$_{opt}$}\tm{\dq}}
\synsym{encoding-prefix}
  \synprd{\tm{u8}}
  \synprd{\tm{u}}
  \synprd{\tm{U}}
  \synprd{\tm{L}}
\synsym{s-char-sequence}
  \synprd{\nt{s-char}}
  \synprd{\nt{s-char-sequence s-char}}
\synsym{s-char}
  \synprd{源字符集中除双引号\tm{\dq}，反斜杠\tm{\bs}或新行字符外的任何成员}
  \synprd[]{\nt{escape-sequence}}

\constraint
\paragraph{}
相邻字符串文本标记的序列不应同时包含宽字符串文字和UTF-8字符串文本。

\desc
\paragraph{}
\textit{字符串文本}是用双引号括起来的零个或多个多字节字符的序列，如
\tm{\dq xyz\dq}。除前缀为\tm{u8}，\textit{UTF-8字符串文本}是相同的。
除前缀字母\tm{L}、\tm{u}或\tm{U}，\textit{宽字符串文本}是相同的。

\paragraph{}
同样的考虑也适用于字符串文本中序列的每个元素，就好像它是一个整型字符常量（对于字
符或UTF-8字符串文本）或一个宽字符常量（对于宽字符串文本），除了单引号\tm{\sq}可
以由其自身或转义序列\tm{\bs\sq}来表示，而双引号\tm{\dq}除外，应以转义序列
\tm{\bs\dq}表示。

\semantic
\paragraph{}
在翻译阶段\ref{tpit6}中，由任何相邻字符序列和相同前缀的字符串文本标记指定的多字
节字符序列被连接成单个多字节字符序列。如果任何标记具有编码前缀，则生成的多字节字
符序列将被视为具有相同的前缀；否则，将被视为（character）字符串文本。是否可以连
接不同前缀的宽字符串文本标记以及如果可以，对生成的多字节字符序列进行的处理由实现
定义。

\paragraph{}
在翻译阶段\ref{tpit7}中，值为零的字节或代码被附加到每个多字节字符序列中，这些字
符序列是由字符串文本或文本产生的。\footnote{字符串文本不必是字符串（见
\ref{lib.intro.term}），因为可以通过转义序列\tm{\bs 0}将空字符嵌入其中。}  然后
使用多字节字符序列初始化静态存储期和长度刚好足以包含序列的数组。对于字符串文本，
数组元素具有\tm{char}类型，并用多字节字符序列的单个字节初始化。对于UTF-8字符串文
本，数组元素具有\tm{char}类型，并用以UTF-8编码的多字节字符序列的字符初始化。对于
以字母\tm{L}为前缀的宽字符串文本，数组元素的类型为\tm{wchar\_t}，并使用与多字节
字符序列相对应的宽字符序列进行初始化，如\tm{mbstowcs}函数使用实现定义的当前区域
设置所定义的那样。对于以字母\tm{u}或\tm{U}为前缀的宽字符串文本，数组元素分别具有
\tm{char16\_t}或\tm{char32\_t}类型，并使用与多字节字符序列相对应的宽字符序列进行
初始化，该序列由对\tm{mbroc16}或\tm{mbroc32}函数（视其类型而定）的连续调用定义，
并带有一个实现定义当前区域设置。包含未在执行字符集中表示的多字节字符或转义序列的
字符串文本的值由实现定义。

\paragraph{}
这些数组的元素具有适当值的情况下，不确定它们是否是不同。如果程序试图修改这样的数
组，则行为未定义。

\paragraph{}
\ex 相邻字符串文本对
\begin{lstlisting}
    "\x12" "3"
\end{lstlisting}
生成一个包含两个字符的单字符串文本，值分别为\tm{\sq\bs x12\sq}和\tm{\sq 3\sq}，
因为转义序列在相邻字符串文本串联之前被转换为执行字符集的单个成员。

\paragraph{}
\ex 相邻字符串文字标记的每个序列
\begin{lstlisting}
    "a" "b" L"c"
    "a" L"b" "c"
    L"a" "b" L"c"
    L"a" L"b" L"c"
\end{lstlisting}
都等价于字符串文本
\begin{lstlisting}
    L"abc"
\end{lstlisting}
同样，每个序列
\begin{lstlisting}
    "a" "b" u"c"
    "a" u"b" "c"
    u"a" "b" u"c"
    u"a" u"b" u"c"
\end{lstlisting}
都等价于
\begin{lstlisting}
    u"abc"
\end{lstlisting}

\fwdref{7.19，7.22.8.1，7.28}

\ssect{标点}{lang.lex.punct}
\syntax
\paragraph{}
\synsym[one of]{punctuator}
  \synprd{\tm{[ ] ( ) \{ \} .\ ->}}
  \synprd{\tm{++ \textendash\textendash\ \& * + - \~\ !}}
  \synprd{\tm{/ \% \tl{}\tl\ \tg{}\tg\ < > <= >= == != \^\ | \&\& ||}}
  \synprd{\tm{?\ :\ ; ...}}
  \synprd{\tm{= *= /= \%= += -= \tl{}\tl{}= \tg{}\tg{}= \&= \^{}= |=}}
  \synprd{\tm{, \# \#\#}}
  \synprd[]{\tm{<:\ :> <\% \%> \%:\ \%:\%:}}

\semantic
\paragraph{}
标点符号是一种具有独立的语法和语义的符号。根据上下文的不同，它可以指定要执行的操
作（相应地可能生成值或函数指示符，产生副作用或其组合），这种情况下被称为
\textit{运算符}（在某些上下文中也存在其他形式的运算符）。\textit{操作数}是运算符
作用于其上的实体。

\paragraph{}
在语言的所有方面，六个标记\footnote{这些标记有时称作``双字母序列''。}         \\
\synprd[]{\tm{<:\ :> <\% \%> \%:\ \%:\%:}}                                    \\
与六个标记                                                                    \\
\synprd[]{\tm{[ ] \{ \} \# \#\#}}                                             \\
除拼写不同外，对应的行为一致。\footnote{因此\tm{[}和\tm{<:}在``字符化''（见
\ref{lang.ppdir.macro.stringize}）时行为不同，但除此外可以自由互换。}

\fwdref{6.5，6.7，6.10，6.8}

\ssect{头名称}{lang.lex.header}
\syntax
\paragraph{}
\synsym{header-name}
  \synprd{\tm{<} \nt{h-char-sequence} \tm{>}}
  \synprd{\tm{\dq} \nt{q-char-sequence} \tm{\dq}}
\synsym{h-char-sequence}
  \synprd{\nt{h-char}}
  \synprd{\nt{h-char-sequence h-char}}
\synsym{h-char}
  \synprd{源字符集中除新行字符和\tm{>}以外的任何成员}
\synsym{q-char-sequence}
  \synprd{\nt{q-char}}
  \synprd{\nt{q-char-sequence q-char}}
\synsym{q-char}
  \synprd[]{源字符集中除新行字符和\tm{\dq}以外的任何成员}

\semantic
\paragraph{}
两种形式的头名称序列都以实现定义的方式映射到\ref{lang.ppdir.inc}中指定的头名称或
外部源文件名。

\paragraph{}
如果字符\tm{\sq}，\tm{\bs}，\tm{\dq}，\tm{\bs\bs}或\tm{/*}出现在分隔符\tm{<}和
\tm{>}之间的序列中则行为未定义。相应的，如果字符\tm{\sq}，\tm{\bs}，\tm{\bs\bs}
或\tm{/*}出现在\tm{\dq}分隔符之间的序列中则行为未定义。\footnote{因此，类似转义
序列的字符序列会导致未定义的行为。} 头名称预处理标记只能在\tm{\#include}预处理指
令和\tm{\#pragma}指令内的实现定义的位置中识别。\footnote{有关在\tm{\#pragma}指令
中使用头名称预处理标记的示例见\ref{lang.ppdir.pragmaop}。}

\paragraph{}
\ex* 以下字符序列
\begin{lstlisting}
    0x3<1/a.h>1e2
    #include <1/a.h>
    #define const.member@$
\end{lstlisting}
构成以下的预处理标记（每个预处理标记使用\tm{\{}和\tm{\}}分隔。
\begin{lstlisting}
    {0x3}{<}{1}{/}{a}{.}{h}{>}{1e2}
    {#}{include} {<1/a.h>}
    {#}{define} {const}{.}{member}{@}{$}
\end{lstlisting}

\fwdref{6.10.2}

\ssect{预处理数字}{lang.lex.ppnum}
\syntax
\paragraph{}
\synsym{pp-number}
  \synprd{\nt{digit}}
  \synprd{\tm{.} \nt{digit}}
  \synprd{\nt{pp-number digit}}
  \synprd{\nt{pp-number identifier-nondigit}}
  \synprd{\nt{pp-number} \tm{e} \nt{sign}}
  \synprd{\nt{pp-number} \tm{E} \nt{sign}}
  \synprd{\nt{pp-number} \tm{p} \nt{sign}}
  \synprd{\nt{pp-number} \tm{P} \nt{sign}}
  \synprd[]{\nt{pp-number} \tm{.}}

\desc
\paragraph{}
一个预处理数字以一个数字开头，前面有可选的小数点（\tm{.}），后面可能跟有有效的标
识符字符和字符序列\tm{e+}、\tm{e-}、\tm{E+}、\tm{E-}、\tm{p+}、\tm{p-}、\tm{P+}
、或\tm{P-}。

\paragraph{}
预处理数字标记词法上包括所有浮点和整数常量标记。

\semantic
\paragraph{}
预处理数字没有类型或值；在成功转换（作为翻译阶段\ref{tpit7}的一部分）为浮点常量
标记或整数常量标记后获取这两个值。

\ssect{注释}{lang.lex.comment}
\paragraph{}
除了在字符常量、字符串文本或注释里之外，字符\tm{/*}引入注释。检查此类注释的内容
只是为了识别多字节字符并查找终止注释的字符\tm{*/}。\footnote{因此注释
\tm{/* ... */}不能嵌套。}

\paragraph{}
除了在字符常量、字符串文本或注释里之外，字符\tm{//}引入一个注释，该注释包含直到
下一个新行字符（但不包括）的所有多字节字符。这种注释的内容仅用于识别多字节字符和
查找终止新行字符。

\paragraph{}
\ex*
\begin{lstlisting}
    "a//b"                    // four-character string literal
    #include "//e"            // undefined behavior
    // */                     // comment, not syntax error
    f = g/**//h;              // equivalent to f = g / h;
    //\
    i();                      // part of a two-line comment
    /\
    / j();                    // part of a two-line comment
    #define glue(x,y) x##y
    glue(/,/) k();            // syntax error, not comment
    /*//*/ l();               // equivalent to l();
    m = n//**/o
      + p;                    // equivalent to m = n + p;
\end{lstlisting}

\sect{表达式}{lang.expr}
\paragraph{}<++>
\paragraph{}<++>
\paragraph{}<++>
\paragraph{}<++>
\paragraph{}<++>
\paragraph{}<++>
\paragraph{}<++>
\paragraph{}<++>
\fwdref{}<++>

\ssect{主表达式}{lang.expr.prim}
\syntax
\paragraph{}<++>

\sssect{泛型选择}{lang.expr.prim.generic}

\ssect{后缀运算符}{lang.expr.post}
\sssect{数组下标}{lang.expr.post.sub}
\sssect{函数调用}{lang.expr.post.call}
\sssect{结构与联合成员}{lang.expr.post.mem}
\sssect{后自增与自减}{lang.expr.post.incr}
\sssect{复合字面值}{lang.expr.post.cmpd}

\ssect{一元运算符}{lang.expr.unary}
\sssect{前自增与自减}{lang.expr.unary.incr}
\sssect{地址与取值}{lang.expr.unary.addr}
\sssect{一元算术运算符}{lang.expr.unary.arith}
\sssect{sizeof和alignof}{lang.expr.unary.sizeof}

\ssect{转换运算符}{lang.expr.cast}
\ssect{乘法运算符}{lang.expr.mul}
\ssect{加法运算符}{lang.expr.add}
\ssect{位移运算符}{lang.expr.shift}
\ssect{关系运算符}{lang.expr.rel}
\ssect{等性运算符}{lang.expr.eq}
\ssect{按位与运算符}{lang.expr.and}
\ssect{按位异或运算符}{lang.expr.xor}
\ssect{按位或运算符}{lang.expr.or}
\ssect{逻辑与运算符}{lang.expr.land}
\ssect{逻辑或运算符}{lang.expr.lor}
\ssect{条件运算符}{lang.expr.cond}
\ssect{赋值运算符}{lang.expr.assign}
\sssect{简单赋值}{lang.expr.assign.simple}
\sssect{复合赋值}{lang.expr.assign.cmpd}

\ssect{逗号运算符}{lang.expr.comma}

\sect{常表达式}{lang.constexpr}

\sect{声明}{lang.dcl}
\ssect{存储类说明}{lang.dcl.stc}
\ssect{类型说明}{lang.dcl.type}
\sssect{结构与联合说明符}{lang.dcl.type.struct}
\sssect{枚举说明符}{lang.dcl.type.enum}
\sssect{标签}{lang.dcl.type.tag}
\sssect{原子类型说明符}{lang.dcl.type.atom}

\ssect{类型限定}{lang.dcl.qual}
\sssect{restrict的形式定义}{lang.dcl.qual.restrict}

\ssect{函数说明}{lang.dcl.fct}
\ssect{对齐说明}{lang.dcl.align}
\ssect{声明子}{lang.dcl.decl}
\sssect{指针声明子}{lang.dcl.decl.ptr}
\sssect{数组声明子}{lang.dcl.decl.array}
\sssect{函数声明子（含原型）}{lang.dcl.decl.fct}

\ssect{类型名}{lang.dcl.typename}
\ssect{类型定义}{lang.dcl.typedef}
\ssect{初始化}{lang.dcl.init}
\ssect{静态断言}{lang.dcl.assert}

\sect{语句与块}{lang.stmt}
\ssect{标号语句}{lang.stmt.label}
\ssect{复合语句}{lang.stmt.cmpd}
\ssect{表达式与空语句}{lang.stmt.expr}
\ssect{选择语句}{lang.stmt.sel}
\sssect{if语句}{lang.stmt.sel.if}
\sssect{switch语句}{lang.stmt.sel.switch}

\ssect{迭代语句}{lang.stmt.iter}
\sssect{while语句}{lang.stmt.iter.while}
\sssect{do语句}{lang.stmt.iter.do}
\sssect{for语句}{lang.stmt.iter.for}

\ssect{跳转语句}{lang.stmt.jmp}
\sssect{goto语句}{lang.stmt.jmp.goto}
\sssect{continue语句}{lang.stmt.jmp.cont}
\sssect{break语句}{lang.stmt.jmp.brk}
\sssect{return语句}{lang.stmt.jmp.ret}

\sect{外部定义}{lang.extn}
\ssect{函数定义}{lang.extn.fct}
\ssect{外部对象定义}{lang.extn.obj}

\sect{预处理指令}{lang.ppdir}
\ssect{条件包含}{lang.ppdir.condinc}
\ssect{源文件包含}{lang.ppdir.inc}
\ssect{宏替换}{lang.ppdir.macro}
\sssect{参数替换}{lang.ppdir.macro.subst}
\sssect{\#运算符}{lang.ppdir.macro.stringize}
\sssect{\#\#运算符}{lang.ppdir.macro.concat}
\sssect{重扫描和进一步替换}{lang.ppdir.macro.rescan}
\sssect{宏定义作用域}{lang.ppdir.macro.scope}

\ssect{行控制}{lang.ppdir.line}
\ssect{Error指令}{lang.ppdir.error}
\ssect{Pragma指令}{lang.ppdir.pragma}
\ssect{空指令}{lang.ppdir.null}
\ssect{预定义宏名}{lang.ppdir.predef}
\sssect{强制定义的宏}{lang.ppdir.predef.mand}
\sssect{环境相关宏}{lang.ppdir.predef.env}
\sssect{条件特性宏}{lang.ppdir.predef.cond}

\ssect{Pragma运算符}{lang.ppdir.pragmaop}

\sect{未来语言方向}{lang.dir}
\ssect{符点类型}{lang.dir.float}
\ssect{标识符链接}{lang.dir.link}
\ssect{外部名称}{lang.dir.extn}
\ssect{字符转义序列}{lang.dir.escape}
\ssect{存储类说明}{lang.dir.stc}
\ssect{函数声明子}{lang.dir.fctdecl}
\ssect{函数定义}{lang.dir.fctdef}
\ssect{Pragma指令}{lang.dir.pragma}
\ssect{预定义宏名}{lang.dir.predef}
