\chptr{语言}{lang}

                                                      \sect{记号}{lang.notation}
\paragraph{}
本章所用语法记号中，语法类别（非结束符）由斜体表示，字面单词和字符集成员（结束符
）由{粗体表示。跟在非结束符后的冒号（\texttt{:}）引入其定义。可选（alternative，
可替换的）定义在独立行上列出，除非前加``one of''。可选（optional，非强制的）符号
由下标``opt''表示，如                                                         \\
\synprd{\tm{\{} \nt{expression\tsub{opt}} \tm{\}}}
表示括号括起来的可选表达式。

\paragraph{}
正文中引用语法类型时不再使用斜体且单词使用空格而不是连字符分隔。

\paragraph{}
附录\ref{synsum}给出语法总结。

                                                       \sect{概念}{lang.concept}

                                        \ssect{标识符作用域}{lang.concept.scope}
\paragraph{}
标识符可以表示对象；函数；结构，联合或枚举标签或成员；类型定义名；标号名；宏名或
宏参数。同一标识符可以在程序中不同点表示不同实体。枚举成员称作\textit{枚举常量}。
宏名和宏参数不再考虑，因为在程序分析的语义阶段源文件中任何宏名已经被构成宏定义的
预处理标记替换掉。

\paragraph{}
对一个标识符所代表的不同实体，该标识符仅在程序的一个文本段内\textit{可见}（即可
用），该文本段称作标识符的\textit{作用域}。由同一标识符所表示的不同实体要么具有
不同作用域，要么处于不同命名空间中。存在四种作用域：函数作用域、文件作用域、块作
用域和函数原型作用域。（\textit{函数原型}指声明参数类型的函数声明。）

\paragraph{}
标号名是唯一具有\textit{函数作用域}的标识符。在其所出现的函数中任一位置可用
（于\tm{goto}语句中），由其语法形态（跟上\tm{:}和语句）隐式声明。

\paragraph{}
任何其他标识符由其声明（声明子或类型说明符）所处位置确定作用域。如果声明该标识符
的声明子或类型说明符处于任何块或参数列表之外，则标识符具有\textit{文件作用域}，
在翻译单元结束处结束。如果声明标识符的声明子或类型说明符出现在块内或函数定义中的
参数声明列表中，则该标识符具有\textit{块作用域}，终止于关联块的末尾。如果声明标
识符的声明子或类型说明符出现在函数原型（不是函数定义的一部分）中的参数声明列表
中，则该标识符具有\textit{函数原型作用域}，终止于函数声明子的末尾。如果标识符在
同一命名空间中指定了两个不同的实体，则作用域可能会重叠。如果是这样，一个实体的作
用域（\textit{内作用域}）将严格结束在另一个实体的作用域（\textit{外作用域}）之
前。在内作用域中，标识符指代内作用域内声明的实体；在外作用域内声明的实体在内作用
域内被\textit{隐藏}（即不可见）。

\paragraph{}
除非另有明确规定，否则本标准使用``标识符''一词指某个实体（与句法结构相反），它指
相关命名空间中的实体，其声明在标识符出现时可见。

\paragraph{}
两个标识符具有\textit{相同的作用域}，当且仅当它们的作用域终止于同一点。

\paragraph{}
结构、联合和枚举标签的作用域在声明标签的类型说明符中的标签出现之后开始。每个枚举
常量的作用域在枚举列表中的枚举定义出现之后开始。任何其他标识符的作用域都在其声明
子完成之后开始。

\paragraph{}
作为一种特殊情况，类型名（不是标识符的声明）被认为具有作用域，该作用域从类型名中
假定未被省略的标识符所出现的位置之后开始。

\fwdref{6.7，6.5.2.2，6.9.1，6.4.2，6.10.3，6.2.3，6.10.2，6.8}

                                           \ssect{标识符链接}{lang.concept.link}
\paragraph{}
可以使在不同作用域或同一作用域中声明多次的标识符通过称为\textit{链接}的过程引用
同一对象或函数。\footnote{不同的标识符之间没有链接。} 存在三种链接：外部链接、内
部链接和无链接。

\paragraph{}
在构成整个程序的一组翻译单元和库中，具有\textit{外部链接}的特定标识符的每个声明
都表示相同的对象或函数。在一个翻译单元中，具有\textit{内部链接}的标识符的每个声
明都表示相同的对象或函数。\textit{无链接}标识符的每个声明都表示一个唯一的实体。

\paragraph{}
如果对象或函数的文件作用域标识符的声明包含存储类说明符\tm{static}，则该标识符具
有内部链接。\footnote{仅当函数声明在文件作用域内时，它才能包含静态存储类说明符；
请参见\ref{lang.dcl.stc}。}

\paragraph{}
对于用存储类说明符\tm{extern}声明的标识符，在该标识符的先前声明可见的作用域内，
\footnote{如\ref{lang.concept.scope}所述，后一个声明可能隐藏前一个声明。} 如果先
前声明指定内部或外部链接，则后面声明中标识符的链接与先前声明中指定的链接相同。如
果前面的声明不可见，或者前面的声明没有指定链接，那么标识符具有外部链接。

\paragraph{}
如果函数的标识符声明没有存储类说明符，则其链接的确定与使用存储类说明符
\tm{extern}声明的链接完全相同。如果对象的标识符声明具有文件作用域，并且没有存储
类说明符，则其链接是外部的。

\paragraph{}
以下标识符没有链接：声明为对象或函数以外的任何标识符；声明为函数参数的标识符；没
有使用存储类说明符\tm{extern}声明的块作用域对象的标识符。

\paragraph{}
如果在翻译单元中，相同的标识符同时具有内部链接和外部链接，则行为未定义。

                                  \ssect{标识符命名空间}{lang.concept.namespace}
\paragraph{}
如果在翻译单元的任何位置都可以看到特定标识符的多个声明，那么语法上下文将对引用不
同实体的使用进行歧义消除。因此，不同类别的标识符具有不同的\textit{命名空间}，如
下所示：
\begin{itemize}
  \item{\textit{标号名}（由标号声明和使用的语法来消除歧义）；}
  \item{结构，联合和枚举\textit{标签}（\textit{tags}）（由跟在关键字\tm{struct}，
    \tm{union}或\tm{enum}\footnote{尽管存在三种可能，实际只有一种命名空间。}后面
    来消除歧义）；}
  \item{结构或联合成员；每个结构或联合成员都有单独的命名空间（由通过\tm{.}或
    \tm{->}运算符访问成员的表达式类型来消除歧义）；}
  \item{所有其他标识符，称为\textit{普通标识符}（\textit{ordinary identifiers}）
    （在普通声明子中声明或声明为枚举常量）。}
\end{itemize}

\fwdref{6.7.2.2，6.8.1，6.7.2.1，6.5.2.3，6.7.2.3，6.8.6.1}

                                        \ssect{对象存储期}{lang.concept.storage}
\paragraph{}
对象具有决定其生命期的\textit{存储期}。有四种存储期：静态存储期、线程存储期、自
存储期动和分配存储期。分配存储期在第\ref{lib.util.mem}节描述。

\paragraph{}
对象\textit{生命期}（\textit{lifetime}）指程序执行的一段时间，该期间内保证为对象
保留其存储。在生命期内，对象存在，有常量地址\footnote{术语``常量地址''意味着在不
同时间创建的指向该对象的两个指针相等。同一程序的两个不同执行期间内的该地址可能不
同。}，并保留其最后存储的值。\footnote{对于易失性对象，最后存储不一定显式存在程
序内。} 如果对象在其生命期之外被引用，则行为未定义。当指针指向（或刚越过）的对象
到达其生命期的末尾时，指针的值将变得不确定。

\paragraph{}
标识符声明时没有存储类说明符\tm{\_\_Thread\_local}且具有外部或内部链接或存储类说
明符\tm{static}的对象，具有\textit{静态存储期}。它的生命期是程序的整个执行期间，
其存储值在程序启动之前仅初始化一次。

\paragraph{}
用存储类说明符\tm{\_\_Thread\_local}声明其标识符的对象具有\textit{线程存储期}。
它的生命期是创建该对象的线程的整个执行期间，其存储值在线程启动时初始化。每个线程
有一个不同的对象，表达式中所声明的名称的使用，指的是计算该表达式的线程所关联的对
象。试图从与对象所关联的线程以外的线程间接访问具有线程存储期的对象的结果由实现定
义。

\paragraph{}
标识符声明不带链接且不带存储类说明符\tm{static}的对象具有\textit{自动存储期}，某
些复合字面值也是如此。试图从与对象关联的线程以外的线程间接访问具有自动存储期对象
的结果由实现定义。

\paragraph{}
对于不是变长数组类型的这类对象，其生命期从进入与之关联的块开始，直到该块的执行以
任何方式结束为止。（进入包含的块或调用函数会暂停但不会结束当前块的执行。）如果递
归地进入块，则每次都会创建一个新的对象实例。对象的初始值不确定。如果为对象指定了
初始化，则每次在块的执行中到达声明或复合字面值时都会执行初始化；否则，每次达到声
明时，值都会变得（becomes）不确定。

\paragraph{}
对于具有变长数组类型的这类对象，其生命期从对象的声明开始直到程序的执行离开声明作
用域。\footnote{离开包含声明的最内块，或跳到该块中声明之前的某个点或某个嵌入块中
将离开声明的作用域。} 如果递归地进入作用域，则每次都会创建对象的新实例。对象的初
始值不确定。

\paragraph{}
具有结构或联合类型的非左值表达式，其中结构或联合包含具有数组类型的成员（包括所有
递归包含的结构和联合的成员）指向一个具有自动存储期和\textit{临时生命期}的对象。
\footnote{访问数组成员时隐式获取此类对象的地址。} 它的生命期从计算表达式时开始，
初始值为表达式的值。其生命期在包含全表达式或完整声明子的计算结束时结束。任何修改
临时生命期对象的尝试都会导致未定义行为。

\fwdref{6.7.6.2，6.5.2.5，6.7.6，6.5.2.2，6.7.9，6.8}

                                                 \ssect{类型}{lang.concept.type}
\paragraph{}
存储在对象中的值或函数返回值的含义由用于访问该值的表达式类型决定。（声明为对象的
标识符是最简单的此类表达式；类型在标识符声明中指定。）类型分为\textit{对象类型}
（描述对象）和\textit{函数类型}（描述函数）。在翻译单元的不同点上，对象类型可能
\textit{不完整}（缺乏足够的信息来确定该类型对象的大小）或\textit{完整}（具有足够
的信息）。\footnote{类型在整个翻译单元中可能是不完整的或完整的，也可能在翻译单元
中的不同点改变状态。}

\paragraph{}
声明为\tm{\_Bool}类型的对象足够存储值$0$和$1$。

\paragraph{}
声明为\tm{char}类型的对象足够存储基本执行字符集的任何成员。如果基本执行字符集的
成员存储在\tm{char}对象中，则其值保证为非负。如果\tm{char}对象中存储了任何其他字
符，则其值由实现定义，但应在该类型的可表示值范围内。

\paragraph{}
有五种\textit{标准有符号整型}，使用\tm{signed char}、\tm{short int}、\tm{int}、
\tm{long int}和\tm{long long int}指定。（这些类型和其他类型可能用其他几种方式指
定，如\ref{lang.dcl.type}所述。）也可能存在实现定义的\textit{扩展有符号整型}。
\footnote{实现定义的关键字应具有\ref{lib.intro.reserved}节所述的具有保留用途的标
识符形式。} 标准和扩展有符号整型统称为\textit{有符号整型}。\footnote{因此，本标
准中关于有符号整型的任何陈述也适用于扩展有符号整型。}

\paragraph{}
声明为\tm{signed char}类型的对象与``普通''\tm{char}对象占用相同的存储量。
``普通''\tm{int}对象具有执行环境体系结构建议的自然大小（足够存储头
\tm{<limits.h>}中定义的\tm{INT\_MIN}到\tm{INT\_MAX}范围内的任何值）。

\paragraph{}
对于每个有符号整型，都有一个对应的（但不同的）无符号整型（用关键字\tm{unsigned}
指定），它使用相同的存储量（包括符号信息），并且具有相同的对齐要求。\tm{\_Bool}
类型和与标准有符号整型相对应的和无符号整型为\textit{标准无符号整型}。与扩展有符
号整型相对应的无符号整型是\textit{扩展无符号整型}。标准和扩展无符号整型统称为
\textit{无符号整型}。\footnote{因此，本标准中关于无符号整型的任何陈述也适用于
扩展无符号整型。}

\paragraph{}
标准有符号整型和标准无符号整型统称为\textit{标准整型}；扩展有符号整型和扩展无符
号整型统称为\textit{扩展整型}。

\paragraph{}
对具有相同符号和不同整型转换阶的任意两个整型（见\ref{lang.conv.arith.rank}），整
型转换阶较小的类型的值范围是另一类型的值的子范围。

\paragraph{}
有符号整型的非负值范围是对应无符号整型的子范围，并且每种类型中相同值的表示形式相
同。\footnote{相同的表示和对齐要求意味着作为函数参数、函数返回值和联合成员的可互
换性。} 涉及无符号操作数的计算不会溢出，因为如果结果不能用无符号整型表示，则结果
取比结果类型可表示最大值加一之后的模。

\paragraph{}
存在三种实浮点类型：\tm{float}、\tm{double}和\tm{long double}。\footnote{见``未
来语言方向''（\ref{lang.dir.float}）。 } \tm{float}类型的值集是\tm{double}类型值
集的子集；\tm{double}类型的值集是\tm{long double}类型值集的子集。

\paragraph{}
存在三种\textit{复类型}，分别是\tm{float \_Complex}、\tm{double \_Complex}和
\tm{long double \_Complex}。\footnote{虚数类型规范见附录\ref{comparith}。}（复类
型是条件特性，不要求实现支持；请参见\ref{lang.ppdir.predef.cond}。）实浮点类型和
复类型统称为\textit{浮点类型}。

\paragraph{}
每个浮点类型都有一个对应的实类型，它始终是一个实浮点类型。对于实浮点类型，它就是
该相同的类型。对于复类型，它是通过从类型名称中删除关键字\tm{\_Complex}后的实浮点
类型。

\paragraph{}
复类型具有与正好包含两个对应实类型元素的数组类型相同的表示和对齐要求；第一个元素
等于复数的实数部分，第二个元素等于复数的虚数部分。

\paragraph{}
\tm{char}类型、有符号和无符号整型以及浮点类型统称为\textit{基本类型}。基本类型是
完整的对象类型。即使实现将两个或多个基本类型定义为具有相同的表示，它们仍然是不同
的类型。\footnote{实现可以定义新的关键字，这些关键字提供了指定基本（或任何其他）
类型的可选方法；这不会违反所有基本类型都不同的要求。实现定义的关键字应具有
\ref{lib.intro.reserved}中所述的具有保留用途的标识符形式。}

\paragraph{}
\tm{char}、\tm{signed char}和\tm{unsigned char}三种类型统称为\textit{字符类型}。
实现应将\tm{char}定义为与\tm{signed char}或\tm{unsigned char}具有相同的范围、表
示和行为。\footnote{\tm{<limits.h>}中定义的\tm{CHAR\_MIN}将具有值$0$或
\tm{SCHAR\_MIN}中的一个，这可用于区分这两个选项。无论做出什么选择，\tm{char}都是
与其他两个类型不同的类型，即两者都不兼容。}

\paragraph{}
\textit{枚举}由一组命名的整型常量值组成。每个不同的枚举构成不同的\textit{枚举类
型}。

\paragraph{}
\tm{char}类型、有符号和无符号整型以及枚举类型统称为\textit{整型}。整型和实浮点类
型统称为\textit{实类型}。

\paragraph{}
整型和浮点类型统称为\textit{算术类型}。每个算术类型属于一个\textit{类型域}：
\textit{实类型域}包含实类型，\textit{复类型域}包含复类型。

\paragraph{}
\tm{void}类型值集为空；它是不完整对象类型，也无法使其完整。

\paragraph{}
可以从对象和函数类型构造任意数量的\textit{派生类型}，如下所示：
\begin{itemize}
  \item{\textit{数组类型}描述一组连续分配的非空对象，该对象具有特定成员对象类型
    （称为\textit{元素类型}）。每当指定数组类型时，元素类型应完整。数组类型由其
    元素类型和数组中的元素个数刻画。数组类型说成是从它的元素类型派生，如果它的元
    素类型是\nt{T}，则数组类型有时称为``\nt{T}的数组''。从元素类型构造数组类型称
    为``数组类型派生''。}
  \item{\textit{结构类型}描述了一组顺序分配的非空成员对象集（在某些情况下还有一
    个不完整的数组），每个对象都有一个可选的指定名称和可能不同的类型。}
  \item{\textit{联合类型}描述了一组重叠的非空成员对象集，每个成员对象都有一个可
    选的指定名称和可能不同的类型。}
  \item{\textit{函数类型}描述具有指定返回类型的函数。函数类型由其返回类型及其参
    数数量和参数类型刻画。函数类型说成是从其返回类型派生，即如果它的返回类型是
    \nt{T}，则该函数类型有时称为``返回\nt{T}的函数''。从返回类型构造函数类型称为
    ``函数类型派生''。}
  \item{\textit{指针类型}可以派生自函数类型或对象类型，称为\textit{被引用的类型}
    （\textit{referenced type}）。指针类型描述一个对象，该对象的值提供对被引用类
    型实体的引用。从引用类型\nt{T}派生的指针类型有时称为``指向\nt{T}的指针''。从
    引用类型构造指针类型称为``指针类型派生''。指针类型是完整的对象类型。}
  \item{\textit{原子类型}描述由\tm{\_Atomic(typename)}结构所指定的类型。（原子类
    型是条件特性，不要求实现支持；参见\ref{lang.ppdir.predef.cond}。）}
\end{itemize}
这些构造派生类型的方法可以递归应用。

\paragraph{}
算术类型与指针类型统称\textit{标量类型}。数组和结构类型统称\textit{聚合类型}。
\footnote{注意聚合类型不包括联合类型，因为联合类型对象一次只能包含一个成员。}

\paragraph{}
未知大小的数组类型是不完整的类型。对于该类型的标识符，可以通过在后续的声明（具有
内部或外部链接）中指定大小来使其完整。未知内容的结构或联合类型（如
\ref{lang.dcl.type.tag}所述）是不完整的类型。对于该类型的所有声明，通过稍后在同
一作用域内声明具有其定义内容的同一结构或联合标记来使其完整。

\paragraph{}
如果类型完整且不是变长数组类型，则该类型具有\textit{已知的常量大小}。

\paragraph{}
数组、函数和指针类型统称为\textit{派生声明子类型}（\textit{derived declarator
types}）。类型\nt{T}的\textit{声明子类型派生}是通过应用\nt{T}的数组类型派生、函
数类型派生或指向\nt{T}的指针类型派生的派生声明子类型的构造。

\paragraph{}
类型由其\textit{类型范畴}刻画，类型范畴指派生类型的最外层派生（如上文派生类型构造
中所述），如果类型不包含派生类型，则是类型本身。

\paragraph{}
到目前为止提到的任何类型都是\textit{未限定类型}。每个未限定类型都有其类型
\footnote{见\ref{lang.dcl.qual}中关于限定数组和函数类型。}的多个\textit{限定版
本}，对应于\tm{const}、\tm{volatile}和\tm{restrict}限定符中的一个、两个或全部三
个的组合。类型的限定或未限定版本是属于同一类型范畴且具有相同表示和对齐要求的不同
类型。\footnote{相同的表示和对齐要求意味着作为函数参数、函数返回值和联合成员的可
互换性。\label{interchg}} 派生类型不由派生它的类型的限定符（如果有）限定。

\paragraph{}
此外，还有\tm{\_Atomic}限定符。使用\tm{\_Atomic}限定符表示原子类型。原子类型的大
小、表示和对齐方式不必与相应的非限定类型相同。因此，只要允许类型的原子版本以及类
型的其他限定版本，本标准就显式使用短语``原子、限定或非限定类型''。短语``限定或非
限定类型''，未特别提及原子时，不包括原子类型。

\paragraph{}
指向\tm{void}的指针应与指向字符类型的指针具有相同的表示和对齐要求。
\textsuperscript{\ref{interchg}} 同样，指向兼容类型的限定或未限定版本的指针应具
有相同的表示和对齐要求。结构类型的所有指针应具有彼此相同的表示和对齐要求。联合类
型的所有指针应具有彼此相同的表示和对齐要求。指向其他类型的指针不需要具有相同的表
示或对齐要求。

\paragraph{}
\ex ``\tm{float *}''指类型``指向\tm{float}的指针''。其类型范畴为指针而不是浮点类
型。该类型的const限定版本为``\tm{float * const}''，而``\tm{const float *}''不是
一个限定类型 --- 其类型为``指向const限定的\tm{float}的指针''，是限定类型的指针。

\paragraph{}
\ex ``\tm{struct tag (*[5])(float)}''指类型``指向返回\tm{struct tag}的函数的指针
的数组''。数组长度为$5$，函数有一个\tm{float}类型的参数。其类型范畴为数组。

\fwdref{6.2.7，6.7}

                                             \ssect{类型表示}{lang.concept.repr}
                                        \sssect{概论}{lang.concept.repr.general}
\paragraph{}
除本节说明外，所有类型的表示都未指明。

\paragraph{}
除了位字段之外，对象由一个或多个连续的字节序列组成，其字节数、顺序和编码为显式指
定，或由实现定义。

\paragraph{}
存储在无符号位字段中的值和\tm{unsigned char}类型的对象应使用纯二进制记号表示。
\footnote{一种使用二进制数字$0$和$1$的整数位置表示法，其中用连续位表示的值是相
加的，以$1$开头，并乘以$2$的连续整数幂，可能最高位除外。（改编自\textit{American
National Dictionary for Information Processing Systems}。）一个字节包含
\tm{CHAR\_BIT}位，\tm{unsigned char}类型的值在$0$到$2^{CHAR\_BIT-1}$之间。}

\paragraph{}
存储在任何其他对象类型的非位字段对象中的值包含$n\times$\texttt{CHAR\_BIT}位组成，
其中$n$是该类型对象的以字节为单位的大小。该值可以复制到\tm{unsigned
char[}\nt{n}\tm{]}类型的对象中（例如，通过\tm{memcpy}）；生成的字节集
称为该值的\textit{对象表示}。位字段中存储的值由$m$位组成，其中$m$是为位字段指定
的大小。对象表示是位字段包含在可寻址存储单元中的一组$m$个位。具有相同对象表示形
式的两个值（NaN除外）相等，但相等的值可能具有不同的对象表示形式。

\paragraph{}
某些对象表示不需要表示对象类型的值。如果对象的存储值具有这样的表示形式，并且由非
字符类型的左值表达式读取，则行为未定义。如果这样的表示是由一个副作用产生的，该副
作用通过非字符类型的左值表达式修改对象的全部或任何部分，则行为未定义。
\footnote{因此，可以将自动变量初始化为陷阱表示，而不会导致未定义的行为，但只有将
适当的值存储在该变量中，才能使用该变量的值。} 这种表示称为陷阱表示。

\paragraph{}
当一个值存储在一个结构或联合类型的对象（包括成员对象）中时，对应于对象表示形式的
任何填充字节的值未指定。\footnote{因此，例如对结构赋值不要求复制任何填充位。}
结构或联合对象的值不是陷阱表示，即使结构或联合对象的成员的值可能是陷阱表示。

\paragraph{}
当一个值存储在联合类型的对象的成员中时，不对应于该成员但对应于其他成员的对象表示
形式的字节值未指定。

\paragraph{}
如果一个运算符应用于具有多个对象表示的值，使用哪种对象表示形式不会影响结果的值。
\footnote{当作为有效类型\tm{T}的对象进行访问时，具有相同有效类型\tm{T}的对象
\tm{x}和\tm{y}可能具有相同的值，但在其他上下文中具有不同的值。特别是，如果为T类
型定义了\tm{==}，\tm{x == y}并不意味着\tm{memcmp(\&x，\&y，sizeof(T)) == 0}。此
外，\tm{x == y}不一定意味着\tm{x}和\tm{y}具有相同的值；对\tm{T}类型值的其他操作
可能会区分它们。} 如果一个值存储在一个对象中，而该对象使用的类型对此值具有多种对
象表示，则未指定使用哪种表示，但不应生成陷阱表示。

\paragraph{}
原子类型对象的存取使用\tm{memory\_order\_seq\_cst}语义进行。

\fwdref{6.7，6.5，6.3.2.1，7.17.3}

                                            \sssect{整型}{lang.concept.repr.int}
\paragraph{}
对于\tm{unsigned char}以外的无符号整型，对象表示的位应分为两组：值位和填充位（后
者不是必须）。如果有$N$个值位，则每个位应表示$1$到$2^{N-1}$之间的$2$的不同幂，使
得该类型的对象能够使用纯二进制表示法表示$0$到$2^{N-1}$之间的值；这称为值的表示。
任何填充位的值未指定。\footnote{填充位的某些组合可能会生成陷阱表示，例如填充位是
一个奇偶校验位。无论如何，有效值的任何算术运算都不能生成除作为异常条件的一部分之
外的陷阱表示，比如溢出，而无符号类型不会发生溢出。填充位的所有其他组合都是值位指
定的值的可选对象表示形式。}

\paragraph{}
对于有符号整型，对象表示的位应分为三组：值位、填充位和符号位。填充位不是必须；
\tm{signed char}不应该有任何填充位。只有一个符号位。每个值位的值应与相应无符号类
型的对象表示中的相同位具有相同的值（如果有符号类型中有$M$个值位，无符号类型中有
$N$个值位，则$M \le N$）。如果符号位为零，则不会影响结果值。如果符号位为$1$，则
应以下列方式修改该值：
\begin{itemize}
  \item{符号位$0$的对应值取反（\textit{符号和量值}（\textit{sign and
    magnitude}））；}
  \item{符号位值为$-(2^M)$（\textit{二补码}（\textit{two's complement}））；}
  \item{符号位值为$-(2^M-1)$（\textit{一补码}（\textit{ones' complement}））；}
\end{itemize}
使用哪一个由实现定义，如同符号位为1和所有值位为零的值（前两个），或符号位和所有
值位为1（一补码）的值是陷阱表示还是正常值。在符号量值和一补码的情况下，如果该
表示是一个正常值，则称为\textit{负零}。

\paragraph{}
如果实现支持负零，应该仅能通过以下生成：
\begin{itemize}
  \item{运算符\tm{\&，|，\^，~，\tl{}\tl{}}和\tm{\tg{}\tg{}}，具有产生该值的操作
    数；}
  \item{运算符\tm{+，-，*，/}和\tm{\%}，其中一个操作数为负零，结果为零；}
  \item{基于以上情形的复合赋值运算符；}
\end{itemize}
未指明这些情况产生负零还是正常的零，以及当存于对象中时负零是否变成正常的零。

\paragraph{}
如果实现不支持负零，则使用能够产生这种值的操作数的运算符\tm{\&，|，\^，~，
\tl{}\tl{}}和\tm{\tg{}\tg{}}的行为未定义。

\paragraph{}
填充位的值未指定。\footnote{填充位的某些组合可能会生成陷阱表示，例如填充位是
一个奇偶校验位。无论如何，有效值的任何算术运算都不能生成除作为异常条件的一部分之
外的陷阱表示，比如溢出。填充位的所有其他组合都是值位指定的值的可选的对象表示。}
符号位为零的有符号整型的有效（非陷阱）对象表示是对应无符号类型的有效对象表示，且
应该表示相同值。对任何整型，所有位为零的对象表示应该是该类型中值零的表示。

\paragraph{}
整型的\textit{精度}指其用于表示值的位数，不包括符号位和填充位。整型的
\textit{宽度}与精度一样，但包括符号位；因此对无符号类型这两个值一样，而有符号类
型宽度比精度多一。

                                 \ssect{兼容类型与合成类型}{lang.concept.compat}
\paragraph{}
两个相同类型为\textit{兼容类型}。额外的确定两个类型是否兼容的规则在类型说明
\ref{lang.dcl.type}，类型限定\ref{lang.dcl.qual}和声明子\ref{lang.dcl.decl}中描
述。\footnote{两个类型不需要完全等价才能兼容。} 另外，不同翻译单元中声明的两
个结构、联合或枚举类型的标记和成员满足以下要求，则它们是兼容的：如果一个声明了标
记，则另一个应使用相同的标记声明。如果在各自的翻译单元内的某个地方是完整的，则适
用以下附加要求：成员之间应存在一一对应的关系，使得每对对应的成员声明为兼容类型；
如果配对中的一个成员使用对齐说明符来声明，则另一个成员应用等效的对齐说明符声明；
如果配对中的一个成员使用名称声明，则另一个成员应该使用相同的名称声明。对于两个结
构，对应成员应该以相同的顺序声明。对于两个结构或联合体，对应的位字段应该具有相同
的宽度。对于两个枚举，对应的成员应具有相同的值。

\paragraph{}
引用同一对象或函数的所有声明都应具有兼容类型；否则行为未定义。

\paragraph{}
\textit{合成类型}可以由两种兼容的类型构造；它是一种与这两种类型都兼容并满足以下
条件的类型：
\begin{itemize}
  \item{如两个类型均为数组类型，以下规则适用：
    \begin{itemize}
      \item{如其中一个是已知常量大小的数组，合成类型为该大小的数组。}
      \item{否则，如其中一个是变长数组，大小由未计算表达式指定，则行为未定义。}
      \item{否则，如其中一个是指定大小的变长数组，合成类型为该大小的变长数组。}
      \item{否则，如其中一个是未指定大小的变长数组，合成类型为未指定大小的变长数
        组。}
      \item{否则，两个类型均为未知大小的数组，合成类型为未知大小的数组。}
    \end{itemize}
    合成类型的元素类型为两个元素类型的合成类型。}
  \item{如果仅有一个是带参数类型列表（函数原型）的函数类型，则合成类型为带参数类
    型列表的函数原型。}
  \item{如果两个类型均为带参数类型列表的函数类型，合成参数类型列表中的参数类型为
    对应参数的合成类型。}
\end{itemize}
这些规则可以递归应用于两个类型所派生于的类型。

\paragraph{}
对于具有内部或外部链接的标识符，其所在作用域中该标识符有一个之前的声明可见，
\footnote{如\ref{lang.concept.scope}所述，后一个声明可能隐藏前一个声明。} 如果前
面的声明指定了内部或外部链接，则后一个声明中的标识符类型将成为合成类型。

\fwdref{6.7.6.2}

\paragraph{}
\ex* 给定以下两个文件作用域声明：
\begin{lstlisting}
    int f(int (*)(), double (*)[3]);
    int f(int (*)(char*), double (*)[]);
\end{lstlisting}
为函数产生的合成类型为：
\begin{lstlisting}
    int f(int (*)(char*), double (*)[3]);
\end{lstlisting}

                                            \ssect{对象对齐}{lang.concept.align}
\paragraph{}
完整的对象类型具有对齐要求，这些要求对可分配（allocated）该类型对象的地址进行限
制。对齐是一个实现定义的整数值，表示可以分配给定对象的连续地址之间的字节数。对象
类型对该类型的每个对象都施加对齐要求：可以使用\tm{\_Alignas}关键字要求更严格的对
齐。

\paragraph{}
\textit{基本对齐}表示小于或等于所有上下文中实现所支持的最大对齐的对齐，该对齐等
于\tm{\_Alignof(max\_align\_t)}。

\paragraph{}
\textit{扩展对齐}表示大于\tm{\_Alignof(max\_align\_t)}的对齐。是否支持任何扩展对
齐以及支持的上下文由实现定义。具有扩展对齐要求的类型是\textit{过度对齐的类型}
（\textit{over-aligned type}）。\footnote{每个过度对齐的类型都是或包含一个结构或
联合类型，该结构或联合类型具有适用扩展对齐的成员。}

\paragraph{}
对齐以\tm{size\_t}类型的值表示。有效的对齐仅包括由基本类型的\tm{\_Alignof}表达式
返回的所有值，以及附加的实现定义的一组值，可能为空。每个有效值应该为二的非负整数
幂。

\paragraph{}
对齐具有从\textit{弱}到\textit{强}（\textit{更严格}）的顺序。更严格的对齐具有更
大的对齐值。满足对齐要求的地址也满足任何更弱的有效对齐要求。

\paragraph{}
完整类型的对齐要求可以使用\tm{\_AlignOf}表达式查询。类型\tm{char}、
\tm{signed char}和\tm{unsigned char}的对齐要求最低。

\paragraph{}
比较对齐有意义且提供了明显的结果：
\begin{itemize}
  \item{数值相等的两个对齐也相等。}
  \item{数值不等的两个对齐也不等。}
  \item{更大的对齐表示更严格的对齐。}
\end{itemize}

                                                          \sect{转换}{lang.conv}
\paragraph{}
一些运算符自动将操作数值从一种类型转换为另一种类型。本节指定此类\textit{隐式转换
}所需的结果，以及由强制转换操作（\textit{显式转换}）产生的结果。第
\ref{lang.conv.arith.usualarith}节中的列表总结了大多数普通运算符执行的转换；在第
\ref{lang.expr}节中对每个运算符进行补充讨论。

\paragraph{}
除非另有明确说明，否则将操作数值转换为兼容类型不会导致值或表示形式发生更改。

\fwdref{6.5.4}

                                             \ssect{算术操作数}{lang.conv.arith}
                                 \sssect{布尔，字符与整型}{lang.conv.arith.rank}
\paragraph{}
每一个整型具有\textit{整型转换阶}，定义如下：
\begin{itemize}
  \item{两个有符号整型即使表示相同，其转换阶也不一样。}
  \item{有符号整型的阶应大于精度较低的有符号整型的阶。}
  \item{阶（\tm{long long int}）$>$阶（\tm{long int}）$>$阶（\tm{int}）$>$
    阶（\tm{short int}）$>$阶（\tm{signed char}）。}
  \item{任何无符号整型的阶应等于相应有符号整型的阶（如果有）。}
  \item{任何标准整型的阶应大于任何宽度相同的扩展整型的阶。}
  \item{阶（\tm{char}）$=$阶（\tm{signed char}）$=$阶（\tm{unsigned char}）。}
  \item{\tm{\_Bool}的阶小于所有其他标准整型的阶。}
  \item{枚举类型的阶等于兼容整型的阶（见\ref{lang.dcl.type.enum}）。}
  \item{扩展有符号整型相对于另一个具有相同精度的扩展有符号整型的阶由实现定义，但
    仍受用于确定整型转换阶的其他规则所约束。}
  \item{对于所有整型\tm{T1}、\tm{T2}和\tm{T3}，如果\tm{T1}的阶大于\tm{T2}，
    \tm{T2}的阶大于\tm{T3}，则\tm{T1}的阶大于\tm{T3}。}
\end{itemize}

\paragraph{}
在可以使用\tm{int}或\tm{unsigned int}的表达式中，可以使用以下内容：
\begin{itemize}
  \item{整型（\tm{int}或\tm{unsigned int}除外）对象或表达式，其整型转换阶小于或
    等于\tm{int}和\tm{unsigned int}的阶。}
  \item{\tm{\_Bool}，\tm{int}，\tm{signed int}或\tm{unsigned int}类型的位字段。}
\end{itemize}
如果\tm{int}可以表示原类型的所有值（如同宽度受限的位字段），则该值将转换为
\tm{int}；否则将转换为\tm{unsigned int}。这些称为\textit{整型提升}。\footnote{整
型提升仅适用于：作为常规算术转换的一部分，应用于某些参数表达式、一元\tm{+}、
\tm{-}、和\tm{\~}运算符的操作数以及移位运算符的两个操作数，由各自的章节指定。}
所有其他类型不受整型提升的影响。

\paragraph{}
整型提升保留值和符号。如前所述，``普通''\tm{char}是否被视为有符号由实现定义。

\fwdref{6.7.2.2，6.7.2.1}

                                         \sssect{布尔类型}{lang.conv.arith.bool}
\paragraph{}
任何标量值转换为\tm{\_Bool}时，如果值等于$0$，则结果为$0$；否则结果为$1$。
\footnote{NaN不等于$0$，所以转换成$1$。}

                             \sssect{有符号和无符号整型}{lang.conv.arith.signed}
\paragraph{}
当一个整型的值被转换为除\tm{\_Bool}外的另一个整型时，如果该值可以用新类型表示，
则该值不变。

\paragraph{}
否则，如果新类型为无符号，则通过重复加或减新类型可表示的最大值加一来转换该值，直
至该值在新类型的范围内。\footnote{该规则描述数学值而不是表达类型值上的算术。}

\paragraph{}
否则，新类型为有符号，且值不能在其中表示；则或者结果由实现定义，或者产生实现定义
信号。

                                    \sssect{实浮点与整型}{lang.conv.arith.fpint}
\paragraph{}
当实浮点类型的有限值转换为除\tm{\_Bool}以外的整型时，小数部分将被丢弃（即向零截
断）。如果整型不能表示整数部分的值，则行为未定义。\footnote{整型值转换为无符号类
型时所执行的取余操作在实浮点类型的值转换为无符号类型时不要求执行。因此，可移植的
实浮点值范围是$(-1,$\tm{U}\textit{type}\tm{\_MAX}$+1)$。}

\paragraph{}
当整型的值转换为实浮点类型时，如果要转换的值可以在新类型中精确表示，则该值不变。
如果要转换的值在可以表示的值范围内但不能精确表示，则结果是最接近的更高或更低可表
示值，以实现定义的方式进行选择。如果要转换的值超出了可以表示的值范围，则行为未定
义。某些隐式转换的结果可能用比新类型所要求的更大的范围和精度表示（见
\ref{lang.conv.arith.usualarith}和\ref{lang.stmt.jmp.ret}）。

                                     \sssect{实浮点类型}{lang.conv.arith.double}
\paragraph{}
当实浮点类型的值转换为实浮点类型时，如果要转换的值可以在新类型中精确表示，则该值
不变。如果要转换的值在可以表示的值范围内但不能精确表示，则结果是最接近的更高或更
低可表示值，以实现定义的方式进行选择。如果要转换的值超出可以表示的值范围，则行为
未定义。某些隐式转换的结果可能用比新类型所要求的更大的范围和精度表示（见
\ref{lang.conv.arith.usualarith}和\ref{lang.stmt.jmp.ret}）。

                                           \sssect{复类型}{lang.conv.arith.cmpl}
\paragraph{}
当复类型的值转换为另一个复类型时，实部和虚部都遵循对应实类型的转换规则。

                                      \sssect{实数与复数}{lang.conv.arith.rcmpl}
\paragraph{}
当实类型的值转换为复类型时，复数结果值的实数部分由转换为相应实数类型的规则确定，
复数结果值的虚部为正零或无符号零。

\paragraph{}
当复类型的值转换为实类型时，将丢弃复数值的虚部，并根据对应实类型的转换规则转换实
数部分的值。

                               \sssect{常规算术转换}{lang.conv.arith.usualarith}
\paragraph{}
许多使用算术类型操作数的运算符以类似的方式进行转换并产生结果类型。其目的是确定操
作数和结果的公共\textit{实类型}。对于指定的操作数，每个操作数都会在不改变类型域
的情况下转换为对应实类型是该公共实类型的类型。除非另有明确说明，否则公共实类型也
是结果的对应实类型，如果它们相同，则其类型域是操作数的类型域，否则是复类型。这种
模式称为\textit{常规算术转换}：
\begin{itemize}
  \item{首先，如果其中任一操作数的对应实类型为\tm{long double}，则另一个操作数将
    在不改变类型域的情况下转换为对应实类型为\tm{long double}的类型。}
  \item{否则，如果其中一个操作数的对应实类型为\tm{double}，则另一个操作数将在不
    改变类型域的情况下转换为其对应实类型为\tm{double}的类型。}
  \item{否则，如果其中任一操作数的对应实类型为\tm{float}，则另一个操作数将在不改
    变类型域的情况下转换为其对应实类型为\tm{float}的类型。\footnote{例如，
    \tm{double \_Complex}和\tm{float}的加法只需要将\tm{float}操作数转换为
    \tm{double}（并产生\tm{double \_Complex}结果）。}}
  \item{否则，对两个操作数执行整型提升。然后对提升后的操作数应用以下规则：
    \begin{itemize}
      \item{如果两个操作数具有相同类型则不再进行转换。}
      \item{否则，如果两个操作数都为有符号整型或都为无符号整型，则具有较小整型转
        换阶类型的操作数将转换为具有较大阶的操作数类型。}
      \item{否则，如果无符号整型的操作数的阶大于或等于另一个操作数类型的阶，则有
        符号整型的操作数将转换为无符号整型的操作数类型。}
      \item{否则，如果有符号整型的操作数类型可以表示无符号整型的操作数类型的所有
        值，则无符号整型的操作将转换为有符号整型的操作数类型。}
      \item{否则，两个操作数都转换为对应于有符号整型操作数的无符号整型。}
    \end{itemize}}
\end{itemize}

\paragraph{}
浮点操作数的值和浮点表达式的结果可以表示在比类型所需的范围和精度更大的范围和精度
上；因此不改变类型。\footnote{仍然需要转换和赋值运算符以删除额外的范围和精度。}

                                             \ssect{其他操作数}{lang.conv.other}
                                \sssect{左值，数组和函数}{lang.conv.other.desig}
\paragraph{}
\textit{左值}是一个表达式（具有非\tm{void}的对象类型），可能指定一个对象；
\footnote{名称``左值''最初来自赋值表达式\tm{E1 = E2}，其中左操作数\tm{E1}需要是
（可修改的）左值。把它视为表示对象的``定位器''可能更好。有时被称为``右值''的东西
在本标准中称为``表达式的值''。\linebreak
左值的一个明显示例是对象的标识符。另一示例是，如果\tm{E}是对象指针的一元表达式，
则\tm{*E}是指代\tm{E}所指对象的左值。} 如果左值在计算时没有指代对象，则行为未定
义。当一个对象被称为具有特定类型时，该类型由用于指定该对象的左值指定。\textit{可
修改左值}指不具有数组类型，不具有不完整类型，不具有const限定类型，且如果是结构或
联合类型则没有任何成员（递归地包括所包含聚合或联合的任何成员或元素）具有常限定类
型的左值。

\paragraph{}
除作为\tm{sizeof}运算符、一元\tm{\&}运算符、\tm{++}运算符、\tm{\dsh\dsh}运算符的
操作数或作为\tm{.}运算符或赋值运算符的左操作数，非数组类型的左值被转换为指定对象
中所存储的值（并且不再是左值）；称为\textit{左值转换}。如果左值具有限定类型，则
该值具有左值类型的非限定版本；另外，如果左值具有原子类型，则该值具有左值类型的非
原子版本；否则，该值具有左值的类型。如果左值具有不完整类型且不是数组类型则行为未
定义。如果左值指定了一个自动存储期的对象，该对象可能使用\tm{register}存储类声明
（从不使用其地址），并且该对象未初始化（未使用初始化声明，并且在使用之前未对其进
行任何赋值）），则行为未定义。

\paragraph{}
除作为\tm{sizeof}运算符或一元\tm{\&}运算符的操作数，或者是用于初始化数组的字符串
文本，否则将类型为``...类型的数组''的表达式转换成类型为``指向...类型的指针''的表
达式，指向数组对象的初始元素，且不是左值。如果数组对象具有寄存器存储类，则行为未
定义。

\paragraph{}
\textit{函数指示符}指具有函数类型的表达式。除作为\tm{sizeof}运算符\footnote{由于
不会发生此转换，因此\tm{sizeof}运算符的操作数仍然是函数指示符，并且违反了
\ref{lang.expr.unary.sizeof}中的约束。} 或一元\tm{\&}运算符的操作数，类型为``返
回...类型的函数''的函数指示符将转换成类型为``指向返回...类型的函数的指针''的表达
式。

\fwdref{6.5.3.2，6.5.16，7.19，6.7.9，6.5.2.4，6.5.3.1，6.5.3.4，6.5.2.3}

                                             \sssect{void}{lang.conv.other.void}
\paragraph{}
\textit{void表达式}（具有\tm{void}类型的表达式）的（不存在）值不得以任何方式使用
，且不应该对此类表达式使用隐式或显式转换（除转换成\tm{void}）。如果将任何其他类
型的表达式作为\tm{void}表达式进行计算，则会丢弃其值或指示符。（\tm{void}表达式仅
为了其副作用而计算。）

                                              \sssect{指针}{lang.conv.other.ptr}
\paragraph{}
指向\tm{void}的指针可以转换为或转换自指向任何对象类型的指针。指向任何对象类型的
指针可以转换为指向\tm{void}的指针，然后再转回；结果应该等于原指针。

\paragraph{}
对于任何限定符\nt{q}，指向非\nt{q}限定类型的指针可以转换为指向该类型的\nt{q}限定
版本的指针；存储在原指针和转换后的指针中的值应该相等。

\paragraph{}
值为$0$的整型常量表达式，或转换为\tm{void *}类型的这种表达式，称为\textit{零指针
常量}。\footnote{\tm{<stddef.h>}（或其他头）中的宏\tm{NULL}定义为零指针常量；见
\ref{lib.def}。} 如果将零指针常量转换为指针类型，则结果指针，称为\textit{零指针}
，与指向任何对象或函数的指针进行比较将保证不相等。

\paragraph{}
将零指针转换为另一种指针类型将产生该类型的零指针。任何两个零指针都应该相等。

\paragraph{}
整型可以转换为任何指针类型。除之前指定，结果由实现定义，可能未正确对齐，可能不指
向所引用类型的实体，或者可能是陷阱表示。\footnote{用于将指针转换为整型或整型转换
为指针的映射函数旨在与执行环境的寻址结构保持一致性。}

\paragraph{}
任何指针类型都可以转换为整型。除之前指定外，结果由实现定义。如果结果无法以整型表
示，则行为未定义。结果不必在任何整型的值范围内。

\paragraph{}
指向对象类型的指针可以转换为指向不同对象类型的指针。如果对于所引用的类型，结果指
针未正确对齐\footnote{通常，``正确对齐''这个概念是传递性的：如果指向类型A的指针
正确对齐地指向类型B的指针，而B指针又正确对齐地指向类型C的指针，则指向类型A的指针
正确对齐地指向类型C的指针。}，则行为未定义。否则当再次转换回时，结果等于原指针。
当指向对象的指针转换为指向字符类型的指针时，结果指向对象的最低地址字节。结果连续
递增，直到对象的大小，产生指向对象的剩余字节的指针。

\paragraph{}
指向一种类型的函数指针可以转换为指向另一种类型的函数指针并且再次转回；结果应该等
于原指针。如果转换的指针用于调用与所引用类型不兼容的函数，则行为未定义。

\fwdref{6.5.4，6.5.9，7.20.1.4，6.5.16.1}

                                                       \sect{词法元素}{lang.lex}
\syntax
\paragraph{}
\synsym{token}
  \synprd{\nt{keyword}}
  \synprd{\nt{identifier}}
  \synprd{\nt{constant}}
  \synprd{\nt{string-literal}}
  \synprd{\nt{punctuator}}
\synsym{preprocessing-token}
  \synprd{\nt{header-name}}
  \synprd{\nt{identifier}}
  \synprd{\nt{pp-number}}
  \synprd{\nt{character-constant}}
  \synprd{\nt{string-literal}}
  \synprd{\nt{punctuator}}
  \synprd[]{除以上所列的每一个非空白字符}

\constraint
\paragraph{}
转换为标记的每个预处理标记应具有关键字、标识符、常量、字符串文本或标点符号的词法
形式之一。

\semantic
\paragraph{}
\textit{标记}（\textit{token}）是翻译阶段\ref{tpit7}和\ref{tpit8}中语言的最小词
法元素。标记的类别：包括关键字、标识符、常量、字符串文本和标点符号。预处理标记是
翻译阶段\ref{tpit3}到\ref{tpit6}中语言的最小词法元素。预处理标记的类别包括：头名
称、标识符、预处理数字、字符常量、字符串文本、标点符号和词法上不匹配其他预处理标
记类别的单个非空白字符。\footnote{在翻译阶段\ref{tpit4}内部使用了另一类别，即占
位标记（见\ref{lang.ppdir.macro.concat}）；它不能出现在源文件中。} 如果\tm{\sq}
或\tm{\dq}字符匹配最后一个类别，则行为未定义。预处理标记可以用\textit{空格}分隔
；这包括注释（稍后描述）或\textit{空白字符}（空格，水平制表符，换行符，垂直制表
符或换页符）或两者均有。如\ref{lang.ppdir}所述，在翻译阶段\ref{tpit4}的某些情况
下，空格（或不存在）不仅仅是预处理标记分隔。在预处理标记中空格只能作为头名称的一
部分或在字符常量或字符串文本中的引号字符之间出现。

\paragraph{}
如果输入流到达某个字符已被解析为预处理标记，下一个预处理标记是可能构成一个预处理
标记的最长序列。此规则有一个例外：头名称预处理标记仅在\tm{\#include}预处理指令
和\tm{\#pragma}指令内的实现定义位置中被识别。在这样的上下文中，可以是头名称或字
符串文本的字符序列被识别为前者。

\paragraph{}
\ex 程序片段\tm{1Ex}被解析为预处理数字标记（不是一个有效的浮点或整型常量标记），
即使解析为预处理标记\tm{1}和\tm{Ex}可能产生有效表达式（例如，如果\tm{Ex}是定义为
\tm{+1}的宏。类似地，程序片段\tm{1E1}被解析为预处理数字（一个是有效的浮点常量标
记），无论\tm{E}是否是宏名。

\paragraph{}
\ex 程序片断\tm{x+++++y}被分析成\tm{x ++ ++ + y}，违背了自增运算符约束，即使分析
成\tm{x ++ + ++ y}可以产生正确的表达式。

\fwdref{6.4.4.4，6.4.9，6.5，6.4.4.2，6.4.7，6.10.3，6.5.2.4，6.5.3.1，6.10，
6.4.8，6.4.5}

                                                \ssect{关键字}{lang.lex.keyword}
\syntax
\paragraph{}
\synsym[one of]{keyword}
\bgroup
\newcommand{\kwgrp}[4][\linebreak]{\synprd[#1]{\makebox[24em]{
      \makebox[8em][l]{\tm{#2}}
      \makebox[8em][l]{\tm{#3}}
      \makebox[8em][l]{\tm{#4}}}}}
  \kwgrp{auto}      {if}        {unsigned}
  \kwgrp{break}     {inline}    {void}
  \kwgrp{case}      {int}       {volatile}
  \kwgrp{char}      {long}      {while}
  \kwgrp{const}     {register}  {\_Alignas}
  \kwgrp{continue}  {restrict}  {\_Alignof}
  \kwgrp{default}   {return}    {\_Atomic}
  \kwgrp{do}        {short}     {\_Bool}
  \kwgrp{double}    {signed}    {\_Complex}
  \kwgrp{else}      {sizeof}    {\_Generic}
  \kwgrp{enum}      {static}    {\_Imaginary}
  \kwgrp{extern}    {struct}    {\_Noreturn}
  \kwgrp{float}     {switch}    {\_Static\_assert}
  \kwgrp{for}       {typedef}   {\_Thread\_local}
  \kwgrp[]{goto}    {union}     {}
\egroup

\semantic
\paragraph{}
上述标记（大小写敏感）保留用作关键字（翻译阶段\ref{tpit7}和\ref{tpit8}），不得另
作他用。关键字\tm{\_Imaginary}保留用作指定虚类型。\footnote{虚类型的一种可能的规
范见附录\ref{comparith}。}

                                                     \ssect{标识符}{lang.lex.id}
                                              \sssect{概论}{lang.lex.id.general}
\syntax
\paragraph{}
\synsym{identifier}
\synprd{\nt{identifier-nondigit}}
\synprd{\nt{identifier identifier-nondigit}}
\synprd{\nt{identifier digit}}
\synsym{identifier-nondigit}
\synprd{\nt{nondigit}}
\synprd{\nt{universal-character-name}}
\synprd{其他实现定义字符}
\synsym[one of]{nondigit}
\synprd{\tm{\_  a b c d e f g h i j k l m}}
\synprd{\tm{\ \ n o p q r s t u v w x y z}}
\synprd{\tm{\ \ A B C D E F G H I J K L M}}
\synprd{\tm{\ \ N O P Q R S T U V W X Y Z}}
\synsym[one of]{digit}
\synprd[]{\tm{0 1 2 3 4 5 6 7 8 9}}

\semantic
\paragraph{}
标识符是由非数字字符（包括下划线\tm{\_}、小写和大写拉丁字母以及其他字符）和数字
组成的序列，用于指定\ref{lang.concept.scope}中所述的一个或多个实体。小写和大写字
母是不同的。标识符的最大长度没有特定限制。

\paragraph{}
标识符中的每个通用字符名称应指定一个字符，其ISO/IEC 10646中的编码属于
\ref{uchar.range}中规定的范围之一。\footnote{在链接器不能接受扩展字符的系统上，
可以使用通用字符名的编码来形成有效的外部标识符。例如，某些未使用的字符或字符序列
可用于将\tm{\bs{}u}编码为通用字符名。扩展字符可能产生一个长的外部标识符。} 初始
字符不应是表示字符编码属于\ref{uchar.disallowed}规定范围之一的通用字符名。实现可
能允许不属于基本源字符集的多字节字符出现在标识符中；允许哪些字符及其与通用字符名
的对应关系由实现定义。

\paragraph{}
当预处理标记在翻译阶段\ref{tpit7}转换为标记时，如果预处理标记可以转换为关键字或
标识符，则它将转换为关键字。

\implimit
\paragraph{}
如\ref{env.env.limit.trans}中所讨论，实现可能限制标识符中有效的初始字符数；
\textit{外部名称}（具有外部链接的标识符）的限制可能比\textit{内部名称}（宏名
称或没有外部链接的标识符）的限制更严格。标识符中有效字符数由实现定义。

\paragraph{}
任何有效字符不同的标识符都是不同的标识符。如果两个标识符仅无效字符不同，则行为未
定义。

\fwdref{6.4.3，6.10.3}

                                       \sssect{预定义标识符}{lang.lex.id.predef}
\semantic
\paragraph{}
翻译器应该隐式声明标识符\tm{\_\_func\_\_}，如同每一个函数定义的起始花括号后紧跟
声明
\begin{lstlisting}
    static const char __func__[] = "function-name";
\end{lstlisting}
这里\textit{function-name}为词法包含的函数名。\footnote{由于名称
\tm{\_\_func\_\_}保留给实现（\ref{lib.intro.reserved}）使用，如果使用名称
\tm{\_\_func\_\_}显式声明任何其他标识符，则行为未定义。}

\paragraph{}
此名称如同隐式声明用源字符集书写进行编码，然后转换为执行字符集，如翻译阶段
\ref{tpit5}所示。

\paragraph{}
\ex* 考虑代码段：
\begin{lstlisting}
    #include <stdio.h>
    void myfunc(void) {
      printf("%s\n", __func__);
      /* ... */
    }
\end{lstlisting}
每次调用函数将向标准输出流打印：
\begin{lstlisting}
    myfunc
\end{lstlisting}

\fwdref{6.9.1}

                                               \ssect{通用字符名}{lang.lex.univ}
\syntax
\paragraph{}
\synsym{universal-character-name}
  \synprd{\tm{\bs{}u} \nt{hex-quad}}
  \synprd{\tm{\bs{}U} \nt{hex-quad hex-quad}}
\synsym{hex-quad}
  \synprd[]{\nt{hexadecimal-digit hexadecimal-digit hexadecimal-digit
                hexadecimal-digit}}

\constraint
\paragraph{}
通用字符名不应指定短标识符小于00A0的字符，除0024（\tm{\$}）、0040（\tm{@}）或
0060（\tm{\sq}）外，也不应指定D800到DFFF范围内的字符。\footnote{这些禁止的字符是
基本字符集中的字符以及ISO/IEC 10646为控制字符、DELETE字符和S区域（保留供UTF-16使
用）保留的代码位置。}

\desc
\paragraph{}
通用字符名可用于标识符，字符常量和字符串文本中，以表示不属于基本字符集中的字符。

\semantic
\paragraph{}
通用字符名\tm{\bs{}U}\textit{nnnnnnnn}表示8位数字短标识符（由ISO/IEC 10646指定）
为\linebreak\textit{nnnnnnnn}\footnote{字符的短标识符首次在ISO/IEC
10646-1:1993/Amd.9:1997中指定。}的字符。类似的，通用字符名
\tm{\bs{}u}\textit{nnnn}表示4位数字短标识符为\textit{nnnn}的字符（其8位数字短标
识符为0000\textit{nnnn}）。

                                                    \ssect{常量}{lang.lex.const}
\syntax
\paragraph{}
\synsym{constant}
  \synprd{\nt{integer-constant}}
  \synprd{\nt{floating-constant}}
  \synprd{\nt{enumeration-constant}}
  \synprd[]{\nt{character-constant}}

\constraint
\paragraph{}
每个常量应具有类型且常量值应在其类型可表示值范围内。

\semantic
\paragraph{}
每个常量具有类型，由其形式和值确定，如后文详述。

                                           \sssect{整型常量}{lang.lex.const.int}
\syntax
\paragraph{}
\synsym{integer-constant}
  \synprd{\nt{decimal-constant integer-suffix\tsub{opt}}}
  \synprd{\nt{octal-constant integer-suffix\tsub{opt}}}
  \synprd{\nt{hexadecimal-constant integer-suffix\tsub{opt}}}
\synsym{decimal-constant}
  \synprd{\nt{nonzero-digit}}
  \synprd{\nt{decimal-constant digit}}
\synsym{octal-constant}
  \synprd{\tm{0}}
  \synprd{\nt{octal-constant octal-digit}}
\synsym{hexadecimal-constant}
  \synprd{\nt{hexadecimal-prefix hexadecimal-digit}}
  \synprd{\nt{hexadecimal-constant hexadecimal-digit}}
\synsym[one of]{hexadecimal-prefix}
  \synprd{\tm{0x 0X}}
\synsym[one of]{nonzero-digit}
  \synprd{\tm{0 1 2 3 4 5 6 7 8 9}}
\synsym[one of]{octal-digit}
  \synprd{\tm{0 1 2 3 4 5 6 7}}
\synsym[one of]{hexadecimal-digit}
  \synprd{\tm{0 1 2 3 4 5 6 7 8 9}}
  \synprd{\tm{a b c d e f}}
  \synprd{\tm{A B C D E F}}
\synsym{integer-suffix}
  \synprd{\nt{unsigned-suffix long-suffix\tsub{opt}}}
  \synprd{\nt{unsigned-suffix long-long-suffix}}
  \synprd{\nt{long-suffix unsigned-suffix\tsub{opt}}}
  \synprd{\nt{long-long-suffix unsigned-suffix\tsub{opt}}}
\synsym[one of]{unsigned-suffix}
  \synprd{\tm{u U}}
\synsym[one of]{long-suffix}
  \synprd{\tm{l L}}
\synsym[one of]{long-long-suffix}
  \synprd[]{\tm{ll LL}}

\desc
\paragraph{}
整型常量以数字开始，但没有小数点或指数部分。可能有前缀指定其基和后缀指定其类型。

\paragraph{}
十进制常数以非零数字开头，由一系列十进制数字组成。八进制常量由前缀\tm{0}，后跟上
（可选）数字\tm{0}到\tm{7}的序列组成。十六进制常量由前缀\tm{0x}或\tm{0X}后跟十进
制数字序列和字母\tm{a}（或\tm{A}）到\tm{f}（或\tm{F}）组成，字母分别具有取值10到
15。

\semantic
\paragraph{}
十进制常量的值以10为基数计算；八进制常量的值以8为基数计算；十六进制常量的值以16
为基数计算。词法上第一个数字是最高位。

\paragraph{}
整型常量的类型是对应列表中可以表示其值的第一个。
\begin{table}[!h]
  \newcommand{\li}{\tm{long int}}
  \newcommand{\lli}{\tm{long long int}}
  \newcommand{\ui}{\tm{unsigned int}}
  \newcommand{\uli}{\tm{unsigned long int}}
  \newcommand{\ulli}{\tm{unsigned long long int}}
  \centering
  \begin{tabular}{l||l|l}
    后缀 & 十进制常量 & 八进制或十六进制常量                                  \\
    \hline\hline
    无 & \tm{int} & \tm{int}                                                  \\
       & \li      & \ui                                                      \\
       & \lli     & \li                                                       \\
       &          & \uli                                                      \\
       &          & \lli                                                      \\
       &          & \ulli                                                     \\
    \hline
    \tm{u}或\tm{U} & \ui   & \ui                                              \\
                   & \uli  & \uli                                             \\
                   & \ulli & \ulli                                            \\
    \hline
    \tm{l}或\tm{L} & \li  & \li                                               \\
                   & \lli & \uli                                              \\
                   &      & \lli                                              \\
                   &      & \ulli                                             \\
    \hline
    \tm{u}或\tm{U}和 & \uli  & \uli                                           \\
    \tm{l}或\tm{L}   & \ulli & \ulli                                          \\
    \hline
    \tm{ll}或\tm{LL} & \lli & \lli                                            \\
                     &      & \ulli                                           \\
    \hline
    \tm{u}或\tm{U}和 & \ulli & \ulli                                          \\
    \tm{ll}或\tm{LL} &       &
  \end{tabular}
\end{table}

\paragraph{}
如果整型常量不能由其列表中的任何类型表示，它可能具有扩展整型，如果扩展整型可以表
示其值的话。如果对该常量，列表中的所有类型都是有符号的，则扩展整型应该有符号。如
果对该常量，列表中的所有类型都是无符号的，则扩展整型应该无符号。如果列表同时包含
有符号和无符号类型，则扩展整型可以是有符号或无符号类型。如果整型常量不能由其列表
中的任何类型表示且没有扩展的整型可以表示，则整型常量没有类型。

\pagebreak

                                         \sssect{浮点常量}{lang.lex.const.float}
\syntax
\paragraph{}
\synsym{floating-constant}
  \synprd{\nt{decimal-floating-constant}}
  \synprd{\nt{hexadecimal-floating-constant}}
\synsym{decimal-floating-constant}
  \synprd{\nt{fractional-constant exponent-part\tsub{opt}
              floating-suffix\tsub{opt}}}
  \synprd{\nt{digit-sequence exponent-part floating-suffix\tsub{opt}}}
\synsym{hexadecimal-floating-constant}
  \synprd{\nt{hexadecimal-prefix hexadecimal-fractional-constant}}
    \synprd{\hspace{6em}\nt{binary-exponent-part floating-suffix\tsub{opt}}}
  \synprd{\nt{hexadecimal-prefix hexadecimal-digit-sequence}}
    \synprd{\hspace{6em}\nt{binary-exponent-part floating-suffix\tsub{opt}}}
\synsym{fractional-constant}
  \synprd{\nt{digit-sequence\tsub{opt}} \tm{.} \nt{digit-sequence}}
  \synprd{\nt{digit-sequence} \tm{.}}
\synsym{exponent-part}
  \synprd{\tm{e} \nt{sign\tsub{opt} digit-sequence}}
  \synprd{\tm{E} \nt{sign\tsub{opt} digit-sequence}}
\synsym[one of]{sign}
  \synprd{\tm{+ -}}
\synsym{digit-sequence}
  \synprd{\nt{digit}}
  \synprd{\nt{digit-sequence digit}}
\synsym{hexadecimal-fractional-constant}
  \synprd{\nt{hexadecimal-digit-sequence\tsub{opt}} \tm{.}
          \nt{hexadecimal-digit-sequence}}
  \synprd{\nt{hexadecimal-digit-sequence\tsub{opt}} \tm{.}}
\synsym{binary-exponent-part}
  \synprd{\tm{p} \nt{sign\tsub{opt} digit-sequence}}
  \synprd{\tm{P} \nt{sign\tsub{opt} digit-sequence}}
\synsym{hexadecimal-digit-sequence}
  \synprd{\nt{hexadecimal-digit}}
  \synprd{\nt{hexadecimal-digit-sequence hexadecimal-digit}}
\synsym[one of]{floating-suffix}
  \synprd{\tm{f l F L}}

\desc
\paragraph{}
浮点常量有一个\textit{有效位部分}，后面可能跟一个\textit{指数部分}和一个指定其类
型的后缀。有效位部分的组成可以包括表示整数部分的数字序列，后跟句点（\tm{.}），后
跟表示小数部分的数字序列。指数部分的组成由一个\tm{e}、\tm{E}、\tm{p}或\tm{P}后跟
一个由可选有符号数字序列组成的指数。整数部分或小数部分必须存在；对于十进制浮点常
量，句点部分或指数部分必须存在。

\semantic
\paragraph{}
有效位部分被解释为（十进制或十六进制）有理数；指数部分中的数字序列被解释为十进制
整数。对十进制浮点常量，指数表示伸缩有效位部分的10的幂次。对十六进制浮点常量，指
数表示伸缩有效位部分的2的幂次。对于十进制浮点常量，以及十六进制浮点常量（当
\tm{FLT\_RADIX}不是2的幂时），结果要么是最近的可表示值，要么是以实现定义的方式选
择紧邻最近的可表示值的较大或较小的可表示值。对于十六进制浮点常量，当
\tm{FLT\_RADIX}为2的幂时，结果正确四舍五入。

\paragraph{}
无后缀浮点常量具有类型\tm{double}。如有后缀\tm{f}或\tm{F}，则\tm{float}类型。如
有后缀\tm{l}或\tm{L}，则具有\tm{long double}类型。

\paragraph{}
浮点常量如同在翻译时转换为内部格式。在执行时，浮点常量的转换不应触发异常条件或浮
点异常。同一源形式\footnote{\tm{1.23, 1.230, 123e-2, 123e-02}和\tm{1.23L}都是不
同源形式，因此不需要转换成相同的内部格式和值。}的所有浮点常量应转换为具有相同值
的相同内部格式。

\recprac
\paragraph{}
如果十六进制常量不能以其计算格式准确表示，则实现应生成诊断消息；然后应继续转换程
序。

\paragraph{}
给定适用于两种转换的匹配输入、相同的结果格式和默认的执行时舍入，浮点常量的翻译时
转换应与库函数（如\tm{strtod}）对字符串的执行时转换相匹配。\footnote{库函数规范
推荐比浮点常量更精确的转换（见7.22.1.3）。}

                                          \sssect{枚举常量}{lang.lex.const.enum}
\syntax
\paragraph{}
\synsym{enumeration-constant}
  \synprd[]{\nt{identifier}}

\semantic
\paragraph{}
声明为枚举常量的标识符具有\tm{int}类型;

\fwdref{6.7.2.2}

                                          \sssect{字符常量}{lang.lex.const.char}
\syntax
\paragraph{}
\synsym{character-constant}
\synprd{\tm{\sq} \nt{c-char-sequence} \tm{\sq}}
\synprd{\tm{L\sq} \nt{c-char-sequence} \tm{\sq}}
\synprd{\tm{u\sq} \nt{c-char-sequence} \tm{\sq}}
\synprd{\tm{U\sq} \nt{c-char-sequence} \tm{\sq}}
\synsym{c-char-sequence}
  \synprd{\nt{c-char}}
  \synprd{\nt{c-char-sequence c-char}}
\synsym{c-char}
  \synprd{源字符集中除单引号\tm{\sq}，反斜杠\tm{\bs}或新行字符外的任何成员}
  \synprd{\nt{escape-sequence}}
\synsym{escape-sequence}
  \synprd{\nt{simple-escape-sequence}}
  \synprd{\nt{octal-escape-sequence}}
  \synprd{\nt{hexadecimal-escape-sequence}}
  \synprd{\nt{universal-character-name}}
\synsym[one of]{simple-escape-sequence}
  \synprd{\tm{\bs\sq\ \bs\dq\ \bs{}?\ \bs\bs}}
  \synprd{\tm{\bs{}a \bs{}b \bs{}f \bs{}n \bs{}r \bs{}t \bs{}v}}
\synsym{octal-escape-sequence}
  \synprd{\tm{\bs} \nt{octal-digit}}
  \synprd{\tm{\bs} \nt{octal-digit octal-digit}}
  \synprd{\tm{\bs} \nt{octal-digit octal-digit octal-digit}}
\synsym{hexadecimal-escape-sequence}
  \synprd{\tm{\bs{}x} \nt{hexadecimal-digit}}
  \synprd[]{\nt{hexadecimal-escape-sequence hexadecimal-digit}}

\desc
\paragraph{}
整型字符常量是一个或多个多字节字符的序列，用单引号括起来，如\tm{\sq{}x\sq}。宽字
符常量除前缀字母\tm{L}、\tm{u}或\tm{U}之外是相同的。除后面详细介绍的一些例外，序
列的元素是源字符集的任何成员；它们以实现定义的方式映射到执行字符集成员。

\paragraph{}
根据以下转义表，单引号\tm{\sq}，双引号\tm{\dq}，问号\tm{?}，反斜杠\tm{\bs}和任意
整数值都可以表示：
\begin{table}[h!]
  \centering
  \begin{tabular}{ll}
    单引号\tm{\sq} & \tm{\bs\sq}                                              \\
    双引号\tm{\dq} & \tm{\bs\dq}                                              \\
    问号\tm{?}     & \tm{\bs ?}                                               \\
    反斜杠\tm{\bs} & \tm{\bs\bs}                                              \\
    八进制字符     & \tm{\bs}\textit{八进制数字}                              \\
    十六进制字符   & \tm{\bs{}x}\textit{十六进制数字}
  \end{tabular}
\end{table}

\paragraph{}
双引号\tm{\dq}和问号\tm{?}可用其自身，也可用转义序列\tm{\bs\dq}和\tm{\bs ?}分别
表示，但单引号\tm{\sq}和反斜杠\tm{\bs}应使用转义序列\tm{\bs\sq}和\tm{\bs\bs}分别
表示。

\paragraph{}
在八进制转义序列中，跟在反斜杠后面的八进制数字被视为整型字符常量的单个字符或宽字
符常量的单个宽字符构造的一部分。这样形成的八进制整数的数值指定所需字符或宽字符的
值。

\paragraph{}
十六进制转义序列中反斜杠后面的十六进制数字和字母\tm{x}被视为整型字符常量的单个字
符或宽字符常量的单个宽字符构造的一部分。这样形成的十六进制整数的数值指定所需字符
或宽字符的值。

\paragraph{}
每个八进制或十六进制转义序列是构成转义序列的最长字符序列。

\paragraph{}
此外，不在基本字符集中的字符可以用通用字符名表示，某些非图形字符可以用转义序列表
示，转义序列由反斜杠\tm{\bs}后跟小写字母\tm{\bs a}、\tm{\bs b}、\tm{\bs f}、
\tm{\bs n}、\tm{\bs r}、\tm{\bs t}和\tm{\bs v}组成。\footnote{这些字符的语义在
\ref{env.env.display}中进行讨论。如果反斜杠后面有任何其他字符，则结果不是标记，
需要进行诊断。见``未来语言方向''（\ref{lang.dir.escape}）。}

\constraint
\paragraph{}
八进制或十六进制转义序列的值应在相应类型的可表示值范围内：
\begin{table}[h!]
  \centering
  \begin{tabular}{l|l}
    前缀   & 对应类型                                                         \\
    \hline
    无     & \tm{unsigned char}                                               \\
    \tm{L} & 对应\tm{wchar\_t}的无符号类型                                    \\
    \tm{u} & \tm{char16\_t}                                                   \\
    \tm{U} & \tm{char32\_t}
  \end{tabular}
\end{table}

\semantic
\paragraph{}
整型字符常量具有\tm{int}类型。包含映射到单字节执行字符的单个字符的整型字符常量的
值是映射字符的表示被解释为整数的数值。包含多个字符（例如\tm{\sq ab\sq}），或包含
不映射到单字节执行字符的字符或转义序列的整型字符常量的值由实现定义。如果整型字符
常量包含单字符或转义序列，则其值是将一个\tm{char}类型对象转换为\tm{int}类型时的
结果，该\tm{char}类型对象的值为所包含的单字符或转义序列。

\paragraph{}
以字母\tm{L}为前缀的宽字符常量具有\tm{wchar\_t}类型，即在\tm{<stddef.h>}头中定义
的整型；以字母\tm{u}或\tm{U}为前缀的宽字符常量具有\tm{char16\_t}或
\tm{char32\_t}类型，分别是在\tm{<uchar.h>}头中定义的无符号整型。包含映射到扩展执
行字符集的单个成员的单个多字节字符的宽字符常量的值是与该多字节字符对应的宽字符，
由\tm{mbtowc}、\tm{mbrtoc16}或\tm{mbrtoc32}函数根据其类型定义，由实现定义了当前
的语言环境。包含多于一个多字节字符的宽字符常量的值，或映射到扩展执行字符集多个成
员的单个多字节字符的值，或包含扩展执行字符集中未表示的多字节字符或转义序列的值由
实现定义。

\paragraph{}
\ex 结构\tm{\sq\bs 0\sq}通常用于表示零字符。

\paragraph{}
\ex 考虑整型使用二补码，\tm{char}类型对象为八位表示的实现。在类型\tm{char}的值范
围与\tm{signed char}相同的实现中，整型字符常量\tm{\sq\bs xFF\sq}的值为$-1$；如果
类型\tm{char}的值范围与\tm{unsigned char}相同，则字符常量\tm{\sq\bs xFF\sq}的值
为$+255$。

\paragraph{}
\ex 即使8位用于\tm{char}类型的对象，构造\tm{\sq\bs x123\sq}也指定只包含一个字符
的整型字符常量，因为十六进制转义序列仅由非十六进制字符终止。要指定一个包含值为
\tm{\sq\bs x12\sq}和\tm{\sq3\sq}的两字符的整型字符常量，可以使用构造\tm{\sq\b
0223\sq}，因为八进制转义序列在三个八进制数字后终止。（此双字符整型字符常量的值由
实现定义。）

\paragraph{}
\ex 即使12位或更多位用于具有\tm{wchar\_t}类型的对象，构造\tm{L\sq\bs 1234\sq}指
定由值\tm{0123}和\tm{\sq 4\sq}组合产生的实现定义值。

\fwdref{7.19，7.22.7.2，7.28}

                                              \ssect{字符串字面值}{lang.lex.str}
\syntax
\paragraph{}
\synsym{string-literal}
  \synprd{\nt{encoding-prefix\tsub{opt}}\tm{\dq}
          \nt{s-char-sequence\tsub{opt}}\tm{\dq}}
\synsym{encoding-prefix}
  \synprd{\tm{u8}}
  \synprd{\tm{u}}
  \synprd{\tm{U}}
  \synprd{\tm{L}}
\synsym{s-char-sequence}
  \synprd{\nt{s-char}}
  \synprd{\nt{s-char-sequence s-char}}
\synsym{s-char}
  \synprd{源字符集中除双引号\tm{\dq}，反斜杠\tm{\bs}或新行字符外的任何成员}
  \synprd[]{\nt{escape-sequence}}

\constraint
\paragraph{}
相邻字符串文本标记序列不应同时包含宽字符串文本和UTF-8字符串文本。

\desc
\paragraph{}
\textit{字符串文本}是用双引号括起来的零个或多个多字节字符的序列，如
\tm{\dq xyz\dq}。除前缀为\tm{u8}，\textit{UTF-8字符串文本}与之相同。除前缀字母
\tm{L}、\tm{u}或\tm{U}，\textit{宽字符串文本}与之相同。

\paragraph{}
同样的考虑也适用于字符串文本序列中的每个元素，就好像它是一个整型字符常量（对于字
符或UTF-8字符串文本）或一个宽字符常量（对于宽字符串文本），除了单引号\tm{\sq}可
以由其自身或转义序列\tm{\bs\sq}来表示，但双引号\tm{\dq}应以转义序列\tm{\bs\dq}表
示。

\semantic
\paragraph{}
在翻译阶段\ref{tpit6}中，由任何相邻字符序列和相同前缀的字符串文本标记指定的多字
节字符序列被连接成单个多字节字符序列。如果任何标记具有编码前缀，则生成的多字节字
符序列将被视为具有相同的前缀；否则，将被视为（character string literal）字符串文
本。是否可以连接不同前缀的宽字符串文本标记，以及如果可以的话，对生成的多字节字符
序列进行的处理，由实现定义。

\paragraph{}
在翻译阶段\ref{tpit7}中，值为零的字节或代码被附加到每个由字符串文本产生的多字节
字符序列中。\footnote{字符串文本不必是字符串（见\ref{lib.intro.term}），因为可以
通过转义序列\tm{\bs 0}将空字符嵌入其中。}  然后使用多字节字符序列初始化静态存储
期和长度刚好足以包含序列的数组。对于字符串文本，数组元素具有\tm{char}类型，并用
多字节字符序列的单个字节初始化。对于UTF-8字符串文本，数组元素具有\tm{char}类型，
并用以UTF-8编码的多字节字符序列的字符初始化。对于以字母\tm{L}为前缀的宽字符串文
本，数组元素的类型为\tm{wchar\_t}，并使用与多字节字符序列相对应的宽字符序列进行
初始化，如\tm{mbstowcs}函数使用实现定义的当前语言环境所定义的那样。对于以字母
\tm{u}或\tm{U}为前缀的宽字符串文本，数组元素分别具有\tm{char16\_t}或
\tm{char32\_t}类型，并使用与多字节字符序列相对应的宽字符序列进行初始化，该序列由
使用实现定义的当前语言环境连续调用\tm{mbroc16}或\tm{mbroc32}函数（视其类型而定）
所定义。包含未在执行字符集中表示的多字节字符或转义序列的字符串文本值由实现定义。

\paragraph{}
在其元素具有适当值的情况下，未指明这些数组是否不同。如果程序试图修改这样的数组，
则行为未定义。

\paragraph{}
\ex 相邻字符串文本对
\begin{lstlisting}
    "\x12" "3"
\end{lstlisting}
生成一个包含两个字符的单字符串文本，值分别为\tm{\sq\bs x12\sq}和\tm{\sq 3\sq}，
因为转义序列在相邻字符串文本串联之前被转换为执行字符集的单个成员。

\paragraph{}
\ex 相邻字符串文本标记的每个序列
\begin{lstlisting}
    "a" "b" L"c"
    "a" L"b" "c"
    L"a" "b" L"c"
    L"a" L"b" L"c"
\end{lstlisting}
都等价于字符串文本
\begin{lstlisting}
    L"abc"
\end{lstlisting}
同样，每个序列
\begin{lstlisting}
    "a" "b" u"c"
    "a" u"b" "c"
    u"a" "b" u"c"
    u"a" u"b" u"c"
\end{lstlisting}
都等价于
\begin{lstlisting}
    u"abc"
\end{lstlisting}

\fwdref{7.19，7.22.8.1，7.28}

                                                    \ssect{标点}{lang.lex.punct}
\syntax
\paragraph{}
\synsym[one of]{punctuator}
  \synprd{\tm{[ ] ( ) \{ \} .\ ->}}
  \synprd{\tm{++ -\dsh\ \& * + - \~\ !}}
  \synprd{\tm{/ \% \tl{}\tl\ \tg{}\tg\ < > <= >= == != \^\ | \&\& ||}}
  \synprd{\tm{?\ :\ ; ...}}
  \synprd{\tm{= *= /= \%= += -= \tl{}\tl{}= \tg{}\tg{}= \&= \^{}= |=}}
  \synprd{\tm{, \# \#\#}}
  \synprd[]{\tm{<:\ :> <\% \%> \%:\ \%:\%:}}

\semantic
\paragraph{}
标点符号是一种具有独立语法和语义的符号。根据上下文，它可以指定要执行的操作（相应
地可能生成值或函数指示符，产生副作用或其组合），这种情况下称其为\textit{运算符}
（在某些上下文中也存在其他形式的运算符）。\textit{操作数}是运算符所操作的实体。

\paragraph{}
在语言的所有方面，以下六个标记\footnote{这些标记有时称作``双字符序列''。}     \\
\synprd[]{\tm{<:\ :> <\% \%> \%:\ \%:\%:}}                                    \\
与以下六个标记                                                                    \\
\synprd[]{\tm{[ ] \{ \} \# \#\#}}                                             \\
除拼写不同外，对应的行为一致。\footnote{因此\tm{[}和\tm{<:}在``字符化''（见
\ref{lang.ppdir.macro.stringize}）时行为不同，但除此外可以自由互换。}

\fwdref{6.5，6.7，6.10，6.8}

                                                 \ssect{头名称}{lang.lex.header}
\syntax
\paragraph{}
\synsym{header-name}
  \synprd{\tm{<} \nt{h-char-sequence} \tm{>}}
  \synprd{\tm{\dq} \nt{q-char-sequence} \tm{\dq}}
\synsym{h-char-sequence}
  \synprd{\nt{h-char}}
  \synprd{\nt{h-char-sequence h-char}}
\synsym{h-char}
  \synprd{源字符集中除新行字符和\tm{>}以外的任何成员}
\synsym{q-char-sequence}
  \synprd{\nt{q-char}}
  \synprd{\nt{q-char-sequence q-char}}
\synsym{q-char}
  \synprd[]{源字符集中除新行字符和\tm{\dq}以外的任何成员}

\semantic
\paragraph{}
两种形式的头名称序列都以实现定义的方式映射到\ref{lang.ppdir.inc}中指定的头名称或
外部源文件名。

\paragraph{}
如果字符\tm{\sq}，\tm{\bs}，\tm{\dq}，\tm{//}或\tm{/*}出现在分隔符\tm{<}和\tm{>}
之间的序列中则行为未定义。相应的，如果字符\tm{\sq}，\tm{\bs}，\tm{//}或\tm{/*}出
现在\tm{\dq}分隔符之间的序列中则行为未定义。\footnote{因此，类似转义序列的字符序
列会导致未定义的行为。} 头名称预处理标记只能在\tm{\#include}预处理指令和
\tm{\#pragma}指令内的实现定义位置中识别。\footnote{有关在\tm{\#pragma}指令中使用
头名称预处理标记的示例见\ref{lang.ppdir.pragmaop}。}

\paragraph{}
\ex* 以下字符序列
\begin{lstlisting}
    0x3<1/a.h>1e2
    #include <1/a.h>
    #define const.member@$
\end{lstlisting}
构成以下的预处理标记（每个预处理标记使用\tm{\{}和\tm{\}}分隔。
\begin{lstlisting}
    {0x3}{<}{1}{/}{a}{.}{h}{>}{1e2}
    {#}{include} {<1/a.h>}
    {#}{define} {const}{.}{member}{@}{$}
\end{lstlisting}

\fwdref{6.10.2}

                                              \ssect{预处理数字}{lang.lex.ppnum}
\syntax
\paragraph{}
\synsym{pp-number}
  \synprd{\nt{digit}}
  \synprd{\tm{.} \nt{digit}}
  \synprd{\nt{pp-number digit}}
  \synprd{\nt{pp-number identifier-nondigit}}
  \synprd{\nt{pp-number} \tm{e} \nt{sign}}
  \synprd{\nt{pp-number} \tm{E} \nt{sign}}
  \synprd{\nt{pp-number} \tm{p} \nt{sign}}
  \synprd{\nt{pp-number} \tm{P} \nt{sign}}
  \synprd[]{\nt{pp-number} \tm{.}}

\desc
\paragraph{}
一个预处理数字以一个数字开头，前面有可选的小数点（\tm{.}），后面可能跟有有效的标
识符字符和字符序列\tm{e+}、\tm{e-}、\tm{E+}、\tm{E-}、\tm{p+}、\tm{p-}、\tm{P+}
、或\tm{P-}。

\paragraph{}
预处理数字标记词法上包括所有浮点和整型常量标记。

\semantic
\paragraph{}
预处理数字没有类型或值；在成功转换（作为翻译阶段\ref{tpit7}的一部分）为浮点常量
标记或整型常量标记后取得这两项。

                                                  \ssect{注释}{lang.lex.comment}
\paragraph{}
除了在字符常量、字符串文本或注释中，字符\tm{/*}引入一个注释。检查此类注释的内容
只是为了识别多字节字符并查找终止注释的字符\tm{*/}。\footnote{因此注释
\tm{/* ... */}不能嵌套。}

\paragraph{}
除了在字符常量、字符串文本或注释中，字符\tm{//}引入一个注释，该注释包含直到下一
个新行字符（但不包括）的所有多字节字符。检查这种注释的内容仅用于识别多字节字符和
查找终止的新行字符。

\paragraph{}
\ex*
\begin{lstlisting}
    "a//b"                    // four-character string literal
    #include "//e"            // undefined behavior
    // */                     // comment, not syntax error
    f = g/**//h;              // equivalent to f = g / h;
    //\
    i();                      // part of a two-line comment
    /\
    / j();                    // part of a two-line comment
    #define glue(x,y) x##y
    glue(/,/) k();            // syntax error, not comment
    /*//*/ l();               // equivalent to l();
    m = n//**/o
      + p;                    // equivalent to m = n + p;
\end{lstlisting}

                                                        \sect{表达式}{lang.expr}
\paragraph{}
\textit{表达式}指运算符和操作数的序列，用于指定值的计算，或指代一个对象或函数，
或生成副作用，或执行以上操作的组合。对运算符操作数的值计算前序于运算符结果的值计
算。

\paragraph{}
如果一个标量对象的副作用相对于同一个标量对象的另一个副作用或使用该标量对象的值进
行的值计算无序，则行为未定义。如果一个表达式的子表达式有多个允许的顺序，那么如果
在任何顺序中出现这样一个无序的副作用，那么该行为未定义。\footnote{本段说明未定义
语句表达式如                                                                  \\
\mbox{\hspace{4em}\tm{i = ++i + 1;}}                                          \\
\mbox{\hspace{4em}\tm{a[i++] = i;}}                                           \\
而允许                                                                        \\
\mbox{\hspace{4em}\tm{i = i + 1;}}                                            \\
\mbox{\hspace{4em}\tm{a[i] = i;}}}

\paragraph{}
运算符和操作数的分组由语法指定。\footnote{语法指定表达式计算中运算符的优先级，优
先级与本章中的主要子章节顺序相同，高优先级优先。因此，例如，允许作为二元\tm{+}运
算符（\ref{lang.expr.add}）的操作数的表达式是\ref{lang.expr.prim}到
\ref{lang.expr.add}中定义的表达式。例外情况是转换表达式（\ref{lang.expr.cast}）
作为一元\tm{+}运算符（\ref{lang.expr.unary}）的操作数，以及包含在以下任意一对运
算符之间的操作数：分组括号\tm{()}（\ref{lang.expr.prim}）、下标方括号\tm{[]}
（\ref{lang.expr.post.sub}）、函数调用括号\tm{()}（\ref{lang.expr.post.call}）和
条件运算符\tm{?:}（\ref{lang.expr.cond}）。\vspace{0.2cm}

\ \ 每个主要子章节内的运算符具有相同的优先级。每个子章节中讨论的表达式的左关联性
或右关联性由语法指定。} 除非下文另有规定，否则子表达式的副作用和值计算无序。
\footnote{在程序执行期间多次计算的表达式中，不要求在不同的计算中其子表达式的无序
和不确定性有序计算一致地执行。}

\paragraph{}
某些运算符（一元运算符\tm{\~}和二元运算符\tm{\tl{}\tl}，\tm{\tg{}\tg}，\tm{\&}，
\tm{\^}和\tm{|}统称为\textit{位运算符}）需要具有整型操作数。这些运算符产生的值依
赖于整型的内部表示，且对有符号类型具有实现定义和未定义的方面。

\paragraph{}
如果在表达式的计算过程中出现\textit{异常情况}（即，如果结果没有数学定义或不在其
类型的可表示值范围内），则行为未定义。

\paragraph{}
用于访问对象存储值的\textit{有效类型}是对象的声明类型（如果有）。\footnote{分配
对象无类型。} 如果通过非字符类型的左值将值存储到没有声明类型的对象中，则左值类型
将成为该次访问和后续的不修改存储值的访问时对象的有效类型。如果使用\tm{memcpy}
或\tm{memmove}将某个值复制到没有声明类型的对象中，或作为字符类型的数组进行复制，
则对于该访问和不修改该值的后续访问，被修改对象的有效类型是从中复制该值的对象的有
效类型（如果它有）。对于没有声明类型的对象的所有其他访问，对象的有效类型即用于访
问的左值的类型。

\paragraph{}
对象的存储值只能由具有以下类型之一的左值表达式访问：\footnote{此列表的目的是指定
对象可能有别名，也可能没有别名的情况。}
\begin{itemize}
  \item{对象有效类型的兼容类型，}
  \item{对象有效类型的兼容类型的限定版本，}
  \item{对象有效类型对应的有符号或无符号类型，}
  \item{对象有效类型限定版本对应的有符号或无符号类型，}
  \item{聚合或联合类型，在其成员中包含上述类型之一（递归地包括子聚合或包含的联合
    的成员），或}
  \item{字符类型。}
\end{itemize}

\paragraph{}
浮点表达式可能被\textit{压缩}，也就是说，像单个操作一样对其进行计算，从而省略源
代码和表达式计算方法所隐含的舍入错误。\footnote{压缩表达式的中间操作的计算如同范
围和精度都是无限的，而最终操作则舍入到由表达式计算方法所确定的格式。压缩表达式还
可能忽略引发的浮点异常。} \tm{<math.h>}中的\tm{FP\_CONTRACT} pragma提供了一种禁
止压缩表达式的方法。否则，表达式是否压缩以及如何压缩由实现定义。\footnote{此许可
专门用于允许实现利用结合多个C运算符的快速机器指令。由于压缩可能会破坏可预测性，
甚至会降低包含表达式的准确性，因此需要对其使用进行明确定义并清楚地记录。}

\fwdref{7.12.2，7.24.2}

                                                \ssect{主表达式}{lang.expr.prim}
\syntax
\paragraph{}
\synsym{primary-expression}
  \synprd{\nt{identifier}}
  \synprd{\nt{constant}}
  \synprd{\nt{string-literal}}
  \synprd{\tm{(} \nt{expression} \tm{)}}
  \synprd[]{\nt{generic-selection}}

\semantic
\paragraph{}
如果标识符已声明为指定对象（在这种情况下它是左值）或函数（在这种情况下它是函数指
示符）则该标识符是主表达式。\footnote{因此，未声明的标识符违反语法。}

\paragraph{}
常量是主表达式。其类型取决于其形式和值，如\ref{lang.lex.const}所述。

\paragraph{}
字符串文本是主表达式。它是一个左值，类型如\ref{lang.lex.str}所述。

\paragraph{}
带圆括号的表达式是主表达式。其类型和值与未加括号的表达式类型和值相同。如果未加括
号的表达式分别是左值、函数指示符或\tm{void}表达式，则它是左值、函数指示符或
\tm{void}表达式。

\paragraph{}
泛型选择是主表达式。其类型和值取决于所选的泛型关联，如下节所述。

\fwdref{6.7}

                                       \sssect{泛型选择}{lang.expr.prim.generic}
\syntax
\paragraph{}
\synsym{generic-selection}
  \synprd{\tm{\_Generic (} \nt{assignment-expression} \tm{,}
    \nt{generic-assoc-list} \tm{)}}
\synsym{generic-assoc-list}
  \synprd{\nt{generic-association}}
  \synprd{\nt{generic-assoc-list} \tm{,} \nt{generic-association}}
\synsym{generic-association}
  \synprd{\nt{type-name} \tm{:} \nt{assignment-expression}}
  \synprd[]{\tm{default} \tm{:} \nt{assignment-expression}}

\constraint
\paragraph{}
一个泛型选择不应该有超过一个的\tm{default}泛型关联。泛型关联中的类型名应指定一个
非变量修改类型的完整对象类型。同一个泛型选择中两个泛型关联不得指定兼容类型。泛型
选择的控制表达式的类型应至多与其泛型关联列表中所列的一种类型兼容。如果泛型选择没
有\tm{default}泛型关联，则其控制表达式的类型应该恰好与泛型关联列表中所列的类型之
一兼容。

\semantic
\paragraph{}
不计算泛型选择的控制表达式。如果泛型选择有一个类型名与控制表达式的类型兼容的泛型
关联，则泛型选择的结果表达式就是该泛型关联中的表达式。否则，泛型选择的结果表达式
是\tm{default}泛型关联中的表达式。不计算泛型选择中的任何其他泛型关联的表达式。

\paragraph{}
泛型选择的类型和值与其结果表达式的类型和值相同。如果结果表达式分别是左值、函数指
示符或\tm{void}表达式，则该泛型选择是一个左值、函数指示符或\tm{void}表达式。

\paragraph{}
\ex* 泛型宏\tm{cbrt}可能按如下实现：
\begin{lstlisting}
    #define cbrt(X) _Generic((X)),                \
                            long double: cbrtl, \
                            default: cbrt,        \
                            float: cbrtf          \
                            )(X)
\end{lstlisting}

                                              \ssect{后缀运算符}{lang.expr.post}
\syntax
\paragraph{}
\synsym{postfix-expression}
  \synprd{\nt{primary-expression}}
  \synprd{\nt{postfix-expression} \tm{[} \nt{expression} \tm{]}}
  \synprd{\nt{postfix-expression} \tm{(} \nt{argument-expression-list\tsub{opt}}
    \tm{)}}
  \synprd{\nt{postfix-expression} \tm{.} \nt{identifier}}
  \synprd{\nt{postfix-expression} \tm{->} \nt{identifier}}
  \synprd{\nt{postfix-expression} \tm{++}}
  \synprd{\nt{postfix-expression} \tm{-\dsh}}
  \synprd{\tm{(} \nt{type-name} \tm{) \{} \nt{initializer-list} \tm{\}}}
  \synprd{\tm{(} \nt{type-name} \tm{) \{} \nt{initializer-list} \tm{, \}}}
\synsym{argument-expression-list}
  \synprd{\nt{argument-expression}}
  \synprd[]{\nt{argument-expression-list} \tm{,} \nt{argument-expression}}

                                           \sssect{数组下标}{lang.expr.post.sub}
\constraint
\paragraph{}
其中一个表达式的类型应为``指向完整对象类型\nt{type}的指针''，另一个表达式的类型
应为整型，结果类型为``\nt{type}''。

\semantic
\paragraph{}
后缀表达式后跟方括号\tm{[]}中的表达式指定数组对象元素的下标。下标运算符\tm{[]}
的定义使\tm{E1[E2]}与\tm{(*((E1)+(E2)))}等价。由于应用于二元\tm{+}运算符的转换规
则，如果\tm{E1}是数组对象（等价于数组对象的初始元素的指针），\tm{E2}是整数，
\tm{E1[E2]}指定\tm{E1}的第\tm{E2}个元素（从零开始）。

\paragraph{}
连续的下标运算符指定多维数组对象的元素。如果\tm{E}是大小为$i\times j\times\cdots
\times k$的$n$维数组（$n\ge 2$），那么将\tm{E}（用作左值以外的值）转换为指向大小
为$j\times\cdots\times k$的$(n-1)$维数组的指针。如果一元\tm{*}运算符显式地应用于
此指针，或由于下标隐式地应用于此数组，则结果引用的是$(n-1)$维数组，如果将其用作
除左值外，则该$(n-1)$数组本身会转换为指针。由此可知数组按行主顺序存储（最后一个
下标变化最快）。

\paragraph{}
\ex 考虑由以下声明定义的数组对象
\begin{lstlisting}
    int x[3][5];
\end{lstlisting}
这里\tm{x}是一个$3\times 5$的\tm{int}数组；准确地说，\tm{x}是由三个元素对象组成
的数组，每个元素对象都是一个由五个\tm{int}组成的数组。在表达式\tm{x[i]}中，相当
于\tm{(*((x)+(i)))}，\tm{x}首先被转换为指向初始$5$个\tm{int}数组的指针。然后根据
\tm{x}的类型来调整\tm{i}，概念上需要将\tm{i}乘以指针指向的对象的大小，即一个由五
个\tm{int}对象组成的数组。将结果相加，并应用间接取值生成一个五个\tm{int}的数组。
当在表达式\tm{x[i][j]}中使用时，该数组转换为指向第一个\tm{int}的指针，因此
\tm{x[i][j]}生成一个\tm{int}。

\fwdref{6.5.6，6.5.3.2，6.7.6.2}

                                          \sssect{函数调用}{lang.expr.post.call}
\constraint
\paragraph{}
表示被调用函数\footnote{大部分是转换作为函数指示符的标识符的结果。}的表达式的类
型应该是指向返回\tm{void}或除数组类型以外的完整对象类型的函数指针。

\paragraph{}
如果表示被调用函数的表达式类型包含原型，则实参数量应与形参数量一致。每个实参所具
有的类型应使其值可以赋给具有相应形参类型的非限定版本的对象。

\semantic
\paragraph{}
后缀表达式后跟括号\tm{()}，其中包含可能为空的逗号分隔的表达式列表，是一个函数调
用。后缀表达式表示被调用的函数。表达式列表指定函数实参。

\paragraph{}
实参可以是任何完整对象类型的表达式。在准备函数调用时，将计算实参值，并将实参的值
赋给对应的形参。\footnote{函数可以更改其形参的值，但这些更改不会影响实参的值。另
一方面，可以传递指向对象的指针，并且函数可以更改指针所指对象的值。声明为具有数组
或函数类型的参数被调整为具有如\ref{lang.extn.fct}所述的指针类型。}

\paragraph{}
如果表示被调用函数的表达式具有指向返回对象类型的函数指针类型，则该函数调用表达式
的类型与该对象类型相同，并且具有\ref{lang.stmt.jmp.ret}中指定的值。否则，函数调
用的类型为\tm{void}。

\paragraph{}
如果表示被调用函数的表达式类型不包含原型，则对每个参数进行整型提升，并将具有
\tm{float}类型的参数提升为\tm{double}。这被称为\textit{缺省参数提升}。如果实参个
数不等于形参个数，则行为未定义。如果函数使用含原型的类型定义，且或者原型以省略号
\tm{(, \ldots)}结尾，或者提升后的实参类型与形参类型不兼容，则行为未定义。如果函
数使用不含原型的类型定义，且提升后的实参类型与提升后的形参类型不兼容，则行为未定
义，以下情况除外：
\begin{itemize}
  \item{其中一个提升后类型为有符号整型，另一个提升后类型为对应的无符号整型，且值
    均可用两个类型表示；}
  \item{两个类型均为指向字符类型或\tm{void}类型的限定或未限定版本的指针。}
\end{itemize}

\paragraph{}
如果表示被调用函数的表达式类型包含原型，则如同赋值一样，将实参隐式转换为相应形参
的类型，形参类型取其声明类型的非限定版本。函数原型声明子中的省略号使得参数类型转
换在最后一个声明的参数后停止。对随后的参数执行缺省参数提升。

\paragraph{}
没有其他转换隐式地进行；特别是，在不含函数原型声明子的函数定义中，实参数量和类型
不与形参的数量和类型进行比较。

\paragraph{}
如果函数定义的类型与表示被调用函数的表达式所指向的类型（表达式的类型）不兼容，则
行为未定义。

\paragraph{}
在函数指示符和实参的计算之后和实际调用之前有一个序列点。调用函数（包括其他函数调
用）时的每个计算，如果没有特别说明为前序或后序于被调用函数体执行的，则相对被调用
函数的执行是不确定性有序的。\footnote{即函数执行不会彼此``交错''。}

\paragraph{}
允许通过任何其他函数链直接或间接进行递归函数调用。

\paragraph{}
\ex* 函数调用
\begin{lstlisting}
    (*pf[f1()]) (f2(), f3() + f4())
\end{lstlisting}
函数\tm{f1}，\tm{f2}，\tm{f3}和\tm{f4}可能以任何顺序调用。所有副作用必须在由
\tm{pf[f1()]}所指向的函数调用之前完成。

\fwdref{6.7.6.3，6.9.1，6.8.6.4，6.5.16.1}

                                     \sssect{结构与联合成员}{lang.expr.post.mem}
\constraint
\paragraph{}
运算符\tm{.}的第一操作数应具有原子、限定或未限定结构或联合类型，第二操作数应指定
该类型的成员。

\paragraph{}
运算符\tm{->}的第一操作数应具有``指向原子、限定或未限定结构的指针''或``指向原子
、限定或未限定联合的指针''类型，第二操作数应指定类型所指向的成员。

\semantic
\paragraph{}
后缀表达式后跟\tm{.}运算符和标识符指定结构或联合对象成员。其值是所命名成员的值，
\footnote{如果用于读取联合对象内容的成员与上一次用来向对象存储值的成员不同，则该
值的对象表示的适当部分将重新解释为\ref{lang.concept.repr}中所述的新类型中的对象
表示（有时称为``类型双关''）。这可能是一个陷阱表示。} 如果第一个表达式是左值，则
该值是左值。如果第一个表达式具有限定类型，则结果具有指定成员类型的如此限定的版本。

\paragraph{}
后缀表达式后跟\tm{->}运算符和标识符指定结构或联合对象的成员。其值是第一个表达式
所指对象的命名成员的值，且是左值。\footnote{如果\tm{\&E}是有效的指针表达式（其中
\tm{\&}是``取地址''运算符，该运算符生成指向其操作数的指针），则表达式
\tm{(\&E)->MOS}与\tm{E.MOS}相同。} 如果第一个表达式是指向限定类型的指针，则结果
具有指定成员类型的如此限定的版本。

\paragraph{}
访问原子结构或联合对象的成员会导致未定义行为。\footnote{例如，如果对一个线程中的
整个结构或联合的访问与对另一个线程中的成员的访问发生冲突，则会发生数据竞争，其中
至少有一个访问是修改。可以使用赋给原子对象或从原子对象所赋的非原子对象安全地访问
成员。}

\paragraph{}
一个特殊的保证简化联合的使用：如果联合包含多个共享公共初始序列的结构（见下文），
并且如果联合对象当前包含这些结构中的一个，则允许在联合的完整类型声明可见的任何地
方访问其中任何一个结构的公共初始部分。如果一个或多个初始成员序列的对应成员具有兼
容类型（对于位字段，宽度相同），则两个结构共享一个\textit{公共初始序列}。

\paragraph{}
\ex 如果\tm{f}是返回结构或联合的函数，而\tm{x}是该结构或联合的成员，则\tm{f{}.x}
是有效的后缀表达式，但不是左值。

\paragraph{}
\ex 以下代码中
\begin{lstlisting}
    struct s { int i; const int ci; };
    struct s s;
    const struct s cs;
    volatile struct s vs;
\end{lstlisting}
各个成员的类型为：
\begin{lstlisting}
    s.i     int
    s.ci    const int
    cs.i    const int
    cs.ci   const int
    vs.i    volatile int
    vs.ci   volatile const int
\end{lstlisting}

\paragraph{}
\ex 以下为合法片断：
\begin{lstlisting}
    union {
      struct {
        int alltypes;
      } n;
      struct {
        int type;
        int intnode;
      } ni;
      struct {
        int type;
        double doublenode;
      } nf;
    } u;
    u.nf.type = 1;
    u.nf.doublenode = 3.14;
    /* ... */
    if (u.n.alltypes == 1)
      if (sin(u.nf.doublenode) == 0.0)
        /* ... */
\end{lstlisting}
以下片断不合法（因为在函数\tm{f}内，联合类型不可见）：
\begin{lstlisting}
    struct t1 { int m; };
    struct t2 { int m; };
    int f(struct t1 *p1, struct t2 *p2)
    {
      if (p1->m < 0)
        p2->m = -p2->m;
      return p1->m;
    }
    int g()
    {
      union {
        struct t1 s1;
        struct t2 s2;
      } u;
      /* ... */
      return f(&u.s1, &u.s2);
    }
\end{lstlisting}

\fwdref{6.5.3.2，6.7.2.1}

                                    \sssect{后缀自增与自减}{lang.expr.post.incr}
\constraint
\paragraph{}
后缀自增或自减运算符的操作数应具有原子、限定或未限定的实类型或指针类型，且应该为
可修改左值。

\semantic
\paragraph{}
后缀\tm{++}运算符的结果为操作数的值。作为副作用，将操作数对象的值递增（即，将适
当类型的值\tm{1}加到该对象中）。有关约束、类型和转换以及操作对指针的影响的信息见
加法运算符和复合赋值的讨论。结果的值计算前序于更新操作数存储值的副作用。对于不确
定有序的函数调用，后缀\tm{++}的操作是单个计算。原子类型对象的后缀\tm{++}是一个读
-修改-写操作，具有\tm{memory\_order\_seq\_cst}语义。\footnote{如果可以形成指向原
子对象的指针，并且\tm{E}为整型，则\tm{E++}相当于以下代码序列，其中\tm{T}是\tm{E}
的类型：                                                                      \\
  \newcommand{\mbx}[2][4em]{\mbox{\hspace{#1}\tm{#2}}}
  \mbx{T *addr = \&E;}                                                        \\
  \mbx{T old = *addr;}                                                        \\
  \mbx{T new;}                                                                \\
  \mbx{do \{;}                                                                \\
  \mbx[6em]{new = old + 1;}                                                   \\
  \mbx{\} while (!atomic\_compare\_exchange\_strong(addr, \&old, new));}      \\
\tm{old}为操作结果。                                                          \\
如果\tm{E}为浮点类型则必须进行特别处理；见\ref{lang.expr.assign.cmpd}。}

\paragraph{}
后缀\tm{-\dsh}运算符类似于后缀\tm{++}运算符，只是操作数的值是递减的（即从
中减去相应类型的值$1$）。

\fwdref{6.5.6，6.5.12.2}

                                        \sssect{复合字面值}{lang.expr.post.cmpd}
\constraint
\paragraph{}
类型名应指定完整的对象类型或未知大小的数组，但不能指定变长数组类型。

\paragraph{}
\ref{lang.dcl.init}中初始化列表的所有约束也适用于复合字面值。

\semantic
\paragraph{}
由带圆括号包含类型名，后跟括号包含的初始化列表组成的后缀表达式是\textit{复合字面
值}。它提供一个未命名对象，其值由初始化列表给定。\footnote{注意这与强制转换表达
式不同。例如，强制转换仅指定到标量类型或\tm{void}的转换，并且强制转换表达式的结
果不是左值。}

\paragraph{}
如果类型名指定了一个未知大小的数组，则该数组的大小由初始化列表确定，如
\ref{lang.dcl.init}中所指定，并且复合字面值的类型是该完整的数组类型。否则（当类
型名指定对象类型时），复合字面值的类型是由类型名所指定的类型。在这两种情况下，结
果都是左值。

\paragraph{}
复合字面值的值为初始化列表所初始化的未命名对象的值。如果复合字面值出现在函数体外
部，则对象具有静态存储期；否则，它具有与包含块相关联的自动存储期。

\paragraph{}
\ref{lang.dcl.init}中初始化列表的所有语义规则也适用于复合字面值。\footnote{比如
未显式初始化的子对象初始化为零。}

\paragraph{}
字符串文本和具有常限定类型的复合字面值不要求指代不同的对象。\footnote{这允许实现
共享具有相同或重叠表示形式的字符串文本和常复合字面值的存储。}

\paragraph{}
\ex 文件作用域定义
\begin{lstlisting}
    int *p = (int []){2, 4};
\end{lstlisting}
初始化\tm{p}指向两个\tm{int}数组的第一个元素，第一个元素的值为$2$，第二个元素的
值为$4$。此复合字面值中的表达式必须是常量。未命名对象具有静态存储期。

\paragraph{}
\ex 相比之下，以下片断中
\begin{lstlisting}
    void f(void)
    {
      int *p;
      /*...*/
      p = (int [2]){*p};
      /*...*/
    }
\end{lstlisting}
\tm{p}被赋以两个\tm{int}的数组的第一个元素地址，第一个元素的值为\tm{p}之前指向的
值，第二个元素的值为零。此复合字面值中的表达式不必是常量。未命名对象具有自动存储
期。

\paragraph{}
\ex 指定初始化可以与复合字面值组合。使用复合字面值创建的结构对象可以传递给函数，
而不依赖于成员顺序：
\begin{lstlisting}
    drawline((struct point){.x=1, .y=1},
             (struct point){.x=3, .y=4});
\end{lstlisting}
或者如果\tm{drawline}需要指向\tm{struct point}的指针：
\begin{lstlisting}
    drawline(&(struct point){.x=1, .y=1},
             &(struct point){.x=3, .y=4});
\end{lstlisting}

\paragraph{}
\ex 只读复合字面值可通过以下结构指定：
\begin{lstlisting}
    (const float []){1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6}
\end{lstlisting}

\paragraph{}
\ex 以下三个表达式具有不同语义：
\begin{lstlisting}
    "/tmp/fileXXXXXX"
    (char []){"/tmp/fileXXXXXX"}
    (const char []){"/tmp/fileXXXXXX"}
\end{lstlisting}
第一个始终具有静态存储期，并且具有\tm{char}类型数组，但不要求为可修改；后两个在
函数体中时具有自动存储期，两个中的第一个可修改。

\paragraph{}
\ex 与字符串文本一样，常限定的复合字面值可以放置在只读内存中，甚至可以共享。如，
\begin{lstlisting}
    (const char []){"abc"} == "abc"
\end{lstlisting}
如果字面值共享存储则结果可能为$1$。

\paragraph{}
\ex 由于复合字面值未命名，单个复合字面值不能指定循环链接的对象。例如，无法编写可
用作函数参数的自引用复合字面值来替代以下的命名对象\tm{endless\_zeros}：
\begin{lstlisting}
    struct int_list { int car; struct int_list *cdr; };
    struct int_list endless_zeros = {0, &endless_zeros};
    eval(endless_zeros);
\end{lstlisting}

\paragraph{}
\ex 每一个复合字面值在给定作用域中仅创建一个对象：
\begin{lstlisting}
    struct s { int i; };
    int f (void)
    {
      struct s *p = 0, *q;
      int j = 0;
    again:
      q = p, p = &((struct s){ j++ });
      if (j < 2) goto again;
      return p == q && q->i == 1;
    }
\end{lstlisting}
函数\tm{f()}总是返回$1$。

\paragraph{}
注意如果使用迭代语句而不是显式\tm{goto}和标号语句，则未命名对象的生命期将仅为循
环体，并在下次进入迭代时\tm{p}将有一个不确定的值，这将导致未定义的行为。

\fwdref{6.7.7，6.7.9}

                                             \ssect{一元运算符}{lang.expr.unary}
\syntax
\paragraph{}
\synsym{unary-expression}
  \synprd{\nt{postfix-expression}}
  \synprd{\tm{++} \nt{unary-expression}}
  \synprd{\tm{-\dsh{}} \nt{unary-expression}}
  \synprd{\nt{unary-operator cast-expression}}
  \synprd{\tm{sizeof} \nt{unary-expression}}
  \synprd{\tm{sizeof (} \nt{type-name} \tm{)}}
  \synprd{\tm{\_Alignof (} \nt{type-name} \tm{)}}
\synsym[one of]{unary-operator}
  \synprd[]{\tm{\&\ \ *\ \ +\ \ -\ \ \~\ \ !}}

                                   \sssect{前缀自增与自减}{lang.expr.unary.incr}
\constraint
\paragraph{}
前缀自增或自减运算符的操作数应具有原子、限定或未限定的实类型或指针类型，并且应该
是可修改左值。

\semantic
\paragraph{}
前缀\tm{++}运算符操作数的值被递增。结果是递增后操作数的新值。表达式\tm{++E}等价
于\tm{(E+=1)}。有关约束、类型、副作用和转换以及操作对指针的影响的信息，请参阅加
法运算符和复合赋值的讨论。

\paragraph{}
前缀\tm{-\dsh}运算符类似于\tm{++}运算符，只是操作数的值被递减。

\fwdref{6.5.6，6.5.16.2}

                                   \sssect{取址与间接取值}{lang.expr.unary.addr}
\constraint
\paragraph{}
一元运算符\tm{\&}的操作数应该为函数、\tm{[]}或一元\tm{*}运算符的结果，或指代非位
字段且未用\tm{register}存储类说明符所声明对象的左值。

\paragraph{}
一元\tm{*}运算符的操作数应具有指针类型。

\semantic
\paragraph{}
一元运算符\tm{\&}取其操作数的地址。如果操作数类型为``\nt{type}''，则结果的类型为
``指向\nt{type}的指针''。如果操作数是一元\tm{*}运算符的结果，则既不计算该运算符
也不计算\tm{\&}运算符，其结果就像两者都被省略一样，除了对运算符的约束仍然适用，
并且结果不是左值。同样，如果操作数是\tm{[]}运算符的结果，则不计算\tm{\&}运算符和
\tm{[]}所隐含的一元\tm{*}运算符，结果就像删除了\tm{\&}运算符而将\tm{[]}运算符更
改为\tm{+}运算符一样。否则，结果是指向由其操作数指定的对象或函数的指针。

\paragraph{}
一元\tm{*}运算符表示间接寻址。如果操作数指向函数，则结果为函数指示符；如果指向对
象，则结果为指定对象的左值。如果操作数的类型为``指向\nt{type}的指针''，则结果的
类型为``\nt{type}''。如果给指针赋了无效值，则一元\tm{*}运算符的行为未定义。
\footnote{因此，\tm{\&*E}等价于\tm{E}（即使\tm{E}是零指针），且\tm{\&(E1[E2])}等
价于\tm{((E1)+(E2))}。如\tm{E}是函数指示符或左值，作为一元\tm{\&}运算符的有效操
作数，则\tm{*\&E}是一个等于\tm{E}的函数指示符或左值总是正确。如果\tm{*P}是一个左
值，\tm{T}是对象指针类型的名字，\tm{*(T)P}是一个左值，其类型与\tm{T}所指向的类型
兼容。                                                                        \\
                                                                              \\
一元\tm{*}运算符解指针引用时的无效值包括零指针、所指对象类型未适当对齐的地址，以
及对象生命期结束后的地址。}

\fwdref{6.7.1，6.7.2.1}

                                  \sssect{一元算术运算符}{lang.expr.unary.arith}
\constraint
\paragraph{}
一元\tm{+}或\tm{-}运算符的操作数应该具有算术类型；\tm{\~}运算符的操作数应该具有
整型；\tm{!}运算符操作数应该具有标量类型。

\semantic
\paragraph{}
一元\tm{+}运算符的结果是其（提升后）操作数的值。对操作数进行整型提升，结果具有提
升后的类型。

\paragraph{}
一元\tm{-}运算符的结果是其（提升后）操作数的负值。对操作数进行整型提升，结果具有
提升后的类型。

\paragraph{}
运算符\tm{\~}的结果是其（提升后）操作数的按位补（当且仅当转换后的操作数中的相应
位未置位的情况下才会置该对应位）。对操作数进行整型提升，结果具有提升后的类型。如
果提升后类型是无符号类型，则表达式\tm{\~{}E}等于该类型可表示的最大值减\tm{E}。

\paragraph{}
如果逻辑取反运算符\tm{!}的操作数的值不等于0，则结果为0；如果操作数的值等于0，则
结果为1。结果的类型为\tm{int}。表达式\tm{!E}等价于\tm{(0==E)}。

                              \sssect{sizeof和\_Alignof}{lang.expr.unary.sizeof}
\constraint
\paragraph{}
\tm{sizeof}运算符不应该用于具有函数类型或不完整类型的表达式、此类类型的带圆括号
的名字或指代位字段成员的表达式。\tm{\_Alignof}运算符不应该用于函数类型或不完整类
型。

\semantic
\paragraph{}
\tm{sizeof}运算符生成其操作数的大小（以字节为单位），操作数可以是表达式或带括号
的类型名。大小由操作数的类型决定。结果是一个整数。如果操作数的类型是变长数组类型
，则计算该操作数；否则不计算操作数且结果为整型常量。

\paragraph{}
\tm{\_Alignof}运算符生成其操作数类型的对齐要求。不计算操作数，结果为整型常量。当
用于数组类型时，结果是元素类型的对齐要求。

\paragraph{}
当\tm{sizeof}应用于类型为\tm{char}、\tm{unsigned char}或\tm{signed char}（或其限
定版本）的操作数时，结果为1。当用于具有数组类型的操作数时，结果是数组中的字节总
数。\footnote{当用于声明为数组或函数类型的参数时，\tm{sizeof}运算符生成调整后的
（指针）类型的大小（见\ref{lang.extn.fct}）。} 当用于具有结构或联合类型的操作数
时，结果是此类对象中的字节总数，包括内部填充和尾部填充。

\paragraph{}
这两个运算符的结果值都是实现定义的，其类型（无符号整型）是\tm{size\_t}，在
\tm{<stddef.h>}（和其他头）中定义。

\paragraph{}
\ex \tm{sizeof}运算符的主要用途是与存储分配器和I/O系统等例程通信。存储分配函数可
以接受待分配对象的大小（以字节为单位），并返回指向\tm{void}的指针。例如：
\begin{lstlisting}
    extern void *alloc(size_t);
    double *dp = alloc(sizeof *dp);
\end{lstlisting}
\tm{alloc}函数的实现应确保其返回值适当对齐，以便转换为指向\tm{double}的指针。

\paragraph{}
\ex \tm{sizeof}运算符的另一个用途是计算数组中的元素个数：
\begin{lstlisting}
    sizeof array / sizeof array[0]
\end{lstlisting}

\paragraph{}
\ex 本例中，计算变长数组的大小并从函数返回：
\begin{lstlisting}
    #include <stddef.h>
    size_t fsize3(int n)
    {
      char b[n+3];
      return sizeof b;
    }
    // variable length array
    // execution time sizeof
    int main()
    {
      size_t size;
      size = fsize3(10); // fsize3 returns 13
      return 0;
    }
\end{lstlisting}

\fwdref{7.19，6.7，6.7.2.1，6.7.7，6.7.6.2}

                                              \ssect{转换运算符}{lang.expr.cast}
\syntax
\paragraph{}
\synsym{cast-expression}
  \synprd{\nt{unary-expression}}
  \synprd[]{\tm{(} \nt{type-name} \tm{)} \nt{cast-expression}}

\constraint
\paragraph{}
除非类型名指定了\tm{void}类型，否则类型名应指定原子、限定或非限定的标量类型，且
操作数应具有标量类型。

\paragraph{}
涉及指针的转换（\ref{lang.expr.assign.simple}中的约束所允许的除外）应通过显式强
制转换进行。

\paragraph{}
指针类型不应转换为任何浮点类型。浮点类型不应转换为任何指针类型。

\semantic
\paragraph{}
在表达式前面加上带括号的类型名，可以将表达式的值转换为所指定的类型。这种结构称做
\textit{强制转换}（\textit{cast}）。\footnote{强制转换不产生左值。因此，对限定类
型的强制转换与对该类型的非限定版本的强制转换具有相同的效果。} 不产生转换
（specifies no conversion）的强制转换对表达式的类型或值没有影响。

\paragraph{}
如果表达式的值使用比强制转换指定的类型（\ref{lang.conv.arith.usualarith}）所要求
的范围或精度更大的范围或精度来表示，则即使表达式的类型与指定的类型相同，
该强制转换也将产生转换，并删除任何额外的范围和精度。

\fwdref{6.5.9，6.7.6.3，6.5.16.1，6.7.7}

                                               \ssect{乘法运算符}{lang.expr.mul}
\syntax
\paragraph{}
\synsym{multiplicative-expression}
  \synprd{\nt{cast-expression}}
  \synprd{\nt{multiplicative-expression} \tm{*} \nt{cast-expression}}
  \synprd{\nt{multiplicative-expression} \tm{/} \nt{cast-expression}}
  \synprd[]{\nt{multiplicative-expression} \tm{\%} \nt{cast-expression}}

\constraint
\paragraph{}
每个操作数应具有算术类型。\tm{\%}运算符的操作数应为整型。

\semantic
\paragraph{}
常规算术转换作用于操作数。

\paragraph{}
二元\tm{*}运算符的结果是操作数的乘积。

\paragraph{}
运算符\tm{/}的结果是第一个操作数除以第二个操作数所得的商；运算符tm{\%}的结果为余
数。在这两个操作中，如果第二个操作数的值为零，则行为未定义。

\paragraph{}
当整数相除时，\tm{/}运算符的结果是去掉任何小数部分的代数商。\footnote{通常被称为
``向零截断''。} 如果商\tm{a/b}是可表示的，则表达式\tm{(a/b)*b + a\%b}应等于
\tm{a}；否则，\tm{a/b}和\tm{a\%b}的行为均未定义。

                                               \ssect{加法运算符}{lang.expr.add}
\syntax
\paragraph{}
\synsym{additive-expression}
  \synprd{\nt{multiplicative-expression}}
  \synprd{\nt{additive-expression} \tm{+} \nt{multiplicative-expression}}
  \synprd[]{\nt{additive-expression} \tm{-} \nt{multiplicative-expression}}

\constraint
\paragraph{}
对于加法，两个操作数都应具有算术类型，或者一个操作数应为指向完整对象类型的指针，
另一个操作数为整型。（递增等价于加1。）

\paragraph{}
对于减法，以下之一应该成立：
\begin{itemize}
  \item{两个操作数均具有算术类型；}
  \item{两个操作数均为指向兼容的完整对象类型的限定或未限定版本的指针；或}
  \item{左操作数为指向完整对象类型的指针，右操作数为整型。}
\end{itemize}
（递减等价于减1。）

\semantic
\paragraph{}
如果两个操作数都具有算术类型，则执行常规算术转换。

\paragraph{}
二元\tm{+}运算符的结果为操作数的和。

\paragraph{}
二元\tm{-}运算符的结果是第一个操作数减去第二个操作数所得的差。

\paragraph{}
就这些运算符而言，指向不是数组元素对象的指针的行为与指向长度为一的数组第一个元素
的指针行为相同，以对象的类型作为其元素的类型。

\paragraph{}
当一个整型表达式被加到指针或从指针中减去时，结果具有指针操作数的类型。如果指针操
作数指向数组对象的元素，并且数组足够大，则结果指向元素与起始元素的偏移量，使得结
果元素和起始数组元素的下标的差等于整型表达式。换句话说，如果表达式\tm{P}指向数组
对象的第$i$个元素，则表达式\tm{(P)+N}（等价地，\tm{N+(P)}）和\tm{(P)-N}（其中
\tm{N}的值为$n$）分别指向数组对象的第$i+n$个元素和第$i-n$个元素，前提是它们存在。
此外，如果表达式\tm{P}指向数组对象的最后一个元素，则表达式\tm{(P)+1}指向数组对象
的最后一个元素之后的第一个元素，如果表达式\tm{Q}指向数组对象的最后一个元素之后的
第一个元素，则表达式\tm{(Q)-1}指向数组对象的最后一个元素。如果指针操作数和结果都
指向同一数组对象的元素，或指向数组对象的最后一个元素之后的第一个元素，则计算结果
不应产生溢出；否则行为未定义。如果结果指向数组对象最后一个元素之后的第一个元素，
则不应将其用作被计算的一元\tm{*}运算符的操作数。

\paragraph{}
当两个指针相减时，二者均应该指向同一数组对象的元素，或指向数组对象最后一个元素之
后的第一个元素；结果是两个数组元素下标的差。结果的大小由实现定义，其类型（有符号
整型）是在\tm{<stddef.h>}头中定义的\tm{ptrdiff\_t}。如果结果在该类型的对象中不可
表示，则行为未定义。换句话说，如果表达式\tm{P}和\tm{Q}分别指向数组对象的第$i$和
第$j$个元素，则表达式\tm{(P)-(Q)}的值为${i-j}$，前提是该值可由\tm{ptrdiff\_t}类
型的对象表示。此外，如果表达式\tm{P}指向数组对象的元素或数组
对象最后一个元素之后的第一个元素，且表达式\tm{Q}指向同一数组对象的最后一个元素，
表达式\tm{((Q+1)-(P)}的值与\tm{((Q)-(P))+1}和\tm{-((P)-((Q+1))}的值相同，如果表
达式\tm{P}指向数组对象最后一个元素之后的第一个元素，则该表达式的值为零，即使表达
式\tm{(Q)+1}没有指向数组对象的元素。\footnote{另一种处理指针算术的方法是首先将指
针转换为字符指针：在此方案中，对转换后的指针进行加法或减法运算的整型表达式首先乘
以最初指向的对象的大小，然后将得到的指针转换回原始类型。对于指针减法，字符指针相
减的结果同样除以最初指向的对象的大小。\\
以这种方式来看时，实现只需要在对象结束后提供一个额外的字节（可能与程序中的另一个
对象重叠），以满足``最后一个元素之后的第一个''要求。}

\paragraph{}
\ex 变长数组类型指针算术定义明确。
\begin{lstlisting}
    {
      int n = 4, m = 3;
      int a[n][m];
      int (*p)[m] = a;  // p == &a[0]
      p += 1;            // p == &a[1]
      (*p)[2] = 99;      // a[1][2] == 99
      n = p - a;         // n == 1
    }
\end{lstlisting}

\paragraph{}
如果上述示例中的数组\tm{a}声明为已知常大小的数组，而指针\tm{p}声明为指向相同已知
常大小的数组（指向\tm{a}）的指针，则结果将相同。

\fwdref{6.7.6.2，7.19}

\pagebreak
                                             \ssect{位移运算符}{lang.expr.shift}
\syntax
\paragraph{}
\synsym{shift-expression}
  \synprd{\nt{additive-expression}}
  \synprd{\nt{shift-expression} \tm{\tl{}\tl} \nt{additive-expression}}
  \synprd[]{\nt{shift-expression} \tm{\tg{}\tg} \nt{additive-expression}}

\constraint
\paragraph{}
每一个操作数都应该具有整型。

\semantic
\paragraph{}
对每个操作数执行整型提升。结果的类型是提升后的左操作数的类型。如果右操作数的值为
负或大于等于提升后的左操作数的宽度，则行为未定义。

\paragraph{}
\tm{E1 \tl{}\tl{} E2}的结果是\tm{E1}左移\tm{E2}位；空出的位用零填充。如果\tm{E1}
为无符号类型，则结果的值为\tm{E1\ttim 2\tsup{E2}}，按结果类型中可表示的最大值加
一取模。如果\tm{E1}具有有符号类型和非负值，且\tm{E1\ttim 2\tsup{E2}}在结果类型中
是可表示的，那么这就是结果值；否则行为未定义。

\paragraph{}
\tm{E1\tg{}\tg E2}的结果是\tm{E1}右移\tm{E2}位。如果\tm{E1}为无符号类型，或者
\tm{E1}具有符号类型和非负值，则结果值是\tm{E1/2\tsup{E2}}商的整数部分。如果
\tm{E1}具有符号类型和负值，则结果值由实现定义。

                                               \ssect{关系运算符}{lang.expr.rel}
\syntax
\paragraph{}
\synsym{relational-expression}
  \synprd{\nt{shift-expression}}
  \synprd{\nt{relational-expression} \tm{\tl} \nt{shift-expression}}
  \synprd{\nt{relational-expression} \tm{\tg} \nt{shift-expression}}
  \synprd{\nt{relational-expression} \tm{\tl=} \nt{shift-expression}}
  \synprd[]{\nt{relational-expression} \tm{\tg=} \nt{shift-expression}}

\constraint
\paragraph{}
以下之一应该成立：
\begin{itemize}
  \item{两个操作数均为实类型；或}
  \item{两个操作数均为指向兼容对象类型的限定或未限定版本的指针。}
\end{itemize}

\semantic
\paragraph{}
如果两操作数均为算术类型，则进行常规算术转换。

\paragraph{}
就这些运算符而言，指向不是数组元素对象的指针的行为与指向长度为一的数组的第一个
元素的指针的行为相同，对象的类型作为其元素类型。

\paragraph{}
当比较两个指针时，结果取决于所指向对象的地址空间中的相对位置。如果指向对象类型的
两个指针都指向同一对象，或者都指向同一数组对象的最后一个元素之后的第一个元素，则
它们相等。如果指向的对象是同一聚合对象的成员，则指向后声明的结构成员的指针比指向
先声明的成员的指针大，指向下标值较大数组元素的指针比指向下标值较小的同一数组元素
的指针大。指向同一联合对象成员的所有指针相等。如果表达式\tm{P}指向数组对象元素，
而表达式\tm{Q}指向同一数组对象的最后一个元素，则指针表达式\tm{Q+1}比\tm{P}大。所
有其他情况下的行为未定义。

\paragraph{}
如果指定的关系为真，则运算符\tm{\tl}（小于）、\tm{\tg}（大于）、\tm{\tl=}（小于
等于）和\tm{\tg=}（大于等于）应生成1，如果为假，则生成0。\footnote{表达式
\tm{a<b<c}不按常规数学方式解释。如语法所示，它意味着\tm{(a<b)<c}；换句话说，
``如果\tm{a}小于\tm{b}，将\tm{1}与\tm{c}比较；否则，将\tm{0}与\tm{c}比较''。}
结果类型为\tm{int}。

                                                \ssect{等性运算符}{lang.expr.eq}
\syntax
\paragraph{}
\synsym{equality-expression}
\synprd{\nt{relational-expression}}
  \synprd{\nt{equality-expression} \tm{==} \nt{relational-expression}}
  \synprd[]{\nt{equality-expression} \tm{!=} \nt{relational-expression}}

\constraint
\paragraph{}
以下之一应该成立：
\begin{itemize}
  \item{两个操作数均为算术类型；}
  \item{两个操作数均为指向兼容类型的限定或未限定版本的指针；}
  \item{其中一个操作数为指向对象类型的指针，另一个为指向\tm{void}类型限定或未限
    定版本的指针，或}
  \item{其中一个操作数是指针，另一个为零指针常量。}
\end{itemize}

\semantic
\paragraph{}
\tm{==}（等于）和\tm{!=}（不等于）运算符与关系运算符类似，但优先级较低。
\footnote{由于优先级，当\tm{a<b}和\tm{c<d}具有相同真值时，\tm{a<b == c<d}为1。}
如果指定的关系为真，则每个运算符生成1；如果指定的关系为假，则生成0。结果的类型为
\tm{int}。对于任何一对操作数，只有一个关系为真。

\paragraph{}
如果两个操作数都有算术类型，则执行常规算术转换。当且仅当实部和虚部相等时，复数类
型的值才相等。来自不同类型域的算术类型的任意两个值相等当且仅当它们转换为由常规算
术转换确定的（复数）结果类型的结果是相等的。

\paragraph{}
否则，至少有一个操作数是指针。如果一个操作数是指针，另一个操作数是零指针常量，则
零指针常量将转换为指针类型。如果一个操作数是指向对象类型的指针，而另一个操作数是
指向\tm{void}限定或不限定版本的指针，则前者将转换为后者的类型。

\paragraph{}
如果两个指针都是零指针，两个指针都是指向同一对象（包括指向对象和位于其开头的子对
象的指针）或函数的指针，两个指针都是指向同一数组对象的最后一个元素之后的第一个元
素的指针，或者一个指针指向一个数组对象最后一个元素之后的第一个元素，另一个指针指
向地址空间中恰好紧跟在第一个数组对象之后的不同数组对象的开始。\footnote{两个对象
可能由于它们是较大数组的相邻元素而在内存中相邻，或者结构的相邻成员之间没有填充，
或者是因为实现选择了将它们放置在一起，即使它们是不相关的。如果先前的无效指针操作
（如越界访问数组）产生未定义行为，则随后的比较也会产生未定义行为。}

\paragraph{}
就这些运算符而言，指向不是数组元素对象的指针行为与指向长度为1的数组的第一个元素
的指针行为相同，对象类型作为其元素类型。

\pagebreak
                                             \ssect{按位与运算符}{lang.expr.and}
\syntax
\paragraph{}
\synsym{AND-expression}
  \synprd{\nt{equality-expression}}
  \synprd[]{\nt{AND-expression} \tm{\&} \nt{equality-expression}}

\constraint
\paragraph{}
每一个操作数均应该具有整型。

\semantic
\paragraph{}
常规算术转换作用于操作数。

\paragraph{}
二元\tm{\&}运算符的结果是操作数的按位与（即当且仅当转换后操作数中的对应位都置位
时，才会设置结果中的对应位）。

                                           \ssect{按位异或运算符}{lang.expr.xor}
\syntax
\paragraph{}
\synsym{exclusive-OR-expression}
  \synprd{\nt{AND-expression}}
  \synprd[]{\nt{exclusive-OR-expression} \tm{\^} \nt{AND-expression}}

\constraint
\paragraph{}
每一个操作数均应该具有整型。

\semantic
\paragraph{}
常规算术转换作用于操作数。

\paragraph{}
二元运算符\tm{\^}的结果是操作数的按位异或（即当且仅当转换后操作数中对应位上仅有
一个置位时，才会设置结果中的对应位）。

                                              \ssect{按位或运算符}{lang.expr.or}
\syntax
\paragraph{}
\synsym{inclusive-OR-expression}
\synprd{\nt{exclusive-OR-expression}}
  \synprd[]{\nt{inclusive-OR-expression} \tm{|} \nt{exclusive-OR-expression}}

\constraint
\paragraph{}
每一个操作数均应该具有整型。

\semantic
\paragraph{}
常规算术转换作用于操作数。

\paragraph{}
运算符\tm{|}的结果为操作数的按位或（即当且仅当转换后操作数中的至少一个对应位置位
时，才会设置结果中的对应位）。

                                            \ssect{逻辑与运算符}{lang.expr.land}
\syntax
\paragraph{}
\synsym{logical-AND-expression}
  \synprd{\nt{inclusive-OR-expression}}
  \synprd[]{\nt{logical-AND-expression} \tm{\&\&} \nt{inclusive-OR-expression}}

\constraint
\paragraph{}
每一个操作数均应该为标量类型。

\semantic
\paragraph{}
如果\tm{\&\&}运算符的两个操作数都不等于0则应生成1；否则将生成0。结果类型为
\tm{int}。

\paragraph{}
与按位二元\tm{\&}运算符不同，\tm{\&\&}运算符保证从左向右计算；如果计算第二个操作
数，则在第一个操作数和第二个操作数的计算之间有一个序列点。如果第一个操作数比较等
于0，则不计算第二个操作数。

                                             \ssect{逻辑或运算符}{lang.expr.lor}
\syntax
\paragraph{}
\synsym{logical-OR-expression}
  \synprd{\nt{inclusive-AND-expression}}
  \synprd[]{\nt{logical-OR-expression} \tm{||} \nt{inclusive-AND-expression}}

\constraint
\paragraph{}
每一个操作数均应该为标量类型。

\semantic
\paragraph{}
如果\tm{||}运算符的两个操作数中任一个不等于0则应生成1；否则将生成0。结果类型为
\tm{int}。

\paragraph{}
与按位二元\tm{|}运算符不同，\tm{||}运算符保证从左向右计算；如果计算第二个操作
数，则在第一个操作数和第二个操作数的计算之间有一个序列点。如果第一个操作数比较不
等于0，则不计算第二个操作数。

                                              \ssect{条件运算符}{lang.expr.cond}
\syntax
\paragraph{}
\synsym{conditional-expression}
  \synprd{\nt{logical-OR-expression}}
  \synprd[]{\nt{logical-OR-expression} \tm{?} \nt{expression} \tm{:}
    \nt{conditional-expression}}

\constraint
\paragraph{}
第一操作数应具有标量类型。

\paragraph{}
对第二和第三操作数，以下之一应该成立：
\begin{itemize}
  \item{两操作数均为算术类型；}
  \item{两操作数均为相同结构或联合类型；}
  \item{两操作数均为void类型。}
  \item{两操作数均为指向兼容类型的限定或未限定版本的指针；}
  \item{其中一个操作数为指针，另一个为零指针常量；或}
  \item{其中一个操作数为对象类型指针，另一个为指向\tm{void}类型限定或未限定版本
    的指针。}
\end{itemize}

\semantic
\paragraph{}
计算其第一个操作数；在其计算和第二个或第三个操作数的计算之间有一个序列点（无论计
算哪一个）。第二个操作数仅在第一个不等于0时计算；第三个操作数仅在第一个等于0时计
算；结果是第二个或第三个操作数的值（无论计算哪一个）并转换为以下描述的类型。
\footnote{条件表达式不产生左值。}

\paragraph{}
如果第二个和第三个操作数都具有算术类型，且由常规算术转换确定结果类型，如果应用的
话，则结果类型是转换后的结果类型。如果两个操作数都具有结构或联合类型，则结果具有
该类型。如果两个操作数都具有\tm{void}类型，则结果具有\tm{void}类型。

\paragraph{}
如果第二个和第三个操作数都是指针，或者一个是零指针常量，另一个是指针，则结果类型
是指向使用两个操作数引用类型的所有类型限定符所限定类型的指针。此外，如果两个操作
数都是指向兼容类型或兼容类型的不同限定版本的指针，则结果类型是指向合成类型的适当
限定版本的指针；如果一个操作数是零指针常量，则结果具有另一个操作数的类型；否则，
一个操作数是指向\tm{void}或其限定版本，在这种情况下，结果类型是指向适当限定版本
的\tm{void}指针。

\paragraph{}
\ex* 当第二个和第三个操作数是指针时产生的共同类型在两个独立的阶段中确定。例如，
适当的限定符不依赖于两个指针是否具有兼容的类型。

\paragraph{}
给定以下声明
\begin{lstlisting}
    const void *c_vp;
    void *vp;
    const int *c_ip;
    volatile int *v_ip;
    int *ip;
    const char *c_cp;
\end{lstlisting}
下表中的第三列是条件表达式结果的通用类型，前两列是第二个和第三个操作数（任意顺
序）：
\begin{table}[h!]
  \begin{tabular}{lll}
    \tm{c\_vp} & \tm{c\_ip} & \tm{const void *} \\
    \tm{v\_ip} & \tm{0}     & \tm{volatile int *} \\
    \tm{c\_ip} & \tm{v\_ip} & \tm{const volatile int *} \\
    \tm{vp}    & \tm{c\_cp} & \tm{const void *} \\
    \tm{ip}    & \tm{c\_ip} & \tm{const int *} \\
    \tm{vp}    & \tm{ip}    & \tm{void *}
  \end{tabular}
\end{table}

                                            \ssect{赋值运算符}{lang.expr.assign}
\syntax
\paragraph{}
\synsym{assignment-expression}
  \synprd{\nt{conditional-expression}}
  \synprd{\nt{unary-expression assignment-operator assignment-expression}}
\synsym[one of]{assignment-operator}
  \synprd[]{\tm{= *= /= \%= += -= \tl{}\tl= \tg{}\tg= \&= \^{}= |=}}

\constraint
\paragraph{}
赋值运算符的左操作数应为可修改的左值。

\semantic
\paragraph{}
赋值运算符将值存储在左操作数指定的对象中。赋值表达式在赋值之后具有左操作数的值，
\footnote{实现允许读取对象以确定值，但不需要这样做，即使对象具有\tm{volatile}限
定类型。} 但不是左值。赋值表达式的类型是左操作数在左值转换后的类型。更新左操作数
的存储值的副作用后序于左操作数和右操作数的值计算。操作数的计算无序。

                                      \sssect{简单赋值}{lang.expr.assign.simple}
\constraint
\paragraph{}
以下之一应该成立：\footnote{对于类型限定符，这些约束的不对称性是由于转换（在
\ref{lang.conv.other.desig}中指定）导致的，该转换将左值更改为``表达式的值''，从
而删除应用于表达式类型范畴的任何类型限定符（例如，它从类型
\tm{int volatile * const}中删除\tm{const}而不删除\tm{volatile}）。}
\begin{itemize}
  \item{左操作数具有原子，限定或未限定算术类型，右操作数具有算术类型；}
  \item{左操作数具有与右操作数兼容的结构或联合类型的原子，限定或未限定版本；}
  \item{左操作数具有原子，限定或未限定指针类型，且（考虑左值转换后的左操作数将具
    有的类型）两操作数均为指向兼容类型的限定或未限定版本的指针，并且左操作数具有
    右操作数所指类型的所有限定符。}
  \item{左操作数具有原子，限定或未限定的指针类型，并且（考虑到左操作数在左值转换
    后将具有的类型）一个操作数是指向对象类型的指针，另一个操作数是指向\tm{void}
    类型的限定或未限定版本的指针，并且左侧指向的类型具有右操作数所指的类型的所有
    限定符；}
  \item{左操作数是原子，限定或未限定指针，右操作数是零指针常量；或}
  \item{左操作数为原子，限定或未限定\tm{\_Bool}类型，右操作数是指针。}
\end{itemize}

\semantic
\paragraph{}
在\textit{简单赋值}（\tm{=}）中，右操作数的值转换为赋值表达式的类型，并替换存储
在左操作数指定的对象中的值。

\paragraph{}
如果从任何与一个对象的存储重叠的另一个对象读取存储在第一个对象中的值，则应该完全
重叠，并且两个对象应具有兼容类型的限定或未限定版本；否则行为未定义。

\paragraph{}
\ex 以下程序片断中
\begin{lstlisting}
    int f(void);
    char c;
    /* ... */
    if ((c = f()) == -1)
      /* ... */
\end{lstlisting}
函数返回的\tm{int}值存储在\tm{char}中时可能会被截断，然后在比较前转换回\tm{int}
的宽度。在一个``普通''\tm{char}的值范围与\tm{unsigned char}的值范围相同
（\tm{char}比\tm{int}更窄）的实现中，转换的结果不能是负数，因此比较的操作数永远
不相等。因此，对于完全可移植性，变量\tm{c}应该声明为\tm{int}。

\paragraph{}
\ex 以下片断中：
\begin{lstlisting}
    char c;
    int i;
    long l;

    l = (c = i);
\end{lstlisting}
\tm{i}的值转换为赋值表达式\tm{c = i}的类型，即\tm{char}类型。然后将括号中的表达
式值转换为外层赋值表达式的类型，即\tm{long int}类型。

\paragraph{}
\ex 考虑以下片断：
\begin{lstlisting}
    const char **cpp;
    char *p;
    const char c = 'A';

    cpp = &p;   // constraint violation
    *cpp = &c;  // valid
    *p = 0;     // valid
\end{lstlisting}
第一个赋值不安全，因为它将允许后面的有效代码尝试更改常量对象\tm{c}的值。

                                        \sssect{复合赋值}{lang.expr.assign.cmpd}
\constraint
\paragraph{}
对\tm{+=}和\tm{-=}运算符，左操作数应为指向完整对象类型的原子、限定或未限定指针，
右操作数应为整型；或左操作数为原子、限定或未限定指针，右操作数为算术类型。

\paragraph{}
对于其他运算符，左操作数应具有原子、限定或未限定算术类型，并且（考虑左操作数在左
值转换后的类型）每个操作数应具有与相应的二元运算符允许的算术类型一致的算术类型。

\semantic
\paragraph{}
形如\tm{E1} \nt{op}\tm{= E2}的\textit{复合赋值}等价于简单赋值表达式\tm{E1 = E1}
\nt{op} \tm{(E2)}，但左值\tm{E1}只计算一次，并且对于不确定性有序的函数调用，复合
赋值的操作是单个（single）计算。如果\tm{E1}具有原子类型，则复合赋值是读-修改-写
操作，具有\tm{memory\_order\_seq\_cst}的内存顺序语义。\footnote{
\newcommand{\lbox}[2][4em]{\\ \mbox{\hspace{#1}#2}}
如果可以形成指向原子对象的指针，并且\tm{E1}和\tm{E2}具有整型，则相当于以下代码序
列，其中\nt{T1}是\tm{E1}的类型，\nt{T2}是\tm{E2}的类型：
\lbox{\nt{T1} \tm{*addr = \&E1;}}
\lbox{\nt{T2} \tm{val = (E1);}}
\lbox{\nt{T1} \tm{odl = *addr;}}
\lbox{\nt{T1} \tm{new;}}
\lbox{\tm{do \{}}
\lbox[6em]{\tm{new = old} \nt{op} \tm{val;}}
\lbox{\tm{\} while (!atomic\_compare\_exchange\_strong(addr, \&old, new));}}  \\
\tm{new}为操作的结果。                                                        \\
如果\tm{E1}或\tm{E2}具有浮点类型，则在丢弃的\tm{new}计算过程中遇到的异常条件或浮
点异常也应丢弃，以满足\tm{E1} \nt{op}\tm{= E2}和\tm{E1 = E1} \nt{op} \tm{(E2)}的
等效性。例如，如果附录\ref{fparith}有效，所涉及的浮点类型具有IEC 60559格式，且
\tm{FLT\_EVAL\_METHOD}为0，则等效代码为
\lbox{\tm{\#include <fenv.h>}}
\lbox{\tm{\#pragma STDC FENV\_ACCESS ON}}
\lbox{\tm{/* ... */}}
\lbox[6em]{\tm{fenv\_t fenv;}}
\lbox[6em]{\nt{T1} \tm{*addr = \&E1;}}
\lbox[6em]{\nt{T2} \tm{val = E2;}}
\lbox[6em]{\nt{T1} \tm{old = *addr;}}
\lbox[6em]{\nt{T1} \tm{new;}}
\lbox[6em]{\tm{feholdexcept(\&fenv);}}
\lbox[6em]{\tm{for (;;) \{}}
\lbox[8em]{\tm{new = old} \nt{op} \tm{val;}}
\lbox[8em]{\tm{if (!atomic\_compare\_exchange\_strong(addr, \&old, new))}}
\lbox[10em]{\tm{break;}}
\lbox[8em]{\tm{feclearexcept(FE\_ALL\_EXCEPT);}}
\lbox[6em]{\tm{\}}}
\lbox[6em]{\tm{feupdateenv(\&fenv);}} \\
如果\tm{FLT\_EVAL\_METHOD}不是0，那么\tm{T2}必须具有计算\tm{E2}所需范围和精度的
类型，以便满足等效性。}

                                             \ssect{逗号运算符}{lang.expr.comma}
\syntax
\paragraph{}
\synsym{expression}
  \synprd{\nt{assignment-expression}}
  \synprd[]{\nt{expression} \tm{,} \nt{assignment-expression}}

\semantic
\paragraph{}
逗号运算符的左操作数被计算为空表达式；它的计算值与右操作数的计算值之间有一个序列
点。然后计算右操作数；结果有其类型和值。\footnote{逗号表达式不产生左值。}

\paragraph{}
\ex* 如语法所示，逗号运算符（如本节所述）不能出现在使用逗号分隔列表中项目的上下
文中（如函数参数或初始化列表）。另一方面，它可以在带圆括号的表达式中使用，也可以
在条件运算符的第二个表达式中使用。在函数调用
\begin{lstlisting}
    f(a, (t=3, t+2), c)
\end{lstlisting}
中函数有三个参数，第二个参数的值为5。

\fwdref{6.7.9}

                                               \sect{常量表达式}{lang.constexpr}
\syntax
\paragraph{}
\synsym{constant-expression}
  \synprd[]{\nt{conditional-expression}}

\desc
\paragraph{}
常量表达式可以在翻译期间而不是运行时进行计算，因此可以在常量可能存在的任何位置使
用。

\constraint
\paragraph{}
常量表达式不应包含赋值、递增、递减、函数调用或逗号运算符，除非它们包含在未计算的
子表达式中。\footnote{通常不计算\tm{sizeof}或\tm{\_Alignof}运算符的操作数
（\ref{lang.expr.unary.sizeof}）。}

\paragraph{}
每个常量表达式的计算结果应为其类型的可表示值范围内的常量。

\semantic
\paragraph{}
在多个上下文中需要计算为常量的表达式。如果在翻译环境中对浮点表达式进行计算，则算
术范围和精度至少应与在执行环境中对表达式进行计算时一样大。\footnote{使用由
\tm{FLT\_EVAL\_METHOD}确定的计算格式也适用于翻译环境中的计算。}

\paragraph{}
\textit{整型常量表达式}\footnote{整型常量表达式在许多上下文中都是必需的，例如结
构的位字段成员的大小、枚举常量的值和非变长数组的大小。
\ref{lang.ppdir.condinc}中讨论了适用于条件包含预处理指令中使用的整型常量表达式的
其他约束。}应具有整型，并且只能具有整型常量、枚举常量、字符常量、结果为整型常量
的sizeof表达式、\tm{\_Alignof}表达式以及作为强制转换直接操作数的浮点常量。整型常
量表达式中的强制转换运算符只能将算术类型转换为整型，除作为\tm{sizeof}或
\tm{\_Alignof}运算符操作数的一部分。

\paragraph{}
初始化中的常量表达式允许有更多的纬度。此类常量表达式应为或计算为以下其中之一：
\begin{itemize}
  \item{算术常量表达式，}
  \item{零指针常量，}
  \item{地址常量，或}
  \item{完整对象类型的地址常量加或减一个整型常量表达式。}
\end{itemize}

\paragraph{}
\textit{算术常量表达式}应具有算术类型，且只能具有整型常量、浮点常量、枚举常量、
字符常量、结果为整型常量的\tm{sizeof}表达式以及\tm{\_Alignof}表达式等操作数。算
术常量表达式中的强制转换运算符只能将算术类型转换为算术类型，除作为\tm{sizeof}或
\tm{\_Alignof}运算符操作数的一部分。

\paragraph{}
\textit{地址常量}是一个零指针、一个指向指定静态存储期对象的左值的指针或一个指向
函数指示符的指针；它应使用一元运算符\tm{\&}或整型常量转换为指针类型来显式创建，
或通过使用数组或函数类型的表达式来隐式创建。数组下标\tm{[]}，成员访问\tm{.}和
\tm{-\tg}运算符、取地址\tm{\&}和取值\tm{*}一元运算符和指针强制转换可用于创建地
址常量，但不能使用这些运算符访问对象的值。

\paragraph{}
实现可能接受其他形式的常量表达式。

\paragraph{}
计算常量表达式的语义规则和非常量表达式一样。\footnote{因此，以下初始化中，    \\
\mbox{\hspace{4em}\tm{static int i = 2 || 1 / 0;}}                            \\
表达式是值为一的有效整型常量表达式。}

\fwdref{6.7.6.2，6.7.9}

                                                           \sect{声明}{lang.dcl}
\syntax
\paragraph{}
\synsym{declaration}
  \synprd{\nt{declaration-specifiers init-declarator-list\tsub{opt}} \tm{;}}
  \synprd{\nt{static\_assert-declaration}}
\synsym{declaration-specifiers}
  \synprd{\nt{storage-class-specifier declaration-specifiers\tsub{opt}}}
  \synprd{\nt{type-specifier declaration-specifiers\tsub{opt}}}
  \synprd{\nt{type-qualifier declaration-specifiers\tsub{opt}}}
  \synprd{\nt{function-specifier declaration-specifiers\tsub{opt}}}
  \synprd{\nt{alignment-specifier declaration-specifiers\tsub{opt}}}
\synsym{init-declarator-list}
  \synprd{\nt{init-declarator}}
  \synprd{\nt{init-declarator-list} \tm{,} \nt{init-declarator}}
\synsym{init-declarator}
  \synprd{\nt{declarator}}
  \synprd[]{\nt{declarator} \tm{=} \nt{initializer}}

\constraint
\paragraph{}
除static\_assert声明之外的声明应至少声明一个声明子（函数参数或结构/联合的成员除
外）、一个标记或一个枚举成员。

\paragraph{}
如果标识符无链接，则在同一作用域和同一命名空间中不应该存在超过一个该标识符的声明
（在声明子或类型说明符中），除了：
\begin{itemize}
  \item{类型定义名称可以重新定义为与当前所表示的相同类型，前提是该类型不是变量修
    改的类型；}
  \item{标签可按照\ref{lang.dcl.type.tag}的规定重新声明。}
\end{itemize}

\paragraph{}
同一作用域内引用同一对象或函数的所有声明应指定兼容类型。

\semantic
\paragraph{}
声明指定一组标识符的解释和属性。标识符的\textit{定义}是该标识符的声明，该声明：
\begin{itemize}
  \item{对于对象，为其保留存储空间；}
  \item{对于函数，包含一个函数体；\footnote{函数定义有不同语法，由
    \ref{lang.extn.fct}描述。}}
  \item{对于枚举常量，是该标识符的（唯一）声明；}
  \item{对类型定义名，是该标识符的第一个（或唯一）声明。}
\end{itemize}

\paragraph{}
声明说明符由一系列说明符组成，这些说明符指示链接、存储期以及声明子指示的实体类型
的一部分。init-declarator-list是一个用逗号分隔的声明子序列，每个声明子都可以有附
加的类型信息，或者是初始化，或者两者都有。声明子包含所声明的标识符（如果有）。

\paragraph{}
如果对象的标识符声明没有链接，则该对象的类型应在其声明子结束时完整，或者如果它有
初始化，在其init-declarator结束时完整；对于函数参数（包括在原型中），则是调整后
的类型（见\ref{lang.dcl.decl.fct}）必须完整。

\fwdref{6.7.6，6.7.2.2，6.7.9，6.7.7，6.7.3}

                                                \ssect{存储类说明}{lang.dcl.stc}
\syntax
\paragraph{}
\synsym{storage-class-specifier}
  \synprd{\tm{typedef}}
  \synprd{\tm{extern}}
  \synprd{\tm{static}}
  \synprd{\tm{\_Thread\_local}}
  \synprd{\tm{auto}}
  \synprd[]{\tm{register}}

\constraint
\paragraph{}
在声明中的说明符中最多可以提供一个存储类说明符，除了\tm{\_Thread\_local}可能与
\tm{static}或\tm{extern}一起出现。\footnote{见``未来语言方向''
（\ref{lang.dir.stc}）}

\paragraph{}
在具有块作用域对象的声明中，如果声明说明符包括\tm{\_Thread\_local}，则它们还应包
括\tm{static}或\tm{extern}。如果对象的任何声明中出现\tm{\_Thread\_local}，则它应
出现在该对象的每个声明中。

\paragraph{}
\tm{\_Thread\_local}不应出现在函数声明的声明说明符中。

\semantic
\paragraph{}
为了语法方便将\tm{typedef}说明符称为``存储类说明符''；\ref{lang.dcl.typedef}对其
进行了讨论。各种链接和存储期的含义在\ref{lang.concept.link}和
\ref{lang.concept.storage}节中进行讨论。

\paragraph{}
带有存储类说明符\tm{register}的对象标识符声明建议尽可能快地访问该对象。这些建议
的有效程度由实现定义。\footnote{实现可以将任何\tm{register}声明简单地视为
\tm{auto}声明。但是，无论是否实际使用可寻址存储，都不能显式（使用
\ref{lang.expr.unary.addr}中讨论的一元运算符）或隐式（通过将数组名转换为
\ref{lang.conv.other.desig}中讨论的指针）计算用存储类说明符\tm{register}声明的对
象的任何部分的地址。因此，可以应用于使用存储类说明符\tm{register}声明的数组的唯
一运算符是\tm{sizeof}。}

\paragraph{}
具有块作用域的函数标识符声明除了\tm{extern}之外，不应具有其他显式存储类说明符。

\paragraph{}
如果使用\tm{typedef}以外的存储类说明符声明聚合或联合对象，则由存储类说明符产生的
属性，除了链接以外，也应用于对象的成员，且递归应用于任何聚合或联合成员对象。

\fwdref{6.7.8}

                                               \ssect{类型说明符}{lang.dcl.type}
\syntax
\paragraph{}
\synsym{type-specifier}
  \synprd{\tm{void}}
  \synprd{\tm{char}}
  \synprd{\tm{short}}
  \synprd{\tm{int}}
  \synprd{\tm{long}}
  \synprd{\tm{float}}
  \synprd{\tm{double}}
  \synprd{\tm{signed}}
  \synprd{\tm{unsigned}}
  \synprd{\tm{\_Bool}}
  \synprd{\tm{\_Complex}}
  \synprd{\nt{automic-type-specifier}}
  \synprd{\nt{struct-or-union-specifier}}
  \synprd{\nt{enum-specifier}}
  \synprd[]{\nt{typedef-name}}

\constraint
\paragraph{}
每个声明中的声明说明符和每个结构声明和类型名称中的说明符限定符列表中应至少提供一
个类型说明符。每个类型说明符列表应为以下多集之一（当每项有多个时，用逗号分隔）；
类型说明符可以以任何顺序出现，可能与其他声明说明符混合。
\begin{itemize}
  \item{\tm{void}}
  \item{\tm{char}}
  \item{\tm{signed char}}
  \item{\tm{unsigned char}}
  \item{\tm{short}，\tm{signed short}，\tm{short int}或\tm{signed short int}}
  \item{\tm{unsigned short}或\tm{unsigned short int}}
  \item{\tm{int}，\tm{signed}或\tm{signed int}}
  \item{\tm{unsigned}或\tm{unsigned int}}
  \item{\tm{long}，\tm{signed long}，\tm{long int}或\tm{signed long int}}
  \item{\tm{unsigned long}或\tm{unsigned long int}}
  \item{\tm{long long}，\tm{signed long long}，\tm{long long int}或
    \tm{signed long long int}}
  \item{\tm{unsigned long long}或\tm{unsigned long long int}}
  \item{\tm{float}}
  \item{\tm{double}}
  \item{\tm{long double}}
  \item{\tm{\_Bool}}
  \item{\tm{float \_Complex}}
  \item{\tm{double \_Complex}}
  \item{\tm{long double \_Complex}}
  \item{原子类型说明符}
  \item{结构或联合说明符}
  \item{枚举说明符}
  \item{类型定义名}
\end{itemize}

\paragraph{}
如果实现不支持复类型则不应使用\tm{\_Complex}类型说明符
（见\ref{lang.ppdir.predef.cond}）。

\semantic
\paragraph{}
结构，联合，枚举和原子类型的说明符在\ref{lang.dcl.type.struct}到
\ref{lang.dcl.type.atom}中讨论。类型定义名的声明在\ref{lang.dcl.typedef}中讨论。
\ref{lang.concept.type}中讨论了其他类型的特征。

\paragraph{}
每个逗号分隔的多集都指定相同的类型，除了位字段，其说明符\tm{int}是与\tm{signed
int}相同的类型还是与\tm{unsigned int}相同的类型由实现定义。

\fwdref{6.7.2.4，6.7.2.2，6.7.2.1，6.7.2.3，6.7.8}

                                 \sssect{结构与联合说明符}{lang.dcl.type.struct}
\syntax
\paragraph{}
\synsym{struct-or-union-specifier}
  \synprd{\nt{struct-or-union identifier\tsub{opt}} \tm{\{}
    \nt{struct-declaration-list} \tm{\}}}
  \synprd{\nt{struct-or-union identifier}}
\synsym{struct-or-union}
  \synprd{\tm{struct}}
  \synprd{\tm{union}}
\synsym{struct-declaration-list}
  \synprd{\nt{struct-declaration}}
  \synprd{\nt{struct-declaration-list struct-declaration}}
\synsym{struct-declaration}
  \synprd{\nt{specifier-qualifier-list struct-declarator-list\tsub{opt}} \tm{;}}
  \synprd{\nt{static\_assert-declaration}}
\synsym{specifier-qualifier-list}
  \synprd{\nt{type-specifier specifier-qualifier-list\tsub{opt}}}
  \synprd{\nt{type-qualifier specifier-qualifier-list\tsub{opt}}}
\synsym{struct-declarator-list}
  \synprd{\nt{struct-declarator}}
  \synprd{\nt{struct-declarator-list} \tm{,} \nt{struct-declarator}}
\synsym{struct-declarator}
  \synprd{\nt{declarator}}
  \synprd[]{\nt{declarator\tsub{opt}} \tm{:} \nt{constant-expression}}

\constraint
\paragraph{}
未声明匿名结构或匿名联合的struct-declaration应包含一个struct-declarator-list。

\paragraph{}
结构或联合不应包含具有不完整或函数类型的成员（因此，结构不应包含其自身的实例，但
可以包含指向其自身实例的指针），除了具有多个命名成员的结构的最后一个成员可能有不
完整的数组类型; 这样的结构（以及可能递归地包含这种结构作为成员的任何联合）不应是
结构的成员或数组的元素。

\paragraph{}
指定位字段宽度的表达式应为整型常量表达式，其值非负且不超过如省略掉冒号和表达式后
的类型所指定对象的宽度。\footnote{虽然\tm{\_Bool}对象中的位数至少为
\tm{CHAR\_BIT}，但\tm{\_Bool}的宽度（符号和值位数）可能只有1位。} 如果该值为零，
则该声明不应具有声明子。

\paragraph{}
位字段的类型应为\tm{\_Bool}，\tm{signed int}，\tm{unsigned int}或其他实现定义类
型的限定或非限定版本。是否允许原子类型由实现定义。

\semantic
\paragraph{}
如\ref{lang.concept.type}中所讨论的，结构是由一系列成员组成的类型，其存储有序分
配，而联合是由存储重叠的成员序列组成的类型。

\paragraph{}
结构和联合说明符具有相同的形式。关键字\tm{struct}和\tm{union}表示指定的类型分别
是结构类型或联合类型。

\paragraph{}
struct-or-union-specifier中struct-declaration-list在翻译单元中声明一个新类型。
struct-declaration-list是结构或联合成员的一系列声明。 如果
struct-declaration-list不包含任何命名成员（直接或通过匿名结构或匿名联合），则行
为未定义。直到终止列表的\tm{\}}之前类型都不完整，之后成为完整类型。

\paragraph{}
结构或联合成员可以具有除变量修改类型之外的任何完整对象类型。\footnote{结构或联合
不能包含具有变量修改类型的成员，因为成员名称不是\ref{lang.concept.namespace}中定
义的普通标识符。} 此外，可以声明成员由指定数量的位组成（如果有的话包括符号位）。
这样的成员称为\textit{位字段}; \footnote{一元\tm{\&}（取地址）运算符不能用于位字
段对象；因此不存在位字段对象的指针或数组。} 它的宽度前面有一个冒号。

\paragraph{}
位字段被解释为具有由指定位数组成的有符号或无符号整型。\footnote{如上面
\ref{lang.dcl.type}中所述，如果使用的实际类型说明符是\tm{int}或定义为\tm{int}的
类型定义名，则位字段是有符号还是无符号由实现定义。} 如果将值0或1存储到
\tm{\_Bool}类型的非零宽度位字段中，则位字段的值应等于存储的值; \tm{\_Bool}位字段
具有\tm{\_Bool}的语义。

\paragraph{}
实现可以分配任何足够大的可寻址存储单元来保存位字段。如果剩余足够的空间，则紧跟在
结构中的另一个位字段之后的位字段将被打包到相同单元的相邻位中。如果剩余空间不足，
则是否将放不下的位字段放入下一个单元或重叠的相邻单元由实现定义。单元内的位字段分
配顺序（高阶到低阶或低阶到高阶）由实现定义。未指定可寻址存储单元的对齐。

\paragraph{}
没有声明子而只有冒号和宽度的位字段声明表示未命名的位字段。\footnote{未命名的位字
段结构成员可用于填充以符合外部强加的布局。} 作为一种特殊情况，宽度为0的位字段结
构成员表示不再将其他位字段打包到放置了前一位字段（如果有的话）的单元中。

\paragraph{}
类型说明符为无标记的结构说明符的未命名成员，称为\textit{匿名结构};
类型说明符为无标记的联合说明符的未命名成员，称为\textit{匿名联合}。
匿名结构或联合的成员被视为包含结构或联合的成员。如果包含结构或联合也是匿名的，则
递归应用。

\paragraph{}
结构或联合对象的每个非位字段成员以适合其类型的实现定义方式对齐。

\paragraph{}
在结构对象中，非位字段成员和位字段所在的单元的地址按声明顺序递增。适当转换的指向
结构对象的指针指向其初始成员（或者如果该成员是位字段，则指向它所在的单元），反之
亦然。结构对象中可能存在未命名的填充，但不是在其开头。

\paragraph{}
联合的大小足以包含其最大的成员。同一时间点最多只有一个成员的值可以存储在联合对象
中。适当转换的指向联合对象的指针指向其每个成员（或者如果成员是位字段，则指向它所
在的单元），反之亦然。

\paragraph{}
结构或联合的末尾可能有未命名的填充。

\paragraph{}
作为一种特殊情况，具有多个命名成员的结构的最后一个元素可能具有不完整的数组类型;
这被称为\textit{灵活数组成员}。在大多数情况下，将忽略灵活数组成员。特别是结构的
大小如同省略了灵活数组成员，除了它可能具有比省略所暗含的更多的尾填充。但当一个
\tm{.}（或\tm{->}）运算符的左操作数为带有灵活数组成员的结构（一个指针），右操作
数命名该成员，其行为如同该成员被最长的数组替换（具有相同的元素类型）而不会使结构
大于被访问的对象；数组的偏移量应保持为灵活数组成员的偏移量，即使这与替换数组的偏
移量不同。如果此数组没有元素，则其行为就如同它有一个元素，但如果任何尝试访问该元
素或生成一个越过它的指针，则行为未定义。

\paragraph{}
\ex 以下代码展示匿名结构或联合：
\begin{lstlisting}
    struct v {
      union {   // anonymous union
        struct { int i, j; }  // anonymous structure
        struct { long k, l; } w;
      };
      int m;
    } v1;

    v1.i = 2;   // valid
    v1.k = 3;   // invalid: inner structure is not anonymous
    v1.w.k = 5; // valid
\end{lstlisting}

\paragraph{}
\ex 在以下声明中
\begin{lstlisting}
    struct s { int n; double d[]; };
\end{lstlisting}
结构\tm{struct s}具有灵活数组成员\tm{d}。一个典型的使用方式是：
\begin{lstlisting}
    int m = /* some value */
    struct s *p = malloc(sizeof (struct s) + sizeof (double [m]));
\end{lstlisting}
假定调用\tm{malloc}成功，\tm{p}所指的对象对大多数目而言其行为如同\tm{p}被声明成
\begin{lstlisting}
    struct { int n; double d[m]; } *p;
\end{lstlisting}
（存在一些该等价不成立的情况；特别是，成员\tm{d}的偏移可能会不一样）。

\paragraph{}
使用以上声明：
\begin{lstlisting}
    struct s t1 = { 0 };          // valid
    struct s t2 = { 1, { 4.2 }};  // invalid
    t1.n = 4;                     // valid
    t1.d[0] = 4.2;                // might be undefined behavior
\end{lstlisting}
\tm{t2}的初始化不合法（违反约束）是因为\tm{struct s}被当成好像不包括成员\tm{d}一
样。对\tm{t1.d[0]}赋值可能是未定义行为，但可能
\begin{lstlisting}
    sizeof (struct s) >= offsetof(struct s, d) + sizeof (double)
\end{lstlisting}
这种情况下赋值是合法的。然而这不能出现在严格合规实现代码中。

\paragraph{}
在进一步声明：
\begin{lstlisting}
    struct ss { int n; }
\end{lstlisting}
表达式：
\begin{lstlisting}
    sizeof (struct s) >= sizeof (struct ss)
    sizeof (struct s) >= offsetof(struct s, d)
\end{lstlisting}
总是等于1.

\paragraph{}
如果\tm{sizeof (double)}等于8，那么在以下代码执行后：
\begin{lstlisting}
    struct s *s1;
    struct s *s2;
    s1 = malloc(sizeof (struct s) + 64);
    s2 = malloc(sizeof (struct s) + 46);
\end{lstlisting}
并假定调用\tm{malloc}成功，\tm{s1}和\tm{s2}所指对象对大多数目的，行为如同标识符
被声明为：
\begin{lstlisting}
    struct { int n; double d[8]; } * s1;
    struct { int n; double d[5]; } * s2;
\end{lstlisting}

\paragraph{}
在以下成功赋值后：
\begin{lstlisting}
    s1 = malloc(sizeof (struct s) + 10);
    s2 = malloc(sizeof (struct s) +  6);
\end{lstlisting}
那么它们的行为如同声明成：
\begin{lstlisting}
    struct { int n; double d[1]; } *s1, *s2;
\end{lstlisting}
并且：
\begin{lstlisting}
    double *dp;
    dp = &(s1->d[0]);   // valid
    *dp = 42;           // valid
    dp = &(s2->d[0]);   // valid
    *dp = 42;           // undefined behavior
\end{lstlisting}

\paragraph{}
赋值：
\begin{lstlisting}
    *s1 = *s2;
\end{lstlisting}
仅拷贝成员\tm{n}；如果任何数组元素在结构的初始\tm{sizeof (struct s)}字节内，则它
们可能被拷贝，或仅被覆盖成不确定值。

\paragraph{}
\ex 因为匿名结构和联合的成员被认为是包含结构或联合的成员，所以以下示例中的
\tm{struct s}具有多于一个命名成员，因此灵活数组成员的使用是合法的：
\begin{lstlisting}
    struct s {
      struct { int i; };
      int a[];
    };
\end{lstlisting}

\fwdref{6.7.6，6.7.2.3}

                                         \sssect{枚举说明符}{lang.dcl.type.enum}
\syntax
\paragraph{}
\synsym{enum-specifier}
  \synprd{\tm{enum} \nt{identifier\tsub{opt}} \tm{\{} \nt{enumerator-list} \tm{\}}}
  \synprd{\tm{enum} \nt{identifier\tsub{opt}} \tm{\{} \nt{enumerator-list} \tm{,\}}}
  \synprd{\tm{enum} \nt{identifier}}
\synsym{enumerator-list}
  \synprd{\nt{enumerator}}
  \synprd{\nt{enumerator-list} \tm{,} \nt{enumerator}}
\synsym{enumerator}
  \synprd{\nt{enumeration-constant}}
  \synprd[]{\nt{enumeration-constant} \tm{=} \nt{constant-expression}}

\constraint
\paragraph{}
定义枚举常量值的表达式应为整型常量表达式，其值可用\tm{int}表示。

\semantic
\paragraph{}
枚举子列表中的标识符声明为具有\tm{int}类型的常量，并且可以出现在常量允许的位置。
\footnote{因此，在同一作用域内声明的枚举常量的标识符应彼此不同，并且与普通声明子
中声明的其他标识符不同。} 带\tm{=}的枚举子将其枚举常量定义为常量表达式的值。如果
第一个枚举子没有\tm{=}，则其枚举常量的值为0。每个后续的不带\tm{=}的枚举子将其枚
举常量定义为通过将1加上前一个枚举常量的值而获得的常量表达式的值。（枚举子与
\tm{=}的使用可能会产生与同一枚举中的其他值重复的枚举常量。）枚举的枚举子也称为其
成员。

\paragraph{}
每个枚举类型应与\tm{char}，有符号整型或无符号整型兼容。类型的选择由实现定义，
\footnote{实现可以直到看到所有枚举常量再决定使用哪个整型。} 但是应该能够表示枚举
的所有成员的值。枚举类型在终止枚举子声明列表的\tm{\}}之前是不完整的，之后成为完
整类型。

\paragraph{}
\ex* 以下代码断：
\begin{lstlisting}
    enum hue { chartreuse, burgundy, claret=20, winedark };
    enum hue col, *cp;
    col = claret;
    cp = &col;
    if (*cp != burgundy)
      /* ... */
\end{lstlisting}
声明\tm{hue}为枚举标签，随后声明\tm{col}为具有该类型的对象，\tm{cp}为指向具有该
类型的对象指针。枚举值为集合$\{0, 1, 20, 21\}$。

\fwdref{6.7.2.3}

                                            \sssect{标签Tags}{lang.dcl.type.tag}
\constraint
\paragraph{}
特定类型的内容最多只能定义一次。

\paragraph{}
如果使用相同标签的两个声明声明的是相同的类型，则应选择使用相同的\tm{struct}，
\tm{union}或\tm{enum}。

\paragraph{}
形如                                                                          \\
\mbox{\hspace{4em}\tm{enum} \nt{identifier}}                                  \\
的不带枚举子列表的类型说明符应该仅在其所说明类型完整之后出现。

\semantic
\paragraph{}
具有相同作用域并使用相同标签的结构，联合或枚举类型的所有声明都声明相同的类型。无
论在同一翻译单元中是否存在标签或该类型的其他声明，直到定义内容的列表的右括号之前
该类型都是不完整的，\footnote{只有在不需要该类型的对象的大小时才可以使用不完整类
型。例如，当类型定义名称声明为结构或联合的说明符，或者声明指向返回结构或联合的函
数的指针时，则不需要它。（见\ref{lang.concept.type}中的不完整类型。）在调用或定
义此类函数之前则必须完整。} 并在之后成为完整类型。

\paragraph{}
对于位于不同作用域或使用不同标签的结构，联合或枚举类型的声明均声明不同的类型。不
包含标签的结构，联合或枚举类型的每个声明都声明不同的类型。

\paragraph{}
形如                                                                          \\
\mbox{\hspace{4em}\nt{struct-or-union identifier\tsub{opt}} \tm{\{}
  \nt{struct-declaration-list} \tm{\}}}                                       \\
或                                                                            \\
\mbox{\hspace{4em}\tm{enum} \nt{identifier\tsub{opt}} \tm{\{}
  \nt{enumerator-list} \tm{\}}}                                               \\
或                                                                            \\
\mbox{\hspace{4em}\tm{enum} \nt{identifier\tsub{opt}} \tm{\{}
  \nt{enumerator-list} \tm{, \}}}                                             \\
的类型说明符声明结构，联合或枚举类型。该列表定义了\textit{结构内容}，
\textit{联合内容}或\textit{枚举内容}。如果提供了标识符，\footnote{如果不存在标识
符，则翻译单元内的类型只能通过其所属的声明来引用。当然，当声明是类型定义名称时，
后续声明可以使用该类型定义名称来声明具有指定结构，联合或枚举类型的对象。} 则类型
说明符同时声明了该标识符为该类型的标签。

\paragraph{}
形如                                                                          \\
\mbox{\hspace{4em}\nt{struct-or-union identifier} \tm{;}}                     \\
的声明说明了一个结构或联合并声明标识符为该类型的标签。\footnote{类似的\tm{enum}
构造不存在。\label{no-enum}}

\paragraph{}
如果形如                                                                      \\
\mbox{\hspace{4em}\nt{struct-or-union identifier}}                            \\
的类型说明符不是作为上述形式之一的一部分而出现，且没有其他标识符声明可见，则它声
明一个不完整的结构或联合类型，并将标识符声明为该类型的标记。\tsup{\ref{no-enum}}

\paragraph{}
如果形如                                                                      \\
\mbox{\hspace{4em}\nt{struct-or-union identifier}}                            \\
或                                                                            \\
\mbox{\hspace{4em}\tm{enum} \nt{identifier}}                                  \\
的类型说明符不是作为上述形式之一的一部分而出现，并且有一个作为标签的标识符声明可
见，则它说明了与该声明相同的类型，并不重新声明该标签。

\paragraph{}
\ex 该机制允许自引用结构的声明。
\begin{lstlisting}
    struct tnode {
      int count;
      struct tnode *left, *right;
    };
\end{lstlisting}
说明了包含一个整型和两个指向同类型对象的指针。一旦给定该声明，以下声明
\begin{lstlisting}
    struct tnode s, *sp;
\end{lstlisting}
声明\tm{s}为给定类型的对象，\tm{sp}为给定类型对象的指针。对于这些声明，表达式
\tm{sp->left}引用\tm{sp}所指对象的左\tm{struct tnode}指针；表达式
\tm{s.right->count}指代\tm{s}所指对象的右\tm{struct tnode}的\tm{count}成员。

\paragraph{}
以下可选形式使用\tm{typedef}机制：
\begin{lstlisting}
    typedef struct tnode TNODE;
    struct tnode {
      int count;
      TNODE *left, *right;
    };
    TNODE s, *sp;
\end{lstlisting}

\paragraph{}
\ex 为了说明使用先前声明的标记来指定一对相互引用的结构，声明
\begin{lstlisting}
    struct s1 { struct s2 *s2p; /* ... */ }; // D1
    struct s2 { struct s1 *s1p; /* ... */ }; // D2
\end{lstlisting}
指定一对包含彼此指针的结构。但请注意，如果\tm{s2}已经在包含作用域内声明为标记，
则声明\tm{D1}将引用\textit{它}，而不是引用\tm{D2}中声明的标记\tm{s2}。为了消除这
种上下文敏感性，声明
\begin{lstlisting}
    struct s2;
\end{lstlisting}
可以插到\tm{D1}之前。这在内作用域中声明了一个新标签\tm{s2}；声明\tm{D2}随后完成
新类型规范。

\fwdref{6.7.6，6.7.8}

                                     \sssect{原子类型说明符}{lang.dcl.type.atom}
\syntax
\paragraph{}
\synsym{atomic-type-specifier}
  \synprd[]{\tm{\_Atomic (} \nt{type-name} \tm{)}}

\constraint
\paragraph{}
如果实现不支持原子类型，则不应该使用原子类型说明符（见
\ref{lang.ppdir.predef.cond}）。

\paragraph{}
原子类型说明符中的类型名称不应引用数组类型，函数类型，原子类型或限定类型。

\semantic
\paragraph{}
与原子类型关联的属性仅对左值表达式有意义。如果\tm{\_Atomic}关键字后紧跟左括号，
则将其解释为类型说明符（具有类型名称），而不是类型限定符。

                                                 \ssect{类型限定}{lang.dcl.qual}
\syntax
\paragraph{}
\synsym{type-qualifier}
  \synprd{\tm{const}}
  \synprd{\tm{restrict}}
  \synprd{\tm{volatile}}
  \synprd[]{\tm{\_Atomic}}

\constraint
\paragraph{}
引用类型为对象类型的指针类型以外的类型不应使用restrict限制。

\paragraph{}
使用\tm{\_Atomic}限定符修改的类型不应是数组类型或函数类型。

\semantic
\paragraph{}
限定类型所关联属性仅对左值表达式有意义。\footnote{实现可能将非\tm{volatile}的
\tm{const}对象放置在只读存储区域中。此外，如果从不使用其地址，则实现不需要为这样
的对象分配存储。}

\paragraph{}
如果同一个限定符或直接或通过一个或多个\tm{typedef}在同一个
\nt{specifier-qualifier-list}中出现多次，则行为与它只出现一次相同。 如果其他限定
符与\nt{specifier-qualifier-list}中的\tm{\_Atomic}限定符一起出现，则结果类型是如
此限定的原子类型。

\paragraph{}
如果尝试通过使用具有非const限定类型的左值来修改使用const限定类型定义的对象，则行
为未定义。如果尝试通过使用具有非volatile限定类型的左值来引用使用volatile限定类型
定义的对象，则行为未定义。\footnote{这适用于那些表现为使用限定类型定义的对象，即
使它们实际上从未被定义为程序中的对象（例如内存映射输入/输出地址处的对象）。}

\paragraph{}
具有volatile限定类型的对象可能以实现未知的方式进行修改，或者具有其他未知副作用。
因此，任何引用这种对象的表达式都应严格按照抽象机的规则进行计算，如
\ref{env.concept.exec.exec}所述。此外，在每个序列点，最后存储在对象中的值应与抽
象机器规定的值一致，除非由前面提到的未知因素修改。\footnote{\tm{volatile}声明可
用于描述与存储器映射的输入/输出端口相对应的对象或由异步中断功能访问的对象。对如
此声明的对象操作不应由实现``优化''或重新排序，除非计算表达式的规则允许。}
volatile限定类型对象的访问的构成由实现定义。

\paragraph{}
通过restrict限定的指针访问的对象与该指针具有特殊关联。在下面的
\ref{lang.dcl.qual.restrict}中定义，此关联要求对该对象的所有访问都直接或间接使用
该特定指针的值。\footnote{例如，将\tm{malloc}返回的值赋给单个指针的语句在分配的
对象和指针之间建立了这种关联。} \tm{restrict}限定符（如\tm{register}存储类）的预
期用途是促进优化，并且从构成符合程序的所有预处理翻译单元中删除限定符的所有实例不
会改变其含义（即可观察行为）。

\paragraph{}
如果数组类型的规范包括任何类型限定符，则元素类型是如此限定的，而不是数组类型。 
如果函数类型的规范包括任何类型限定符，则行为未定义。\footnote{这两种情况都可以通
过使用\tm{typedef}出现。}

\paragraph{}
要使两种限定类型兼容，两者都应具有兼容类型的等价限定; 说明符或限定符列表中类型限
定符的顺序不会影响指定的类型。

\paragraph{}
\ex 定义为
\begin{lstlisting}
    extern const volatile int real_time_clock;
\end{lstlisting}
的对象可以被硬件修改，但不能赋值，自增或自减。

\paragraph{}
\ex 以下声明和表达式说明了类型限定符修改聚合类型时的行为：
\begin{lstlisting}
    const struct s { int mem; } cs = { 1 };
    struct s ncs;     // the object ncs is modifiable
    typedef int A[2][3];
    const A a = {{4, 5, 6}, {7, 8, 9}}; // array of array of const int
    int *pi;
    const int *pci;

    ncs = cs;         // valid
    cs = ncs;         // violates modifiable lvalue constraint for =
    pi = &ncs.mem;    // valid
    pi = &cs.mem;     // violates type constraints for =
    pci = &cs.mem;    // valid
    pi = a[0];        // invalid: a[0] has type ``const int *''
\end{lstlisting}

\paragraph{}
\ex 声明
\begin{lstlisting}
    _Atomic volatile int *p;
\end{lstlisting}
说明\tm{p}具有``指向原子\tm{volatile int}的指针''类型，即一个指向volatile限定原
子类型的指针。

                             \sssect{restrict的形式定义}{lang.dcl.qual.restrict}
\paragraph{}
设\tm{D}是普通标识符的声明，它提供了一种将对象\tm{P}指定为类型\tm{T}的restrict限
定指针的方法。

\paragraph{}
如果\tm{D}出现在块内并且没有存储类\tm{extern}，则让\tm{B}表示该块。 如果\tm{D}出
现在函数定义的参数声明列表中，则让B表示关联的块。否则，让\tm{B}表示\tm{main}的块
（或者在独立环境中在程序启动时调用的任何函数的块）。

\paragraph{}
在下文中，指针表达式\tm{E}被称为\textit{基于}对象\tm{P}，如果（在计算\tm{E}之前
执行\tm{B}中的某个序列点）修改\tm{P}以指向其先前指向的数组对象的副本将改变\tm{E}
的值。\footnote{换句话说，\tm{E}取决于\tm{P}本身的值而不是通过\tm{P}间接引用的对
象值。例如，如果标识符\tm{p}具有类型\tm{(int **restrict)}，则指针表达式\tm{p}和
\tm{p+1}是基于由\tm{p}指定的受限指针对象，但指针表达式\tm{*p}和\tm{p[1]}不是。}
注意``基于''仅为具有指针类型的表达式定义。

\paragraph{}
在每次执行\tm{B}期间，设\tm{L}为任何左值，使得\tm{\&L}基于\tm{P}。如果\tm{L}用于
访问它指定的对象\tm{X}的值，并且\tm{X}也被修改（通过任何方式），则以下要求适用：
\tm{T}不应该是const限定的。用于访问\tm{X}值的每个其他左值也应具有基于\tm{P}的地
址。出于本节的目的，每次修改\tm{X}的访问也应被视为修改\tm{P}。如果为\tm{P}分配了
指针表达式\tm{E}的值，该指针表达式\tm{E}基于与块\tm{B2}相关联的另一个受限指针对
象{P2}，则\tm{B2}的执行应在执行\tm{B}之前开始，或\tm{B2}的执行应在赋值之前结束。
如果不满足这些要求，则行为未定义。

\paragraph{}
这里执行\tm{B}意味着程序的执行部分将对应于具有标量类型的对象的生命周期和与\tm{B}
相关联的自动存储期。

\paragraph{}
翻译器可以自由地忽略使用\tm{restrict}的任何或所有别名含义。

\paragraph{}
\ex 文件作用域声明
\begin{lstlisting}
    int * restrict a;
    int * restrict b;
    extern int c[];
\end{lstlisting}
断言如果使用\tm{a}，\tm{b}或\tm{c}中的一个访问对象，并且该对象在程序中的任何位置
被修改，则永远不会使用其他两个中的任何一个来访问它。

\paragraph{}
\ex 下例中的函数参数声明
\begin{lstlisting}
    void f(int n, int * restrict p, int * restrict q)
    {
      while (n-- > 0)
      *p++ = *q++;
    }
\end{lstlisting}
断言如果在每次执行函数期间通过其中一个指针参数访问对象，则不会通过另一个访问它。

\paragraph{}
\tm{restrict}限定符的好处是使翻译器能够对函数\tm{f}进行有效的依赖性分析，而无需
检查程序中\tm{f}的任何调用。成本是程序员必须检查所有这些调用以确保没有给出未定义
行为。例如，\tm{g}中\tm{f}的第二次调用具有未定义行为，因为\tm{d[1]}到\tm{d[49]}
中的每一个都通过\tm{p}和\tm{q}访问。
\begin{lstlisting}
    void g(void)
    {
        extern int d[100];
        f(50, d + 50, d); // valid
        f(50, d + 1, d);  // undefined behavior
    }
\end{lstlisting}

\paragraph{}
\ex 函数参数声明
\begin{lstlisting}
    void h(int n, int * restrict p, int * restrict q, int * restrict r)
    {
        int i;
        for (i = 0; i < n; i++)
            p[i] = q[i] + r[i];
      }
\end{lstlisting}
说明如何通过两个受限指针对未修改的对象进行别名化。特别地，如果\tm{a}和\tm{b}是不
相交的数组，则形式\tm{h(100, a, b, b)}的调用有定义行为，因为在函数\tm{h}内没有修
改数组\tm{b}。

\paragraph{}
\ex 限制受限指针之间的赋值的规则不区分函数调用和等效嵌套块。除了一个例外，只有在
嵌套块中声明的受限指针之间``由外到内''的赋值具有定义行为。
\begin{lstlisting}
    {
        int * restrict p1;
        int * restrict q1;
        p1 = q1; // undefined behavior
        {
            int * restrict p2 = p1; // valid
            int * restrict q2 = q1; // valid
            p1 = q2;                // undefined behavior
            p2 = q2;                // undefined behavior
        }
    }
\end{lstlisting}

\paragraph{}
该例外允许限制指针的值从该块执行，当该块完成执行时它（或者更确切地说，用于指定它
的普通标识符）被声明。例如这允许\tm{new\_vector}返回一个\tm{vector}。
\begin{lstlisting}
    typedef struct { int n; float * restrict v; } vector;
    vector new_vector(int n)
    {
        vector t;
        t.n = n;
        t.v = malloc(n * sizeof (float));
        return t;
    }
\end{lstlisting}

                                                \ssect{函数说明符}{lang.dcl.fct}
\syntax
\paragraph{}
\synsym{function-specifier}
  \synprd{\tm{inline}}
  \synprd[]{\tm{\_Noreturn}}

\constraint
\paragraph{}
函数说明符只能在函数标识符的声明中使用。

\paragraph{}
具有外部链接的函数的内联定义不应包含具有静态或线程存储期的可修改对象的定义，并且
不应包含对具有内部链接的标识符的引用。

\paragraph{}
在宿主环境中，\tm{main}的声明中不应出现任何函数说明符。

\semantic
\paragraph{}
函数说明符可能出现多次; 其行为与它只出现一次相同。

\paragraph{}
使用\tm{inline}函数说明符声明的函数是\textit{内联函数}。 使函数成为内联函数表明
对函数的调用尽可能快。\footnote{例如，通过使用通常的函数调用机制的替代方法，例如
``内联替换''。内联替换不是文本替换，也不创建新函数。因此，例如在函数体内使用的
宏的扩展使用它在函数体出现时的定义，而不是调用函数的位置；且标识符引用的是函数体
作用域内的声明。同样，该函数具有单个地址，而不管除外部定义之外还发生的内联定义的
数量。} 建议的有效程度由实现定义。\footnote{例如，实现可能永远不会执行内联替换，
或者可能只对\tm{inline}声明作用域内的调用执行内联替换。}

\paragraph{}
具有内部链接的任何函数都可以是内联函数。对于具有外部链接的函数，以下限制适用：如
果使用\tm{inline}函数说明符声明函数，则它也应在同一翻译单元中定义。如果转换单元
中函数的所有文件作用域声明都包含不带\tm{extern}的\tm{inline}函数说明符，则该翻译
单元中的定义是\textit{内联定义}。内联定义不提供函数的外部定义，也不禁止另一个翻译
单元中的外部定义。内联定义提供了外部定义的替代，翻译器可以使用该定义在同一翻译单
元中实现对该函数的任何调用。未指定对函数的调用是使用内联定义还是外部定义。
\footnote{由于内联定义不同于相应的外部定义以及其他翻译单元中的任何其他对应内联定
义，因此具有静态存储期的所有相应对象在每个定义中也是不同的。}

\paragraph{}
使用\tm{\_Noreturn}函数说明符声明的函数不应返回其调用者。

\recprac
\paragraph{}
实现应为使用\tm{\_Noreturn}函数说明符声明但可能返回其调用者的函数生成诊断消息。

\paragraph{}
\ex 具有外部链接的内联函数声明可以产生外部定义或可用于仅在翻译单元内使用的定义。
带\tm{extern}的文件作用域声明会创建外部定义。 以下示例显示一个完整翻译单元。
\begin{lstlisting}
    inline double fahr(double t)
    {
        return (9.0 * t) / 5.0 + 32.0;
    }
    inline double cels(double t)
    {
        return (5.0 * (t - 32.0)) / 9.0;
    }
    extern double fahr(double); // creates an external definition
    double convert(int is_fahr, double temp)
    {
        /* A translator may perform inline substitutions */
        return is_fahr ? cels(temp) : fahr(temp);
    }
\end{lstlisting}

\paragraph{}
注意\tm{fahr}的定义是外部定义，因为\tm{fahr}也是用\tm{extern}声明的，但\tm{cels}
的定义是内联定义。由于\tm{cels}具有外部链接并被引用，因此外部定义必须出现在另一
个翻译单元中（见\ref{lang.extn}）；内联定义和外部定义是不同的且任一个都可能用于
调用。

\paragraph{}
\ex
\begin{lstlisting}
    _Noreturn void f () {
        abort(); // ok
    }
    _Noreturn void g (int i) { // causes undefined behavior if i <= 0
        if (i > 0) abort();
    }
\end{lstlisting}

\fwdref{6.9.1}

                                              \ssect{对齐说明符}{lang.dcl.align}
\syntax
\paragraph{}
\synsym{alignment-specifier}
  \synprd{\tm{\_Alignas (} \nt{type-name} \tm{)}}
  \synprd[]{\tm{\_Alignas (} \nt{constant-expression} \tm{)}}

\constraint
\paragraph{}
不应在类型定义，位字段，函数，参数或使用\tm{register}存储类说明符声明的对象声明
中指定对齐属性。

\paragraph{}
常量表达式应为整型常量表达式。它应计算为有效基本对齐，或者为其出现的上下文中由实
现支持的有效扩展对齐，或者为零。

\paragraph{}
声明中所有对齐属性的组合效果不得指定比声明的对象或成员类型所需对齐更宽松的对齐。

\semantic
\paragraph{}
第一种形式等价于\tm{\_Alignas (\_Alignof (}\nt{type-name}\tm{))}。

\paragraph{}
声明的对象或成员的对齐要求被视为指定的对齐。零对齐没有效果。\footnote{零对齐也不
会影响同一声明中的其他对齐规范。} 当声明中出现多个对齐说明符时，有效的对齐要求是
指定的最严格对齐。

\paragraph{}
如果对象的定义具有对齐说明符，则该对象的任何其他声明都应指定等效对齐或没有对齐说
明符。如果对象的定义没有对齐说明符，则该对象的任何其他声明也应没有对齐说明符。如
果不同翻译单元中的对象声明具有不同的对齐说明符，则该行为未定义。

                                                   \ssect{声明子}{lang.dcl.decl}
\syntax
\paragraph{}
\synsym{declarator}
  \synprd{\nt{pointer\tsub{opt} direct-declarator}}
\synsym{direct-declarator}
  \synprd{\nt{identifier}}
  \synprd{\tm{(} \nt{declarator} \tm{)}}
  \synprd{\nt{direct-declarator} \tm{[} \nt{type-qualifier-list\tsub{opt}
    assignment-expression\tsub{opt}} \tm{]}}
  \synprd{\nt{direct-declarator} \tm{[ static} \nt{type-qualifier-list\tsub{opt}
    assignment-expression} \tm{]}}
  \synprd{\nt{direct-declarator} \tm{[} \nt{type-qualifier-list} \tm{static}
    \nt{assignment-expression} \tm{]}}
  \synprd{\nt{direct-declarator} \tm{[} \nt{type-qualifier-list\tsub{opt}}
    \tm{*]}}
  \synprd{\nt{direct-declarator} \tm{(} \nt{parameter-type-list} \tm{)}}
  \synprd{\nt{direct-declarator} \tm{(} \nt{identifier-list\tsub{opt}} \tm{)}}
\synsym{pointer}
  \synprd{\tm{*} \nt{type-qualifier-list\tsub{opt}}}
  \synprd{\tm{*} \nt{type-qualifier-list\tsub{opt} pointer}}
\synsym{type-qualifier-list}
  \synprd{\nt{type-qualifier}}
  \synprd{\nt{type-qualifier-list type-qualifier}}
\synsym{parameter-type-list}
  \synprd{\nt{parameter-list}}
  \synprd{\nt{parameter-list} \tm{, ...}}
\synsym{parameter-list}
  \synprd{\nt{parameter-declaration}}
  \synprd{\nt{parameter-list} \tm{,} \nt{parameter-declaration}}
\synsym{parameter-declaration}
  \synprd{\nt{declaration-specifiers declarator}}
  \synprd{\nt{declaration-specifiers abstract-declarator\tsub{opt}}}
\synsym{identifier-list}
  \synprd{\nt{identifier}}
  \synprd{\nt{identifier-list} \tm{,} \nt{identifier}}

\semantic
\paragraph{}
每一个声明子声明一个标识符，并断言当一个和声明同形式的操作数出现在表达式中时它代
表的是带有由声明说明符所指示作用域、存储期和类型的对象或函数。

\paragraph{}
\textit{全声明子}是不属于另一声明子的声明子。全声明子的结尾是一个序列点。如果在
全声明子中，声明子的嵌套序列中存在指定变长数组类型的声明子，则称全声明子指定的类
型是变量修改的。此外，由声明子类型派生自变量修改类型的任何类型本身都是变量修
改的。

\paragraph{}
后续子章节中，考虑声明                                                          \\
\mbox{\hspace{4em}\tm{T D1}}                                                  \\
\tm{T}包含指定类型\textit{T}的声明说明符（比如\tm{int}），\tm{D1}是一个声明子，
包括一个标识符\textit{ident}。在各种形式的声明子中，为标识符\textit{ident}指定的
类型使用此符号进行归纳描述。

\paragraph{}
如果在声明``\tm{T D1}''中，\tm{D1}形如                                        \\
\mbox{\hspace{4em}\nt{identifier}}                                            \\
则为\textit{ident}所指定的类型为\textit{T}。

\paragraph{}
如果在声明``\tm{T D1}''中，\tm{D1}形如                                        \\
\mbox{\hspace{4em}\tm{(} \nt{identifier} \tm{)}}                              \\
\textit{ident}具有由声明``\tm{T D}''所指定的类型。因此，括号中的声明子与无括号声
明符相同，但复杂声明子的绑定可以用括号改变。

\implimit
\paragraph{}
如\ref{env.env.limit.trans}所述，实现可以限制直接或通过一个或多个\tm{typedef}修
改算术、结构、联合或\tm{void}类型的指针、数组和函数声明子的数量。

\fwdref{6.7.6.2，6.7.8}

                                          \sssect{指针声明子}{lang.dcl.decl.ptr}
\semantic
\paragraph{}
如果在声明``\tm{T D1}''中，\tm{D1}形如                                        \\
\mbox{\hspace{4em}\tm{*} \nt{type-qualifier-list\tsub{opt}} \tm{D}}           \\
且声明``\tm{T D}''中为\textit{ident}所指定类型是
``\nt{derived-declarator-type-list T}''，那么为\textit{ident}所指定的类型为
``指向\nt{derived-declarator-type-list type-qualifier-list}的\textit{T}的指针''。
对列表中的每一个类型限定符，\textit{ident}是如此限定的指针。

\paragraph{}
要使两种指针类型兼容，两者都应具有相同的限定，且都应是指向兼容类型的指针。

\paragraph{}
\ex* 以下声明展示了``指向常量的指针变量''和``指向变量的指针常量''之间的区别。
\begin{lstlisting}
    const int *ptr_to_constant;
    int *const constant_ptr;
\end{lstlisting}
由\tm{ptr\_to\_constant}指向的任何对象的内容不应通过该指针修改，
但\tm{ptr\_to\_constant}本身可以更改以指向另一个对象。类似地，\tm{constant\_ptr}
指向的\tm{int}的内容可以修改，但\tm{constant\_ptr}本身应始终指向相同的位置。

\paragraph{}
指针常量\tm{constant\_ptr}的声明可以通过包含``指向\tm{int}的指针''的类型定义来澄
清。
\begin{lstlisting}
    typedef int *int_ptr;
    const int_ptr constant_ptr;
\end{lstlisting}
声明\tm{constant\_ptr}为对象，具有类型``const限定的指向\tm{int}的指针''。

                                        \sssect{数组声明子}{lang.dcl.decl.array}
\constraint
\paragraph{}
除了可选的类型限定符和关键字\tm{static}之外，\tm{[}和\tm{]}还可以分隔表达式或
\tm{*}。如果它们分隔表达式（指定数组的大小），则表达式应具有整型。如果表达式是常
量表达式，则其值应大于零。元素类型不得为不完整或函数类型。可选的类型限定符和关键
字\tm{static}只能出现在具有数组类型的函数参数声明中，且只能出现在最外层的数组类
型派生中。

\paragraph{}
如果标识符被声明为具有变量修改类型，则它应为普通标识符（如
\ref{lang.concept.namespace}中所定义），没有链接，并且具有块作用域或函数原型作用
域。如果标识符声明为具有静态或线程存储期的对象，则它不应具有变长数组类型。

\semantic
\paragraph{}
如果在声明``\tm{T D1}''中，\tm{D1}形如以下                                    \\
\mbox{\hspace{4em}\tm{D[} \nt{type-qualifier-list\tsub{opt}
  assignment-expression\tsub{opt}} \tm{]}}                                    \\
\mbox{\hspace{4em}\tm{D[static} \nt{type-qualifier-list\tsub{opt}
  assignment-expression} \tm{]}}                                              \\
\mbox{\hspace{4em}\tm{D[} \nt{type-qualifier-list} \tm{static}
  \nt{assignment-expression} \tm{]}}                                          \\
\mbox{\hspace{4em}\tm{D[} \nt{type-qualifier-list\tsub{opt}} \tm{*]}}         \\
之一，且声明``\tm{T D}''中为\textit{ident}所指定类型是
``\nt{derived-declarator-type-list T}''，那么为\textit{ident}所指定的类型为
``\nt{derived-declarator-type-list type-qualifier-list}的\textit{T}的数组''。
\footnote{多个相邻的``...的数组''规范定义多维数组。} （见\ref{lang.dcl.decl.fct}
关于可选类型限定符和关键字\tm{static}的涵义。）

\paragraph{}
如果不存在大小，则数组类型是不完整类型。如果该大小是\tm{*}而不是表达式，则数组类
型是一个未指定大小的\textit{变长数组}类型，只能在具有函数原型作用域的声明或
类型名称中使用；\footnote{因此，\tm{*}只能用于非定义的函数声明中
（见\ref{lang.dcl.decl.fct}）。} 此类数组仍然是完整的类型。如果大小是整型常量表
达式，并且元素类型具有已知的常量大小，则数组类型不是变长数组类型；否则，数组
类型是\textit{变长数组}类型。（变长数组是条件特性，不要求实现支持；见
\ref{lang.ppdir.predef.cond}。）

\paragraph{}
如果大小为非整型常量表达式的表达式：如果它出现在函数原型作用域的声明中，则将其视
为被\tm{*}替换；否则，每次计算它时，其值都应大于零。变长数组类型的每个实例的
大小在其生命期内不会更改。如果大小表达式是\tm{sizeof}运算符的操作数的一部分，并
且更改大小表达式的值不会影响运算符的结果，则未指定是否计算大小表达式。

\paragraph{}
要使两个数组类型兼容，两个数组类型都应具有兼容的元素类型，如果两个大小说明符都存
在，并且是整型常量表达式，则两个大小说明符应具有相同的常量值。如果两个数组类型在
要求它们兼容的上下文中使用，且如果两个大小说明符的值不相等，则行为未定义。

\paragraph{}
\ex
\begin{lstlisting}
    float fa[11], *afp[17];
\end{lstlisting}
声明\tm{float}数字数组和\tm{float}数字指针的数组。

\paragraph{}
\ex 注意以下声明间的区别
\begin{lstlisting}
    extern int *x;
    extern itn y[];
\end{lstlisting}
第一个声明\tm{x}为指向\tm{int}的指针；第二个声明\tm{y}为未指定大小（不完整类型）
的\tm{int}的数组，其存储在别处定义。

\paragraph{}
\ex 以下声明展示变量修改类型的兼容规则。
\begin{lstlisting}
    extern int n;
    extern int m;
    void fcompat(void)
    {
        int a[n][6][m];
        int (*p)[4][n+1];
        int c[n][n][6][m];
        int (*r)[n][n][n+1];
        p = a; // invalid: not compatible because 4 != 6
        r = c; // compatible, but defined behavior only if
               // n == 6 and m == n+1
    }
\end{lstlisting}

\paragraph{}
\ex 变量修改（VM）类型的所有声明都必须在块作用域或函数原型作用域内。使用
\tm{\_Thread\_local}、\tm{static}或\tm{extern}存储类说明符声明的数组对象不能具有
变长数组（VLA）类型。但是，使用\tm{static}存储类说明符声明的对象可以具有VM类
型（即指向VLA类型的指针）。最后，用VM类型声明的所有标识符必须是普通标识符，因此
不能是结构或联合的成员。
\begin{lstlisting}
    extern int n;
    int A[n];                      // invalid: file scope VM
    extern int (*p2)[n];           // invalid: file scope VLA
    int B[100];                    // valid: file scope but not VM
    void fvla(int m, int C[m][m]); // valid: VLA with prototype scope
    void fvla(int m, int C[m][m])  // valid: adjusted to auto pointer to VLA
    {
        typedef int VLA[m][m];     // valid: block scope typedef VLA
        struct tag {
            int (*y)[n];           // invalid: y not ordinary identifier
            int z[n];              // invalid: z not ordinary identifier
        };
        int D[m];                  // valid: auto VLA
        static int E[m];           // invalid: static block scope VLA
        extern int F[m];           // invalid: F has linkage and is VLA
        int (*s)[m];               // valid: auto pointer to VLA
        extern int (*r)[m];        // invalid: r has linkage and points to VLA
        static int (*q)[m] = &B;   // valid: q is a static block pointer to VLA
    }
\end{lstlisting}

\fwdref{6.7.6.3，6.9.1，6.7.9}

                                \sssect{函数声明子（含原型）}{lang.dcl.decl.fct}
\constraint
\paragraph{}
函数声明子不应指定函数类型或数组类型的返回类型。

\paragraph{}
参数声明中唯一可以出现的存储类说明符是\tm{register}。

\paragraph{}
不是函数定义的函数声明子中标识符列表应为空。

\paragraph{}
调整后，函数定义的函数声明子中的参数类型列表中的参数不应具有不完整的类型。

\semantic
\paragraph{}
如果在声明``\tm{T D1}''中，\tm{D1}形如                                        \\
\mbox{\hspace{4em}\tm{D(} \nt{parameter-type-list} \tm{)}}                    \\
或                                                                            \\
\mbox{\hspace{4em}\tm{D(} \nt{identifier-list\tsub{opt}} \tm{)}}              \\
且声明``\tm{T D}''中为\textit{ident}所指定类型是
``\nt{derived-declarator-type-list T}''，那么为\textit{ident}所指定的类型为
``返回\textit{T}的\nt{derived-declarator-type-list}的函数''。

\paragraph{}
参数类型列表指定函数参数的类型，并可以声明函数参数的标识符。

\paragraph{}
将参数声明为``...\textit{类型}的数组''应调整为``指向...\textit{类型}的限定指针''
，其中类型限定符（如果有）是数组类型派生的\tm{[}和\tm{]}中指定的限定符。如果关键
字\tm{static}也出现在数组类型派生的\tm{[}和\tm{]}中，那么对于对函数的每次调用，
相应的实际参数的值应提供对数组的第一个元素的访问，其中至少有大小表达式指定的元素
数。

\paragraph{}
参数声明为``返回...\textit{类型}的函数''应该调整为``指向返回...\textit{类型}的函
数指针''，如\ref{lang.conv.other.desig}中所述。

\paragraph{}
如果列表以省略号（\tm{, ...}）结尾，则在逗号后，不提供参数的数量或类型信息。
\footnote{\tm{<stdarg.h}>头（\ref{lib.vararg}）中定义的宏可用于访问与省略号相对
应的参数。}

\paragraph{}
一种特殊情况是\tm{void}类型的未命名参数作为列表中的唯一项，指明函数无参数。

\paragraph{}
如果在参数声明中，既可以将标识符视为类型定义名称，也可以当成参数名称，则应将其视
为类型定义名称。

\paragraph{}
如果函数声明子不是该函数定义的一部分，则参数的类型可能不完整，并且可以在声明子说
明符序列中使用\tm{[*]}符号来指定变长数组类型。

\paragraph{}
参数声明的声明说明符中的存储类说明符（如果存在）将被忽略，除非声明的参数是函数定
义的参数类型列表的成员之一。

\paragraph{}
标识符列表只声明函数参数的标识符。作为函数定义的一部分的函数声明子中的空列表指定
该函数没有参数。不是该函数定义的一部分的函数声明子中的空列表指明没有提供有关参数
数量或类型的信息。\footnote{见``未来语言方向''（\ref{lang.dir.fctdecl}）。}

\paragraph{}
要使两种函数类型兼容，两者都应指定兼容的返回类型。\footnote{如果两种函数类型都是
``旧式''的，则不比较参数类型。} 此外，参数类型列表，如果两者都存在，则参数数量和
省略号终止符应一致；对应参数应具有兼容类型。如果一个类型具有参数类型列表，而另一
个类型由不是函数定义的一部分且包含空标识符列表的函数声明子指定，则参数列表不应具
有省略号终止符，并且每个参数的类型应与由应用缺省参数提升而产生的类型兼容。如果一
个类型具有参数类型列表，另一个类型由包含（可能为空）标识符列表的函数定义指定，则
两者参数数量应一致，且每个原型参数的类型应与应用缺省参数提升到相应的标识符而产生
的类型相兼容。（在确定类型兼容性和合成类型时，使用函数或数组类型声明的每个参数都
被视为具有调整后的类型，用限定类型声明的每个参数都被视为具有其声明类型的未限定版
本。）

\paragraph{}
\ex 声明
\begin{lstlisting}
    int f(void), *fip(), (*pfi)();
\end{lstlisting}
声明了一个返回\tm{int}，没有参数的函数\tm{f}，一个没有参数规范，返回指向\tm{int}
的指针的函数\tm{fip}，以及一个返回\tm{int}，没有参数规范的函数指针\tm{pfi}。比较
后两个函数尤其有用。\tm{*fip()}的绑定是\tm{*(fip())}，因此声明建议调用函数
\tm{fip}，并且表达式中的相同构造需要调用函数\tm{fip}，然后通过指针结果使用间接寻
址来生成\tm{int}。在声明子\tm{(*pfi)()}中，需要额外的括号来指示通过指向函数的指针
进行的间接寻址生成一个函数指示符，该指示符随后用于调用函数；它返回一个\tm{int}。

\paragraph{}
如果声明出现在任何函数的外部，则标识符具有文件作用域和外部链接。如果声明出现在函
数内部，则函数\tm{f}和\tm{fip}的标识符具有块作用域和内部或外部链接（取决于这些标
识符的哪个文件作用域声明可见），指针\tm{pfi}的标识符具有块作用域且没有链接。

\paragraph{}
\ex 声明
\begin{lstlisting}
    int (*apfi[3])(int *x, int *y);
\end{lstlisting}
声明了三个指向返回\tm{int}的函数指针的数组\tm{apfi}。这些函数都具有两个指向
\tm{int}的指针参数。标识符\tm{x}和\tm{y}仅为描述而声明，在\tm{apfi}声明结束时则
离开其作用域。

\paragraph{}
\ex 声明
\begin{lstlisting}
    int (*fpfi(int (*)(long), int))(int, ...);
\end{lstlisting}
声明了函数\tm{fpfi}，该函数返回指向返回\tm{int}的函数指针。函数\tm{fpfi}有两个参
数：指向返回\tm{int}的函数指针（其中一个参数类型为\tm{long int}）和\tm{int}。
\tm{fpfi}返回的指针指向具有一个\tm{int}参数并接受零个或多个任何类型的附加参数的
函数。

\paragraph{}
\ex 以下原型具有变量修改参数。
\begin{lstlisting}
    void addscalar(int n, int m,
        double a[n][n*m+300], double x);
    int main()
    {
        double b[4][308];
        addscalar(4, 2, b, 2.17);
        return 0;
    }
    void addscalar(int n, int m,
        double a[n][n*m+300], double x)
    {
        for (int i = 0; i < n; i++)
            for (int j = 0, k = n*m+300; j < k; j++)
                // a is a pointer to a VLA with n*m+300 elements
                a[i][j] += x;
    }
\end{lstlisting}

\paragraph{}
\ex 以下为兼容的函数原型声明子。
\begin{lstlisting}
    double maximum(int n, int m, double a[n][m]);
    double maximum(int n, int m, double a[*][*]);
    double maximum(int n, int m, double a[ ][*]);
    double maximum(int n, int m, double a[ ][m]);
\end{lstlisting}
以下亦是：
\begin{lstlisting}
    f(double (* restrict a)[5]);
    f(double a[restrict][5]);
    f(double a[restrict 3][5]);
    f(double a[restrict static 3][5]);
\end{lstlisting}
（注意，最后一个声明还指定任何\tm{f}的调用中的对应于\tm{a}的参数必须指向至少
5个double的三个数组中第一个的非空指针，而其他声明则不是。）

\fwdref{6.9.1，6.7.7}

                                               \ssect{类型名}{lang.dcl.typename}
\syntax
\paragraph{}
\synsym{type-name}
  \synprd{\nt{specifier-qualifier-list abstract-declarator\tsub{opt}}}
\synsym{abstract-declarator}
  \synprd{\nt{pointer}}
  \synprd{\nt{pointer\tsub{opt} direct-abstract-declarator}}
\synsym{direct-abstract-declarator}
  \synprd{\tm{(} \nt{abstract-declarator} \tm{)}}
  \synprd{\nt{direct-abstract-declarator\tsub{opt}} \tm{[}
    \nt{type-qualifier-list\tsub{opt} assignment-expression\tsub{opt}} \tm{]}}
  \synprd{\nt{direct-abstract-declarator\tsub{opt}} \tm{[ static}
    \nt{type-qualifier-list\tsub{opt} assignment-expression} \tm{]}}
  \synprd{\nt{direct-abstract-declarator\tsub{opt}} \tm{[}
    \nt{type-qualifier-list} \tm{static} \nt{assignment-expression} \tm{]}}
  \synprd{\nt{direct-abstract-declarator\tsub{opt}} \tm{[ * ]}}
  \synprd[]{\nt{direct-abstract-declarator\tsub{opt}} \tm{(}
    \nt{parameter-type-list\tsub{opt}} \tm{)}}

\semantic
\paragraph{}
在一些上下文中需要指定一个类型。通过使用\textit{类型名}来实现的，类型名在语法上
是该类型的一个函数或对象省略了标识符后的声明。\footnote{如语法所示，类型名中的空
括号被解释为``没有参数规范的函数''，而不是省略标识符周围的多余括号。}

\paragraph{}
\ex* 以下结构
\begin{lstlisting}
    (a) int
    (b) int *
    (c) int *[3]
    (d) int (*)[3]
    (e) int (*)[*]
    (f) int *()
    (g) int (*)(void)
    (h) int (*const [])(unsigned int, ...)
\end{lstlisting}
分别命名以下类型：(a) \tm{int}，(b) 指向\tm{int}的指针，(c) 指向\tm{int}的三个指
针的数组，(d) 指向三个\tm{int}的数组的指针，(e) 指向不指定个数的\tm{int}变长数组
的指针，(f) 不带参数说明的函数，返回指向\tm{int}的指针，(g) 指向不带参数，返回
\tm{int}的函数的指针和(h) 未指定大小的指向函数的常量指针的数组，每个具有一个类型
为\tm{unsigned int}的参数和一个未指定数量的其他参数，返回一个\tm{int}。

                                              \ssect{类型定义}{lang.dcl.typedef}
\syntax
\paragraph{}
\synsym{typedef-name}
  \synprd[]{\nt{identifier}}

\constraint
\paragraph{}
如果类型定义名称指定了一个变量修改类型，那么它应该具有块作用域。

\semantic
\paragraph{}
在存储类说明符为\tm{typedef}的声明中，每个声明子将标识符定义为类型定义名称，该名
称以\ref{lang.dcl.decl}中描述的方式表示为标识符指定的类型。每次按执行顺序到达类
型定义名称的声明时，都会计算与变长数组声明子关联的任何数组大小表达式。
\tm{typedef}声明不引入新类型，只引入指定类型的同义词。也就是说，在以下声明中：\\
\mbox{\hspace{4em}\tm{typedef T type\_ident;}}                                \\
\mbox{\hspace{4em}\tm{type\_ident D;}}                                        \\
\tm{type\_ident}定义为类型定义名称，类型为声明说明符中指定的\tm{T}（称为\nt{T}）
，\tm{D}中的标识符具有类型``\nt{derived-declarator-type-list T}”，其中
\nt{derived-declarator-type-list}由\tm{D}中的声明子指定。类型定义名称与普通声明
子中声明的其他标识符具有相同的命名空间。

\paragraph{}
\ex 在以下声明之后
\begin{lstlisting}
    typedef int MILES, KLICKSP();
    typedef struct { double hi, lo; } range;
\end{lstlisting}
结构
\begin{lstlisting}
    MILES distance;
    extern KLICKSP *metricp;
    range x;
    range z, *zp;
\end{lstlisting}
均为有效声明。\tm{distance}的类型是\tm{int}，\tm{metricp}的类型是``指向返回
\tm{int}，没有参数规范的函数的指针''，\tm{x}和\tm{z}的类型是指定的结构；\tm{zp}
是指向此类结构的指针。对象\tm{distance}的类型与任何其他\tm{int}对象兼容。

\paragraph{}
\ex 以下声明之后
\begin{lstlisting}
    typedef struct s1 { int x; } t1, *tp1;
    typedef struct s2 { int x; } t2, *tp2;
\end{lstlisting}
类型\tm{t1}以及\tm{tp1}所指向的类型兼容。类型\tm{t1}与类型\tm{struct s1}也兼容，
但与类型\tm{struct s2}，\tm{t2}，\tm{tp2}所指向的类型或\tm{int}不兼容。

\paragraph{}
\ex 以下模糊的结构
\begin{lstlisting}
    typedef signed int t;
    typedef int plain;
    struct tag {
        unsigned t:4;
        const t:5;
        plain r:5;
    };
\end{lstlisting}
声明了类型为\tm{signed int}的类型定义名称\tm{t}、类型为\tm{int}的类型定义名称
\tm{plain}和具有三个位字段成员的结构，一个名为\tm{t}，包含范围$[0,15]$中的值，一
个未命名的常限定位字段（如果可以访问它），可能包含范围$[-15,+15]$或$[-16,+15]$中
的值，以及一个名为\tm{r}的位字段，包含范围$[0,31]$、$[-15,+15]$或$[-16,+15]$中的
一个范围内的值。（范围的选择由实现定义。）前两个位字段声明的不同之处在于，
\tm{unsigned}是类型说明符（强制\tm{t}为结构成员的名称），而\tm{const}是类型限定
符（它修改\tm{t}，\tm{t}作为类型定义名称仍可见）。如果这些声明在内部作用域中后跟
\begin{lstlisting}
    t f(t (t));
    long t;
\end{lstlisting}
那么用类型``返回\tm{signed int}的函数，带一个类型为指向函数的指针的未命名参数，
该函数参数返回\tm{signed int}的函数，带一个类型为\tm{signed int}的未命名参数''
声明函数\tm{f}，以及类型为\tm{long int}的标识符\tm{t}。

\paragraph{}
\ex 另一方面，类型定义名称可以用来提高代码的可读性。\tm{signal}函数的以下三个声
明都指定了完全相同的类型，第一个声明不使用任何类型定义名称。
\begin{lstlisting}
    typedef void fv(int), (*pfv)(int);
    void (*signal(int, void (*)(int)))(int);
    fv *signal(int, fv *);
    pfv signal(int, pfv);
\end{lstlisting}

\paragraph{}
\ex 如果类型定义名称表示变长数组类型，则该数组长度在定义类型定义名称时确定，而不
是每次使用时：
\begin{lstlisting}
    void copyt(int n)
    {
        typedef int B[n]; // B is n ints, n evaluated now
        n += 1;
        B a;              // a is n ints, n without += 1
        int b[n];         // a and b are different sizes
        for (int i = 1; i < n; i++)
            a[i-1] = b[i];
    }
\end{lstlisting}

                                                   \ssect{初始化}{lang.dcl.init}
\syntax
\paragraph{}
\synsym{initializer}
  \synprd{\nt{assignment-expression}}
  \synprd{\tm{\{} \nt{initializer-list} \tm{\}}}
  \synprd{\tm{\{} \nt{initializer-list} \tm{, \}}}
\synsym{initializer-list}
  \synprd{\nt{designation\tsub{opt} initializer}}
  \synprd{\nt{initializer-list} \tm{,} \nt{designation\tsub{opt} initializer}}
\synsym{designation}
  \synprd{\nt{designator-list} \tm{=}}
\synsym{designator-list}
  \synprd{\nt{designator}}
  \synprd{\nt{designator-list designator}}
\synsym{designator}
  \synprd{\tm{[} \nt{constant-expression} \tm{]}}
  \synprd[]{\tm{.} \nt{identifier}}

\constraint
\paragraph{}
初始化不应尝试为未包含在被初始化实体中的对象提供值。

\paragraph{}
要初始化的实体的类型应为未知大小的数组或非变长数组类型的完整对象类型。

\paragraph{}
对于具有静态或线程存储期的对象，初始化中所有表达式都应为常量表达式或字符串文本。

\paragraph{}
如果标识符的声明具有块作用域，并且标识符具有外部或内部链接，则标识符的声明不应具
有初始化。

\paragraph{}
如果指示符具有形如                                                            \\
\mbox{\hspace{4em}\tm{[} \nt{constant-expression} \tm{]}}                     \\
则当前对象（定义见下文）应为数组类型，表达式应为整型常量表达式。如果数组的大小未
知，则任何非负值都有效。

\paragraph{}
如果指示符具有形如                                                            \\
\mbox{\hspace{4em}\tm{.} \nt{identifier}}                                     \\
则当前对象（定义见下文）应具有结构或联合类型，标识符应为该类型成员的名称。

\semantic
\paragraph{}
初始化指定存储在对象中的初始值。

\paragraph{}
除非另有明确说明，否则就本节而言，结构和联合类型对象的未命名成员不参与初始化。结
构对象的未命名成员即使在初始化之后也具有不确定的值。

\paragraph{}
如果没有显式初始化具有自动存储期的对象，则其值不确定。如果没有显式初始化具有静态
或线程存储期的对象，则：
\begin{itemize}
  \item{如果是指针类型，则初始化为零指针；}
  \item{如果是算术类型，则初始化为（正或无符号）零；}
  \item{如果是聚合类型，则根据这些规则对每个成员进行（递归）初始化，并将任何填充
    初始化为零位；}
  \item{如果是联合，则根据这些规则对第一个命名成员进行（递归）初始化，并将任何填
    充初始化为零位；}
\end{itemize}

\paragraph{}
标量初始化应是单个表达式，可选地用大括号括起来。对象的初始值是表达式（转换后）的
初始值；将标量类型作为声明类型的非限定版本，则与简单赋值相同的类型约束和转换规则
也适用于标量初始化。

\paragraph{}
本节剩余部分解释具有聚合或联合类型对象的初始化。

\paragraph{}
具有自动存储期的结构或联合对象的初始化应为如下所述的初始化列表，或具有兼容于结构
或联合类型的单个表达式。在后一种情形下，对象的初始值（包括未命名的成员）是表达式
的初始值。

\paragraph{}
字符类型数组可以由字符串文本或UTF-8字符串文本初始化，可选地用大括号括起来。字符
串文本的连续字节（如果空间足够或数组大小未知，则包括终止的零字符）初始化数组的元
素。

\paragraph{}
元素类型与\tm{wchar\_t}、\tm{char16\_t}或\tm{char32\_t}的限定或非限定版本兼容的
数组可以由具有相应编码前缀（分别为\tm{L}、\tm{u}或\tm{U}）的宽字符串文本初始化，
可选地括在大括号中。宽字符串文本的连续宽字符（如果空间足够或数组大小未知，则包括
终止的零宽字符）初始化数组的元素。

\paragraph{}
否则，具有聚合或联合类型的对象的初始化应为元素或命名成员的带括号的初始化列表。

\paragraph{}
每个括号括起来的初始化列表都有一个关联的\textit{当前对象}。如果不存在指定，则根
据当前对象的类型对当前对象的子对象进行初始化：数组元素以下标递增的顺序、结构成员
以声明的顺序，以及联合的第一个命名成员。\footnote{如果子聚合或包含的联合的初始化
列表不是以左大括号开头，则其子对象将正常初始化，但子聚合或包含的联合不会成为当前
对象：当前对象仅与大括号包含的初始化列表相关联。} 相反，指定会导致后续初始化开始
由指示符所描述的子对象的初始化。然后，初始化按顺序继续进行，从指示器所描述的下一
个子对象开始。\footnote{初始化联合成员后，下一个对象不是联合的下一个成员；而是包
含联合的对象的下一个子对象。}

\paragraph{}
每个指示符列表都以与最近的包含大括号对关联的当前对象开始其说明。指示符列表中的每
个项（按顺序）指定其当前对象的特定成员，并将下一个指定符（如果有）的当前对象更改
为该成员。\footnote{因此，指示符只能指定关联于包含大括号对的聚合或联合的严格子对
象。也请注意，每个单独的指示符列表都是独立的。} 在指示符列表末尾生成的当前对象是
由后续初始化的子对象。

\paragraph{}
初始化应按照初始化列表的顺序进行，为特定子对象提供的每个初始化都将覆盖先前为同一
子对象列出的任何初始化；\footnote{子对象的任何初始化如果被重写，因此而不用于初始
化该子对象，则可能不会计算。} 所有未显式初始化的子对象都应隐式初始化，与具有静态
存储期的对象相同。

\paragraph{}
如果聚合或联合包含聚合或联合作为元素或成员，则这些规则递归地应用于子聚合或包含的
联合。如果子聚合或包含的联合的初始化以左大括号开头，则由该大括号及其匹配的右大括
号括起的初始化将初始化子聚合或包含的联合的元素或成员。否则，仅考虑列表中足够的初
始化项来初始化子聚合的元素或成员或包含的联合的第一个成员；剩下的任何初始化都将用
于初始化当前子聚合或包含的联合所属的聚合的下一个元素或成员。

\paragraph{}
如果括号括起来的列表中的初始化少于聚合的元素或成员，或者用于初始化已知大小数组的
字符串文本中的字符少于数组中的元素，则应隐式初始化聚合的其余部分，与具有静态存储
期的对象相同。

\paragraph{}
如果初始化一个未知大小的数组，则其大小由具有显式初始化的最大索引元素确定。数组类
型在其初始化列表的末尾成为完整类型。

\paragraph{}
初始化列表表达式的计算彼此不确定性有序，因此未指定任何副作用发生的顺序。
\footnote{特别的，计算顺序不要求与子对象初始化的顺序相同。}

\paragraph{}
\ex 假定\tm{<complex.h>}已被包含，声明
\begin{lstlisting}
    int i = 3.5;
    double complex c = 5 + 3 * I;
\end{lstlisting}
定义并使用值3初始化\tm{i}，定义并使用值$5.0+i3.0$初始化\tm{c}。

\paragraph{}
\ex 声明
\begin{lstlisting}
    int x[] = { 1, 3, 5 };
\end{lstlisting}
定义\tm{x}并将其初始化为具有三个元素的一维数组对象，因为未指定大小而具有三个初始
化项。

\paragraph{}
\ex 声明
\begin{lstlisting}
    int y[4][3] = {
        { 1, 3, 5 },
        { 2, 4, 6 },
        { 3, 5, 7 },
    };
\end{lstlisting}
是一个具有完全括号初始化的定义：1、3和5初始化\tm{y}的第一行（数组对象\tm{y[0]}）
，即\tm{y[0][0]}、\tm{y[0][1]}和\tm{y[0][2]}。接下来的两行同样初始化\tm{y[1]}和
\tm{y[2]}。初始化提前结束，因此\tm{y[3]}初始化为零。完全相同的效果可以通过
\begin{lstlisting}
    int y[4][3] = {
        1, 3, 5, 2, 4, 6, 3, 5, 7
    };
\end{lstlisting}
\tm{y[0]}的初始化不以左括号开始，因此使用列表中的三项。同样接下来的三项依次用于
\tm{y[1]}和\tm{y[2]}的初始化。

\paragraph{}
\ex 声明
\begin{lstlisting}
    int z[4][3] = {
        { 1 }, { 2 }, { 3 }, { 4 }
    };
\end{lstlisting}
按所示初始化\tm{z}的第一列，并将其余初始化为零。

\paragraph{}
\ex 声明
\begin{lstlisting}
    struct { int a[3], b; } w[] = { { 1 }, 2 };
\end{lstlisting}
为带不一致括号初始化的定义。它定义了带两个元素的结构：\tm{w[0].a[0]}为1，
\tm{w[1].a[0]}为2；所有其他元素为0。

\paragraph{}
\ex 声明
\begin{lstlisting}
    short q[4][3][2] = {
        { 1 },
        { 2, 3 },
        { 4, 5, 6 }
    };
\end{lstlisting}
包含不完整但一致的括号初始化。它定义一个三维数组对象：\tm{q[0][0][0]}为1，
\tm{q[1][0][0]}为2，\tm{q[1][0][1]}为3，而4、5和6分别初始化\tm{q[2][0][0]}，
\tm{q[2][0][1]}和\tm{q[2][1][0]}；其余均为零。\tm{q[0][0]}的初始化不是以左大括号
开头，因此最多可以使用当前列表中的六项。因为只有一个，所以剩下的五个元素的值初始
化为零。同样，\tm{q[1][0]}和\tm{q[2][0]}的初始化不是以左大括号开始的，因此每个初
始化最多使用六项来初始化各自的二维子集合。如果列表中含有六项以上，则会发出诊断消
息。相同的初始化结果可以通过以下方式实现：
\begin{lstlisting}
    short q[4][3][2] = {
        1, 0, 0, 0, 0, 0,
        2, 3, 0, 0, 0, 0,
        4, 5, 6
    };
\end{lstlisting}
或通过
\begin{lstlisting}
    short q[4][3][2] = {
        {
            { 1 },
        },
        {
            { 2, 3 },
        },
        {
            { 4, 5 },
            { 6 },
        }
    };
\end{lstlisting}
以全括号的方式初始化。

\paragraph{}
注意一般来说，完全加括号和最小加括号的初始化形式不太可能引起混淆。

\paragraph{}
\ex 完成数组类型的一种初始化形式是类型定义名称。给定声明
\begin{lstlisting}
    typedef int A[];  // OK - declared with block scope
\end{lstlisting}
声明
\begin{lstlisting}
    A a = { 1, 2 }, b = { 3, 4, 5 };
\end{lstlisting}
等价于
\begin{lstlisting}
    int a[] = { 1, 2 }, b[] = { 3, 4, 5 };
\end{lstlisting}
由于不完整类型的规则。

\paragraph{}
\ex 声明
\begin{lstlisting}
    char s[] = "abc", t[3] = "abc";
\end{lstlisting}
定义``普通''的\tm{char}数组对象\tm{s}和\tm{t}，其元素使用字符串文本初始化。该声
明等价于
\begin{lstlisting}
    char s[] = { 'a', 'b', 'c', '\0' },
         t[] = { 'a', 'b', 'c' };
\end{lstlisting}
数组内容可修改。另一方面，声明
\begin{lstlisting}
    char *p = "abc";
\end{lstlisting}
定义类型为``指向\tm{char}的指针''\tm{p}，并初始化为指向类型为``\tm{char}的指针''
的对象，长度为4，元素由字符串文本初始化。如果尝试使用\tm{p}修改数组内容，则行为
未定义。

\paragraph{}
\ex 可以使用指示符初始化数组以对应于枚举的元素：
\begin{lstlisting}
    enum { member_one, member_two };
    const char *nm[] = {
        [member_two] = "member two",
        [member_one] = "member one",
    };
\end{lstlisting}

\paragraph{}
\ex 结构成员可以初始化为非零值，而不取决于它们的顺序：
\begin{lstlisting}
    div_t answer = { .quot = 2, .rem = -1 };
\end{lstlisting}

\paragraph{}
\ex 当未加修饰的初始化列表可能被误解时，可以使用指示符提供显式初始化：
\begin{lstlisting}
    struct { int a[3], b; } w[] =
        { [0].a = {1}, [1].a[0] = 2 };
\end{lstlisting}

\paragraph{}
\ex 可以使用单个指示符从数组的两端``分配''空间：
\begin{lstlisting}
    int a[MAX] = {
        1, 3, 5, 7, 9, [MAX-5] = 8, 6, 4, 2, 0
    };
\end{lstlisting}

\paragraph{}
上例中如果\tm{MAX}大于10，中间会有一些零值元素；如果小于10，前五个初始化提供的一
些值会被第二个五项覆盖。

\paragraph{}
\ex 联合的任何成员可以初始化：
\begin{lstlisting}
    union { /* ... */ } u = { .any_member = 42 };
\end{lstlisting}

\fwdref{7.19}

                                               \ssect{静态断言}{lang.dcl.assert}
\syntax
\paragraph{}
\synsym{static\_assert-declaration}
  \synprd[]{\tm{\_Static\_assert (} \nt{constant-expression} \tm{,}
    \nt{string-literal} \tm{) ;}}

\constraint
\paragraph{}
常量表达式应该不等于0。

\semantic
\paragraph{}
常量表达式应为整型常量表达式。如果常量表达式的值不等于0，则声明无效。否则，将违
反约束，并且实现将生成包含字符串文本的诊断消息，除了不在基本源字符集中的字符不需
要出现在消息中。

\fwdref{7.2}

                                                      \sect{语句与块}{lang.stmt}
\syntax
\paragraph{}
\synsym{statement}
  \synprd{\nt{labeled-statement}}
  \synprd{\nt{compound-statement}}
  \synprd{\nt{expression-statement}}
  \synprd{\nt{selection-statement}}
  \synprd{\nt{iteration-statement}}
  \synprd[]{\nt{jump-statement}}

\semantic
\paragraph{}
\textit{语句}指定要执行的操作。除非另有说明，否则语句按顺序执行。

\paragraph{}
\textit{块}允许将一组声明和语句组合成一个语法单元。对具有自动存储期的对象初始化
和具有块作用域的普通标识符的变长数组声明子进行计算，并在每次按执行顺序到达声
明时将值存储在对象中（包括在没有初始化的对象中存储不确定值），如同它是一个声明，
在每个声明中按声明子出现的顺序进行。

\paragraph{}
\textit{全表达式}是不属于另一个表达式或声明子的表达式。以下每一个都是全表达式：
不是复合字面值一部分的初始化；表达式语句中的表达式；选择语句的控制表达式
（\tm{if}或\tm{switch}）；\tm{while}或\tm{do}语句的控制表达式；\tm{for}语句的每
个（可选）表达式；\tm{return}语句中的（可选）表达式。全表达式的计算和下一个要计
算的全表达式的计算之间有一个序列点。

\fwdref{6.8.3，6.8.4，6.8.5，6.8.6.4}

                                               \ssect{标号语句}{lang.stmt.label}
\syntax
\paragraph{}
\synsym{labeled-statement}
  \synprd{\nt{identifier} \tm{:} \nt{statement}}
  \synprd{\tm{case} \nt{constant-expression} \tm{:} \nt{statement}}
  \synprd[]{\tm{default :} \nt{expression}}

\constraint
\paragraph{}
\tm{case}和\tm{default}标号应该只出现在\tm{switch}语句中。关于这些标号的进一步约
束在\tm{switch}语句中讨论。

\paragraph{}
在一个函数内标号名应该唯一。

\semantic
\paragraph{}
任何语句前都可以有一个前缀，该前缀将一个标识符声明为标号名。标号本身不会改变控制
流，控制流在它们之间继续畅通无阻。

\fwdref{6.8.6.1，6.8.4.2}

                                                \ssect{复合语句}{lang.stmt.cmpd}
\syntax
\paragraph{}
\synsym{compound-statement}
\synprd{\tm{\{} \nt{block-item-list\tsub{opt}} \tm{\}}}
\synsym{block-item-list}
  \synprd{\nt{block-item}}
  \synprd{\nt{block-item-list block-item}}
\synsym{block-item}
  \synprd{\nt{declaration}}
  \synprd[]{\nt{statement}}

\semantic
\paragraph{}
\textit{复合语句}是一个块。

                                          \ssect{表达式与空语句}{lang.stmt.expr}
\syntax
\paragraph{}
\synsym{expression-statement}
  \synprd[]{\nt{expression\tsub{opt} \tm{;}}}

\semantic
\paragraph{}
表达式语句中的表达式仅为其副作用\footnote{比如赋值，具有副作用的函数调用。}而作
为void表达式而计算。

\paragraph{}
\textit{空语句}（仅包含一个分号）不进行任何操作。

\paragraph{}
\ex 如果函数调用仅作为表达式语句计算其副作用，则可以通过强制转换将表达式转换为
void表达式来显式放弃其值：
\begin{lstlisting}
    int p(int);
    /* ... */
    (void)p(0);
\end{lstlisting}

\paragraph{}
\ex 在程序片断中
\begin{lstlisting}
    char *s;
    /* ... */
    while (*s++ != '\0')
        ;
\end{lstlisting}
一个空语句为迭代语句提供一个空的循环体。

\paragraph{}
\ex 空语句也可用于在复合语句的结束\tm{\}}之前加上标号。
\begin{lstlisting}
    while (loop1) {
        /* ... */
        while (loop2) {
            /* ... */
            if (want_out)
                goto end_loop1;
            /* ... */
        }
        /* ... */
    end_loop1: ;
    }
\end{lstlisting}

\fwdref{6.8.5}

                                                 \ssect{选择语句}{lang.stmt.sel}
\syntax
\paragraph{}
\synsym{selection-statement}
  \synprd{\tm{if (} \nt{expression} \tm{)} \nt{statement}}
  \synprd{\tm{if (} \nt{expression} \tm{)} \nt{statement} \tm{else}
    \nt{statement}}
  \synprd[]{\tm{switch (} \nt{expression} \tm{)} \nt{statement}}

\semantic
\paragraph{}
选择语句根据控制表达式的值在一组语句中进行选择。

\paragraph{}
选择语句是一个块，其作用域是其包含块作用域的严格子集。每个关联子语句也是一个块，
其作用域是选择语句作用域的严格子集。

                                               \sssect{if语句}{lang.stmt.sel.if}
\constraint
\paragraph{}
\tm{if}语句的控制表达式应为标量类型。

\semantic
\paragraph{}
在这两种形式中，如果表达式不等于0，则执行第一个子语句。在\tm{else}形式中，如果表
达式等于0，则执行第二个子语句。如果通过标号到达第一个子语句，则不会执行第二个子
语句。

\paragraph{}
\tm{else}与语法允许的词法上最近的前置\tm{if}相关联。

                                       \sssect{switch语句}{lang.stmt.sel.switch}
\constraint
\paragraph{}
\tm{switch}语句的控制表达式应为整型。

\paragraph{}
如果\tm{switch}语句在具有变量修改类型的标识符的作用域内具有关联的\tm{case}或
\tm{default}标号，则整个\tm{switch}语句应在该标识符的作用域内。\footnote{也就是
说，声明要么位于\tm{switch}语句之前，要么位于与包含声明的块中的\tm{switch}关联的
最后一个\tm{case}或\tm{default}标号之后。}

\paragraph{}
每个\tm{case}标号的表达式应为整型常量表达式，同一\tm{switch}语句中的两个
\tm{case}常量表达式在转换后不应具有相同的值。\tm{switch}语句中最多可以有一个
\tm{default}标号。（任何被包含的\tm{switch}语句都可以有一个\tm{default}标号或
值与包含它的\tm{switch}语句中的\tm{case}常量表达式重复的\tm{case}常量表达式。）

\semantic
\paragraph{}
\tm{switch}语句使控制流跳转到、进入或越过作为\textit{switch主体}的语句，取决于控
制表达式的值，以及是否存在\tm{default}标号以及switch主体上或其中任何\tm{case}标
号的值。\tm{case}或\tm{default}标号只能在最近的包含\tm{switch}语句中访问。

\paragraph{}
对控制表达式执行整型提升。每个\tm{case}标号中的常量表达式都转换为控制表达式的提
升类型。如果转换的值与提升的控制表达式的值匹配，则控制流将跳转到匹配的\tm{case}
标号后面的语句。否则，如果存在\tm{default}标号，控制流将跳转到该标号后的语句。如
果没有匹配的转换后\tm{case}常量表达式，并且没有\tm{default}标号，则不会执行
switch主体的任何部分。

\implimit
\paragraph{}
如\ref{env.env.limit.trans}所讨论，实现可能限制\tm{switch}语句中\tm{case}值的数
量。

\paragraph{}
\ex* 在程序片断中
\begin{lstlisting}
    switch (expr)
    {
        int i = 4;
        f(i);
    case 0:
        i = 17;
        /* falls through into default code */
    default:
        printf("%d\n", i);
    }
\end{lstlisting}
标识符为\tm{i}的对象具有自动存储期（在块内），但从未初始化，因此，如果控制表达式
具有非零值，则对\tm{printf}函数的调用将访问不确定的值。同样，无法调用函数\tm{f}。

                                                \ssect{迭代语句}{lang.stmt.iter}
\syntax
\paragraph{}
\synsym{iteration-statement}
  \synprd{\tm{while (} \nt{expression} \tm{)} \nt{statement}}
  \synprd{\tm{do} \nt{statement} \tm{while (} \nt{expression} \tm{) ;}}
  \synprd{\tm{for (} \nt{expression\tsub{opt}} \tm{;} \nt{expression\tsub{opt}}
    \tm{;} \nt{expression\tsub{opt}} \nt{)} \nt{statement}}
  \synprd[]{\tm{for (} \nt{declaration expression\tsub{opt}} \tm{;}
    \nt{expression\tsub{opt}} \tm{)} \nt{statement}}

\constraint
\paragraph{}
迭代语句的控制表达式应为标量类型。

\paragraph{}
\tm{for}语句的声明部分只能声明具有存储类\tm{auto}或\tm{register}的对象标识符。

\semantic
\paragraph{}
迭代语句使一个称为\textit{循环体}的语句重复执行，直到控制表达式等于0。无论循环体
是从迭代语句进入还是通过跳转进入，都会发生重复。\footnote{跳过的代码不执行。特别
地，\tm{for}或\tm{while}语句的控制表达式在进入循环体之前不进行计算，\tm{for}语句
的\textit{clause-1}也不进行计算。}

\paragraph{}
迭代语句是一个块，其作用域是其包含块作用域的严格子集。循环体也是一个块，其作用域
是迭代语句作用域的严格子集。

\paragraph{}
一个迭代语句，如果其控制表达式不是常量表达式，\footnote{省略的控制表达式被替换成
非零常量，因此也是一个常量表达式。} 在循环体内，控制表达式中或（\tm{for}语句的情
况下）\textit{expression-3}中不进行输入/输出操作，不访问易失对象，并且不进行同步
或原子操作，则实现可以假定其会终止。\footnote{目的是允许编译器变换，比如移除空循
环，即使不能证明终止。}

                                        \sssect{while语句}{lang.stmt.iter.while}
\paragraph{}
控制表达式的计算在循环体每次执行前进行。

                                              \sssect{do语句}{lang.stmt.iter.do}
\paragraph{}
控制表达式的计算在循环体每次执行之后进行。

                                            \sssect{for语句}{lang.stmt.iter.for}
\paragraph{}
语句                                                                          \\
\mbox{\hspace{4em}\tm{for (} \nt{clause-1} \tm{;} \nt{expression-2} \tm{;}
  \nt{expression-3} \tm{)} \nt{statement}}                                    \\
行为如下：\textit{expression-2}为控制表达式，在循环体每次执行之前计算。
\textit{expression-3}在循环体每次执行之后作为void表达式计算。如果
\textit{clause-1}是一个声明，其所声明的任何标识符的作用域为声明的剩余部分，以及
整个循环体，包括另外两个表达式；其按执行顺序在控制表达式首次计算前到达。如果
\textit{clause-1}是一个表达式，在控制表达式首次计算前作为void表达式进行计算。
\footnote{因此，\textit{clause-1}指定循环的初始化，可能声明一个或多个变量以在循
环中使用；控制表达式\textit{expression-2}指定在每次迭代之前进行的计算，以便循环
的执行继续进行，直到表达式的值等于0；\textit{expression-3}指定在每次迭代后执行的
操作（例如递增）。}

\paragraph{}
\textit{clause-1}和\textit{expression-3}都可以省略。省略\textit{expression-2}则
替换成非零常量。

                                                 \ssect{跳转语句}{lang.stmt.jmp}
\syntax
\paragraph{}
\synsym{jump-statement}
  \synprd{\tm{goto} \nt{identifier} \tm{;}}
  \synprd{\tm{continue} \tm{;}}
  \synprd{\tm{break} \tm{;}}
  \synprd[]{\tm{return} \nt{expression\tsub{opt}} \tm{;}}

\semantic
\paragraph{}
跳转语句导致无条件跳转到另一个位置。

                                           \sssect{goto语句}{lang.stmt.jmp.goto}
\constraint
\paragraph{}
\tm{goto}语句中的标识符应命名位于包含函数中某处的标号。\tm{goto}语句不得从具有可
变修改类型的标识符的作用域外跳转到该标识符的作用域内。

\semantic
\paragraph{}
\tm{goto}语句导致无条件跳转到以包含函数中的命名标号为前缀的语句。

\paragraph{}
\ex 有时可以方便地跳到一组复杂语句的中间。下面的概要介绍了一种基于这三个假设的解
决问题的可能方法：
\begin{enumerate}
  \item{常规初始化代码只访问当前函数可见的对象。}
  \item{常规初始化代码太大，无法保证复制。}
  \item{用于确定下一个操作的代码位于循环的头部。（例如，允许\tm{continue}语句访
    问它。）}
\end{enumerate}
\begin{lstlisting}
    /* ... */
    goto first_time;
    for (;;) {
        // determine next operation
        /* ... */
        if (need to reinitialize) {
            // reinitialize-only code
            /* ... */
        first_time:
            // general initialization code
            /* ... */
            continue;
        }
        // handle other operations
        /* ... */
    }
\end{lstlisting}

\paragraph{}
\ex \tm{goto}语句不允许跳过具有变量修改类型的对象的任何声明。但是，允许在作用域
内跳转。
\begin{lstlisting}
    goto lab3;            // invalid: going INTO scope of VLA.
    {
        double a[n];
        a[j] = 4.4;
    lab3:
        a[j] = 3.3;
        goto lab4;        // valid: going WITHIN scope of VLA.
        a[j] = 5.5;
    lab4:
        a[j] = 6.6;
    }
    goto lab4;            // invalid: going INTO scope of VLA.
\end{lstlisting}

                                       \sssect{continue语句}{lang.stmt.jmp.cont}
\constraint
\paragraph{}
\tm{continue}语句只能出现在循环体中或作为循环体出现。

\semantic
\paragraph{}
\tm{continue}语句导致跳转到最小的包含迭代语句的循环继续部分，即跳转到循环体的末
尾。更准确地说，在每个语句中                                                  \\
\begin{minipage}{0.30\linewidth}
\mbox{\hspace{0em}\tm{while (/* ... */) \{}}                                  \\
  \mbox{\hspace{2em}\tm{/* ... */}}                                           \\
  \mbox{\hspace{2em}\tm{continue;}}                                           \\
  \mbox{\hspace{2em}\tm{/* ... */}}                                           \\
\mbox{\hspace{0em}\tm{contin:}}                                               \\
\mbox{\hspace{0em}\tm{\}}}
\end{minipage}
\hfill
\begin{minipage}{0.30\linewidth}
\mbox{\hspace{0em}\tm{do \{}}                                                 \\
  \mbox{\hspace{2em}\tm{/* ... */}}                                           \\
  \mbox{\hspace{2em}\tm{continue;}}                                           \\
  \mbox{\hspace{2em}\tm{/* ... */}}                                           \\
\mbox{\hspace{0em}\tm{contin:}}                                               \\
\mbox{\hspace{0em}\tm{\} while (/* ... */);}}
\end{minipage}
\hfill
\begin{minipage}{0.30\linewidth}
\mbox{\hspace{0em}\tm{for (/* ... */) \{}}                                    \\
  \mbox{\hspace{2em}\tm{/* ... */}}                                           \\
  \mbox{\hspace{2em}\tm{continue;}}                                           \\
  \mbox{\hspace{2em}\tm{/* ... */}}                                           \\
\mbox{\hspace{0em}\tm{contin:}}                                               \\
\mbox{\hspace{0em}\tm{\}}}
\end{minipage}                                                              \\\\
除非所示的\tm{continue}语句在一个包含的迭代语句中（在这种情况下，它在该语句中被
解释），否则它等同于\tm{goto contin;}。\footnote{\tm{contin:}标号后面是一个空语
句。}

                                           \sssect{break语句}{lang.stmt.jmp.brk}
\constraint
\paragraph{}
\tm{break}语句只能出现在switch主体或循环体中或作为switch主体或循环主体出现。

\semantic
\paragraph{}
\tm{break}语句终止最小的包含\tm{switch}或迭代语句的执行。

                                          \sssect{return语句}{lang.stmt.jmp.ret}
\constraint
\paragraph{}
带有表达式的\tm{return}语句不能出现在返回类型为\tm{void}的函数中。没有表达式的
\tm{return}语句只能出现在返回类型为\tm{void}的函数中。

\semantic
\paragraph{}
\tm{return}语句终止当前函数的执行，并将控制流返回给调用者。函数可以有任意数量的
\tm{return}语句。

\paragraph{}
如果执行带有表达式的\tm{return}语句，则表达式的值将作为函数调用表达式的值返回给
调用者。如果表达式的类型与它出现的函数的返回类型不同，则该值会像通过赋值给具有函
数返回类型的对象一样进行转换。\footnote{\tm{return}语句不是赋值语句。
\ref{lang.expr.assign.simple}节中的重叠限制不适用于函数返回的情况。浮点值的表示
可能比类型所隐含的范围或精度更广；可以使用强制转换来删除这个额外的范围和精度。}

\paragraph{}
\ex* 以下代码中：
\begin{lstlisting}
    struct s { double i; } f(void);
    union {
        struct {
            int f1;
            struct s f2;
        } u1;
        struct {
            struct s f3;
            int f4;
        } u2;
    } g;
    struct s f(void)
    {
        return g.u1.f2;
    }
    /* ... */
    g.u2.f3 = f();
\end{lstlisting}
没有未定义的行为，尽管如果直接执行赋值（而不使用函数调用获取值），则会出现这种情
况。

                                                      \sect{外部定义}{lang.extn}
\syntax
\paragraph{}
\synsym{translation-unit}
  \synprd{\nt{external-declaration}}
  \synprd{\nt{translation-unit external-declaration}}
\synsym{external-declaration}
  \synprd{\nt{function-definition}}
  \synprd[]{\nt{declaration}}

\constraint
\paragraph{}
存储类说明符\tm{auto}和\tm{register}不应出现在外部声明的声明说明符中。

\paragraph{}
在翻译单元中，声明为内部链接的每个标识符的外部定义不得超过一个。此外，如果表达式
中使用了用内部链接声明的标识符（用作\tm{sizeof}或\tm{\_Alignof}运算符的操作数
的一部分除外，其结果是整型常量），则翻译单元中的标识符只能有一个外部定义。

\semantic
\paragraph{}
如\ref{evn.concept.trans.struct}所述，预处理后的程序文本单元是一个翻译单元，由一
系列外部声明组成。它们被描述为``外部''，因为它们出现在任何函数之外（因此具有文件
作用域）。正如\ref{lang.dcl}中所讨论的，一个声明会导致为标识符所命名的对象或函数
保留存储，则该声明是一个定义。

\paragraph{}
\textit{外部定义}是外部声明，也是函数（内联定义除外）或对象的定义。如果在表达式
中使用了用外部链接声明的标识符（用作\tm{sizeof}或\tm{\_Alignof}运算符的操作数的
一部分除外，其结果是整型常量），则在整个程序中的某个位置，该标识符恰有一个外部定
义；否则，不能有超过一个外部定义。\footnote{因此，如果声明为外部链接的标识符未用
于表达式中，则不需要外部定义。}

                                                 \ssect{函数定义}{lang.extn.fct}
\syntax
\paragraph{}
\synsym{function-definition}
  \synprd{\nt{declaration-specifiers declarator declaration-list\tsub{opt}
    compound-statement}}
\synsym{declaration-list}
  \synprd{\nt{declaration}}
  \synprd[]{\nt{declaration-list declaration}}

\constraint
\paragraph{}
函数定义中声明的标识符（函数名）应具有函数类型，由函数定义的声明子部分指定。
\footnote{其目的是函数定义中的类型类别不能从\tm{typedef}派生：
\newcommand{\lbox}[2]{\\ \mbox{\makebox[22em]{\hspace{4em}\tm{#1}\hfill}
  \tm{//} #2}}
\lbox{typedef int F(void);}{type \tm{F} is ``function with no parameters}
\lbox{}{\hspace{8em} returning \tm{int}''}
\lbox{F f, g;}{\tm{f} and \tm{g} both have type compatible with \tm{F}}
\lbox{F f \{ /* ... */ \}}{WRONG: syntax/constraint error}
\lbox{F g() \{ /* ... */ \}}{WRONG: declares that \tm{g} returns a function}
\lbox{int f(void) \{ /* ... */ \}}{RIGHT: \tm{f} has type compatible with
                                  \tm{F}}
\lbox{int g() \{ /* ... */ \}}{RIGHT: \tm{g} has type compatible with \tm{F}}
\lbox{F *e(void) \{ /* ... */ \}}{\tm{e} returns a pointer to a function}
\lbox{F *((e))(void) \{ /* ... */ \}}{same: parentheses irrelevant}
\lbox{int (*fp)(void);}{\tm{fp} points to a function that has type \tm{F}}
\lbox{F *Fp;}{\tm{Fp} points to a function that has type \tm{F}}
}

\paragraph{}
函数的返回类型应为\tm{void}或非数组类型的完整对象类型。

\paragraph{}
声明说明符中的存储类说明符（如果有）应是\tm{extern}或\tm{static}。

\paragraph{}
如果声明子包括参数类型列表，则每个参数的声明应包括标识符，但由一个\tm{void}类型
的单个参数组成的参数列表的特殊情况除外，在这种情况下，不应存在标识符。不应跟上任
何声明列表。

\paragraph{}
如果声明子包括标识符列表，则声明列表中的每个声明应至少有一个声明子，这些声明子应
仅声明标识符列表中的标识符，并且标识符列表中的每个标识符都应被声明。声明为类型定
义名称的标识符不应重新声明为参数。声明列表中的声明不应包含除\tm{register}的任何
存储类说明符，也不应有初始化。

\semantic
\paragraph{}
函数定义中的声明子指定要定义的函数的名称及其参数的标识符。如果声明子包含参数类型
列表，则该列表还指定所有参数的类型；这样的声明子还充当函数原型，以便以后在同一翻
译单元中调用同一函数。如果声明子包含标识符列表，\footnote{见``未来语言方向''
\ref{lang.dir.fctdef}。} 参数类型应在后续的声明列表中声明。在这两种情况下，每个
参数的类型都会根据\ref{lang.dcl.decl.fct}中的参数类型列表进行调整；结果类型应为
完整的对象类型。

\paragraph{}
如果接受可变数量参数的函数没有以省略号结尾的参数类型列表进行定义，则行为未定义。

\paragraph{}
每个参数都有自动存储期；其标识符是一个左值。\footnote{除了在包含块中以外，参数标
识符不能在函数体中重新声明。} 未指定参数存储的布局。

\paragraph{}
在进入函数时，计算每个变量修改参数的大小表达式，并将每个参数表达式的值转换为相应
参数的类型，就像通过赋值一样。（数组表达式和作为参数的函数指示符在调用前被转换为
指针。）

\paragraph{}
在分配了所有参数之后，将执行构成函数定义主体的复合语句。

\paragraph{}
如果达到终止函数的\tm{\}}，并且调用者使用函数调用的值，则行为未定义。

\paragraph{}
\ex 以下代码中：
\begin{lstlisting}
    extern int max(int a, int b)
    {
        return a > b ? a : b;
    }
\end{lstlisting}
\tm{extern}是存储类说明符，\tm{int}是类型说明符；\tm{max(int a, int b)}是函数声
明子；并且
\begin{lstlisting}
    { return a > b ? a : b; }
\end{lstlisting}
为函数体。以下类似定义使用标识符列表形式作为参数声明：
\begin{lstlisting}
    extern int max(a, b)
    int a, b;
    {
        return a > b ? a : b;
    }
\end{lstlisting}
这里\tm{int a, b;}是参数的声明列表。这两个定义之间的区别在于，第一种形式充当原型
声明，强制转换后续调用函数的参数，而第二种形式则没有。

\paragraph{}
\ex 要将一个函数传递给另一个函数，可以写成
\begin{lstlisting}
    int f(void);
    /* ... */
    g(f);
\end{lstlisting}
则\tm{g}的定义可以写成
\begin{lstlisting}
    void g(int (*funcp)(void))
    {
        /* ... */
        (*funcp)(); /* or funcp(); ...
    }
\end{lstlisting}
或等价的，
\begin{lstlisting}
    void g(int func(void))
    {
        /* ... */
        func(); /* or (*func)(); ... */
    }
\end{lstlisting}

                                             \ssect{外部对象定义}{lang.extn.obj}
\semantic
\paragraph{}
如果对象的标识符声明具有文件作用域和初始化，则该声明是标识符的外部定义。

\paragraph{}
如果文件作用域对象没有初始化也没有存储类说明符，或者存储类说明符是\tm{static}，
则该对象的标识符声明构成一个\textit{尝试性定义}。如果翻译单元包含一个或多个标识
符的尝试性定义，而翻译单元不包含该标识符的外部定义，则行为与翻译单元包含该标识符
的文件作用域声明完全相同，其具有合成类型直到翻译单元结束处，并初始化为0。

\paragraph{}
如果对象的标识符声明是尝试性定义且具有内部链接，则声明的类型不应是不完整类型。

\paragraph{}
\ex
\begin{lstlisting}
    int i1 = 1;         // definition, external linkage
    static int i2 = 2;  // definition, internal linkage
    extern int i3 = 3;  // definition, external linkage
    int i4;             // tentative definition, external linkage
    static int i5;      // tentative definition, internal linkage

    int i1;             // valid tentative definition, refers to pre vious
    int i2;             // 6.2.2 renders undefined, linkage disagreement
    int i3;             // valid tentative definition, refers to pre vious
    int i4;             // valid tentative definition, refers to pre vious
    int i5;             // 6.2.2 renders undefined, linkage disagreement

    extern int i1;      // refers to previous, whose linkage is external
    extern int i2;      // refers to previous, whose linkage is internal
    extern int i3;      // refers to previous, whose linkage is external
    extern int i4;      // refers to previous, whose linkage is external
    extern int i5;      // refers to previous, whose linkage is internal
\end{lstlisting}

\paragraph{}
\ex 如果在翻译单元的末尾包含
\begin{lstlisting}
    int i[];
\end{lstlisting}
数组\tm{i}的类型仍然不完整，隐式初始化导致它有一个元素，在程序启动时该元素设置为
零。

                                                   \sect{预处理指令}{lang.ppdir}
\syntax
\paragraph{}
{\newcommand{\ppdprd}[2]{\synprd{\makebox[5em]{\tm{\# #1}\hfill} #2}}
\synsym{preprocessing-file}
  \synprd{\nt{group\tsub{opt}}}
\synsym{group}
  \synprd{\nt{group-part}}
  \synprd{\nt{group group-part}}
\synsym{group-part}
  \synprd{\nt{if-section}}
  \synprd{\nt{control-line}}
  \synprd{\nt{text-line}}
  \synprd{\tm{\#} \nt{non-directive}}
\synsym{if-section}
  \synprd{\nt{if-group elif-group\tsub{opt} else-group\tsub{opt} endif-line}}
\synsym{if-section}
  \ppdprd{if}{\nt{constant-expression new-line group\tsub{opt}}}
  \ppdprd{ifdef}{\nt{identifier new-line group\tsub{opt}}}
  \ppdprd{ifndef}{\nt{identifier new-line group\tsub{opt}}}
\synsym{elif-groups}
  \synprd{\nt{elif-group}}
  \synprd{\nt{elif-groups elif-group}}
\synsym{elif-group}
  \ppdprd{elif}{\nt{constant-expression new-line group\tsub{opt}}}
\synsym{else-group}
  \ppdprd{else}{\nt{new-line group\tsub{opt}}}
\synsym{endif-line}
  \ppdprd{endif}{\nt{new-line}}
\synsym{control-line}
  \ppdprd{include}{\nt{pp-tokens new-line}}
  \ppdprd{define}{\nt{identifier replacement-list new-line}}
  \ppdprd{define}{\nt{identifier lparen identifier-list\tsub{opt}} \tm{)}
    \nt{replacement-list new-line}}
  \ppdprd{define}{\nt{identifier lparen} \tm{ ... )} \nt{replacement-list
    new-line}}
  \ppdprd{define}{\nt{identifier lparen identifier-list} \tm{, ... )}
    \nt{replacement-list new-line}}
  \ppdprd{undef}{\nt{identifier new-line}}
  \ppdprd{line}{\nt{pp-tokens new-line}}
  \ppdprd{error}{\nt{pp-tokens\tsub{opt} new-line}}
  \ppdprd{pragma}{\nt{pp-tokens\tsub{opt} new-line}}
  \ppdprd{}{\nt{new-line}}
\synsym{text-line}
  \synprd{\nt{pp-tokens\tsub{opt} new-line}}
\synsym{non-directive}
  \synprd{\nt{pp-tokens new-line}}
\synsym{lparen}
  \synprd{前面没有直接跟上空白的\tm{(}字符}
\synsym{replacement-list}
  \synprd{\nt{pp-tokens\tsub{opt}}}
\synsym{pp-tokens}
  \synprd{\nt{preprocessing-token}}
  \synprd{\nt{pp-tokens preprocessing-token}}
\synsym{new-line}
  \synprd[]{新行字符}}

\desc
\paragraph{}
\textit{预处理指令}由一系列满足以下约束的预处理标记组成：序列中的第一个标记是一
个\tm{\#}预处理标记，（在翻译阶段\ref{tpit4}开始时）它或是源文件中的第一个字符
（可选地在不包含新行字符的空白之后），或跟在包含至少一个新行字符的空白之后。序列
中的最后一个标记是序列中第一个标记后面的第一个新行字符。\footnote{因此，预处理指
令通常称为``行''。这些``行''除在预处理期间的某些情况外没有其他语法意义，如同所有
空白一样都是等效的（例如，请参见\ref{lang.ppdir.macro.stringize}中的字符串文本创
建运算符）。} 一个新行字符结束预处理指令，即使它出现在函数式宏调用中。

\paragraph{}
文本行不得以\tm{\#}预处理标记开头。非指令不得以语法中出现的任何指令名称开头。

\paragraph{}
在跳过的组（\ref{lang.ppdir.condinc}）中，指令语法将放宽，允许在指令名称和后续的
新行字符之间出现任何预处理标记序列。

\constraint
\paragraph{}
在预处理指令内的预处理标记之间（从引入预处理标记\tm{\#}后到终止新行字符前）唯一
可以出现的空白字符是空格和水平制表符（包括替换注释的空格或翻译阶段\ref{tpit3}中
可能的其他空白字符）。

\semantic
\paragraph{}
实现可以有条件地处理和跳过源文件的部分，包括其他源文件，以及替换宏。这些功能被称
为\textit{预处理}，因为从概念上讲，它们发生在产生翻译单元的翻译之前。

\paragraph{}
除非另有说明，否则预处理指令中的预处理标记不受宏展开的影响。

\paragraph{}
\ex* 以下代码中：
\begin{lstlisting}
    #define EMPTY
    EMPTY # include <file.h>
\end{lstlisting}
第二行上的预处理标记序列\textit{不是}预处理指令，因为它不是在转换阶段\ref{tpit4}
开始时以\tm{\#}开头，即使在替换宏\tm{EMPTY}之后会这样。

                                            \ssect{条件包含}{lang.ppdir.condinc}
\constraint
\paragraph{}
控制条件包含的表达式应为整型常量表达式，除非：标识符（包括词法上等价于关键字的标
识符）按后文所述解释；\footnote{因为控制常量表达式在翻译阶段\ref{tpit4}计算，所
以所有标识符要么是宏名称，要么不是宏名称 -- 只是没有关键字、枚举常量等。} 并且可
能包含形如                                                                    \\
\mbox{\hspace{4em}\tm{defined} \nt{identifier}}                               \\
或                                                                            \\
\mbox{\hspace{4em}\tm{defined (} \nt{identifier} \tm{)}}                      \\
的一元运算符的表达式，如果标识符当前被定义为宏名（即，如果它是预定义的，或者如果
它是一个\tm{\#define}预处理指令的主体，而中间没有具有相同主体标识符的
\tm{\#undef}指令），则该值计算为1；否则为0。

\paragraph{}
所有宏替换发生后，剩余的每个预处理标记（在将成为控制表达式的预处理标记列表中）应
具有标记（\ref{lang.lex}）的词法形式。

\semantic
\paragraph{}
形如                                                                          \\
\mbox{\hspace{4em}\tm{\# if\ \ } \nt{constant-expression new-line
  group\tsub{opt}}}                                                           \\
\mbox{\hspace{4em}\tm{\# elif} \nt{constant-expression new-line
  group\tsub{opt}}}                                                           \\
的预处理指令检查条件表达式是否计算为非零。

\paragraph{}
在计算之前，将成为控制常量表达式的预处理标记列表中的宏调用将被替换（由
\tm{defined}一元运算符修改的宏名称除外），就像在普通文本中一样。如果标记
\tm{defined}是由于此替换过程而生成的，或者在宏替换之前\tm{defined}一元运算符的使
用不与两个指定形式中的任一个匹配，则行为未定义。在因宏展开和\tm{defined}一元运算
符而进行的所有替换之后，所有剩余的标识符（包括词法上与关键字相同的标识符）都将替
换为pp数字0，然后每个预处理标记都将转换为标记。生成的标记组成控制常数表达式，该
表达式根据\ref{lang.constexpr}的规则进行计算。对于该标记转换和计算，所有有符号整
型和所有无符号整型的表示方式都与头\tm{<stdint.h>}\footnote{因此，在\tm{INT\_MAX}
为\tm{0X7FFF}，\tm{UINT\_MAX}为\tm{0XFFFF}的实现中，常量\tm{0x8000}在\tm{\#if}表
达式中有符号且为正，即使它在翻译阶段\ref{tpit7}中是无符号的。} 中定义的
\tm{intmax\_t}和\tm{uintmax\_t}类型的表示方式相同。这包括解释字符常量，其可能涉及
将转义序列转换为执行字符集成员。这些字符常量的数值是否与表达式中出现相同字符常量
（而不是在\tm{\#if}或\tm{\#elif}指令中）时获得的值相匹配由实现定义。\footnote{因
此，不能保证下面的\tm{\#if}指令和\tm{if}语句中的常量表达式在这两个上下文中的计算
值相同。                                                                      \\
\mbox{\hspace{4em}\tm{\#if 'z' - 'a' == 25}}                                  \\
\mbox{\hspace{4em}\tm{if ('z' - 'a' == 25)}}
} 此外，单个字符常量是否可能具有负值由实现定义。

\paragraph{}
形如                                                                          \\
\mbox{\hspace{4em}{\tm{\# ifdef\ } \nt{identifier new-line group\tsub{opt}}}} \\
\mbox{\hspace{4em}{\tm{\# ifndef} \nt{identifier new-line group\tsub{opt}}}}  \\
的预处理指令检查标识符当前是否定义为宏名。他们的条件分别相当于\tm{\#if defined}
\nt{identifier}和\tm{\#if !defined} \nt{identifier}。

\paragraph{}
每个指令的条件按顺序检查。如果计算结果为假（零），则跳过它所控制的组：仅通过确定
指令的名称处理指令，以跟踪嵌套条件的层级；忽略指令的其余预处理标记，与组中的其他
预处理标记一样。只处理控制条件计算结果为真（非零）的第一个组。如果没有条件的值为
真，并且存在\tm{\#else}指令，则处理由\tm{\#else}控制的组；如果缺少\tm{\#else}指
令，则跳过所有组，直到\tm{\#endif}。\footnote{如语法所示，在终止新行字符之前，预
处理标记不应跟在\tm{\#else}或\tm{\#endif}指令之后。然而，注释可能出现在源文件的
任何地方，包括预处理指令中。}

\fwdref{6.10.3，6.10.2，7.20.1.5}

                                              \ssect{源文件包含}{lang.ppdir.inc}
\constraint
\paragraph{}
\tm{\#include}指令应标识可由实现处理的头或源文件。

\semantic
\paragraph{}
形如                                                                          \\
\mbox{\hspace{4em}\tm{\# include <}\nt{h-char-sequence}\tm{>} \nt{new-line}}  \\
的预处理指令在实现定义的位置序列中搜索由分隔符\tm{<}和\tm{>}之间的指定序列唯一标
识的头，并导致该头的整个内容替换该指令。如何指定位置或标识头由实现定义。

\paragraph{}
形如                                                                          \\
\mbox{\hspace{4em}\tm{\# include \dq}\nt{q-char-sequence}\tm{\dq}
  \nt{new-line}}                                                              \\
使源文件的整个内容替换该指令，这些内容由分隔符\tm{\dq}之间的指定序列标识。以实现
定义的方式搜索命名的源文件。如果不支持此搜索，或者搜索失败，则会像读取        \\
\mbox{\hspace{4em}\tm{\# include <}\nt{h-char-sequence}\tm{>} \nt{new-line}}  \\
一样，与原始指令中包含相同序列（包括\tm{>}字符，如果有的话），重新处理该指令。

\paragraph{}
允许形如                                                                      \\
\mbox{\hspace{4em}\tm{\# include} \nt{pp-tokens new-line}}                    \\
的预处理指令（不与以上两种形式匹配）。指令中\tm{include}之后的预处理标记的处理与
普通文本的处理相同。（当前定义为宏名的每个标识符都由其预处理标记替换列表替换。）
所有替换后生成的指令应与前面两种形式中的一个匹配。\footnote{注意，相邻的字符串文
本不会连接到单个字符串文本中（见\ref{env.concept.trans.phase}中的翻译阶段）；因
此，产生两个字符串文本的展开是无效的指令。} 将\tm{<}和\tm{>}预处理标记对或一对
\tm{\dq}字符之间的一系列预处理标记组合成单个头名称预处理标记的方法由实现定义。

\paragraph{}
实现应为由一个或多个非数字或数字（\ref{lang.lex.id.general}）后跟句点（\tm{.}）
和单个非数字组成的序列提供唯一映射。第一个字符不能是数字。该实现可以忽略字母大小
写的区别，并将映射限制为该期间之前的八个有效字符。

\paragraph{}
\tm{\#include}预处理指令可能出现在由于另一个文件中的\tm{\#include}指令而被读取的
源文件中，最多到达由实现定义的嵌套限制（见\ref{env.env.limit.trans}）。

\paragraph{}
\ex \tm{\#include}预处理指令的最常见用法如下：
\begin{lstlisting}
    #include <stdio.h>
    #include "myprog.h"
\end{lstlisting}

\paragraph{}
\ex 本例说明宏替换的\tm{\#include}指令：
\begin{lstlisting}
    #if VERSION == 1
        #define INCFILE "vers1.h"
    #elif VERSION == 2
        #define INCFILE "vers2.h" // and so on
    #else
        #define INCFILE "versN.h"
    #endif
    #include INCFILE
\end{lstlisting}

\fwdref{6.10.3}

                                                \ssect{宏替换}{lang.ppdir.macro}
\constraint
\paragraph{}
只有当两个预处理标记具有相同的个数、顺序、拼写和空格分隔时，两个替换列表才是相同
的，其中所有空格分隔被认为是相同的。

\paragraph{}
除非第二个定义是对象式宏定义，并且两个替换列表相同，否则当前定义为对象式宏的标识
符不能被另一个\tm{\#define}预处理指令重新定义。同样，当前定义为函数式宏的标识符
不应被另一个\tm{\#define}预处理指令重新定义，除非第二个定义是函数式宏定义，具有
相同的参数个数和拼写，并且两个替换列表相同。

\paragraph{}
在对象式宏定义中，标识符和替换列表之间应留有空白。

\paragraph{}
如果宏定义中的标识符列表没有以省略号结尾，则调用函数式宏时的参数数目（包括不含预
处理标记的参数）应等于宏定义中的参数数目。否则，调用中的参数应该多于宏定义中的参
数（不包括\tm{...}）。应存在一个\tm{)}终止调用的预处理标记。

\paragraph{}
标识符\tm{\_\_VAR\_ARGS\_\_}应只出现在参数中使用省略号的函数式宏替换列表中。

\paragraph{}
函数式宏的参数标识符应在其作用域内唯一声明。

\semantic
\paragraph{}
紧跟在\tm{define}后面的标识符称为\textit{宏名称}。宏名称有一个命名空间。预处理标
记替换列表之前或之后的任何空白字符都不被视为任何宏形式替换列表的一部分。

\paragraph{}
如果预处理标记\tm{\#}后面跟有标识符，词法上出现在预处理指令可以开始的点，则该标
识符不受宏替换的影响。

\paragraph{}
形如                                                                          \\
\mbox{\hspace{4em}\tm{\# define} \nt{identifier replacement-list new-line}}   \\
的预处理指令定义一个对象式宏，使宏名\footnote{由于在宏替换时，所有字符常量和字符
串文本都是预处理标记，而不是可能包含类似标识符的子序列的序列（见
\ref{env.concept.trans.phase}，翻译阶段），因此从不扫描它们的宏名称或参数。} 的
每个后续实例被构成指令其余部分的预处理标记替换列表所替换。然后替换列表将重新扫描
以替换以下指定的更多宏名称。

\paragraph{}
形如                                                                          \\
\mbox{\hspace{4em}\tm{\# define} \nt{identifier lparen
  identifier-list\tsub{opt}} \tm{)} \nt{replacement-list new-line}}           \\
\mbox{\hspace{4em}\tm{\# define} \nt{identifier lparen} \tm{... )}
  \nt{replacement-list new-line}}                                             \\
\mbox{\hspace{4em}\tm{\# define} \nt{identifier lparen identifier-list}
  \tm{, ... )} \nt{replacement-list new-line}}                                \\
的预处理指令定义带参数的函数式宏，其用法在语法上类似于函数调用。参数由可选的标识
符列表指定，其作用域从标识符列表中的声明扩展到终止\tm{\#define}预处理指令的新行
字符。函数式宏名后跟一个\tm{(}作为下一个预处理标记的每个后续实例，引入预处理标记
序列，这些序列由定义中的替换列表替换（宏调用）。替换的预处理标记序列由匹配的
\tm{)}预处理标记终止，跳过中间匹配的左右括号预处理标记对。在组成函数式宏调用的预
处理标记序列中，新行被认为是正常的空白字符。

\paragraph{}
由最外部层匹配的括号括起来的预处理标记序列构成函数式宏的参数列表。列表中的各个参
数由逗号预处理标记分隔，但匹配的内圆括号之间的逗号预处理标记不分隔参数。如果在参
数列表中有一系列的预处理标记形成预处理指令，\footnote{不论名称，空指令仍是预处理
指令。} 则行为未定义。

\paragraph{}
如果有\tm{...}在宏定义的标识符列表中，那么尾随参数（包括任何分隔逗号预处理标记）
合并以形成单个项：\textit{变量参数}。合并后的参数数目比宏定义中的参数数目多一个
（不包括\tm{...}）。

                                       \sssect{参数替换}{lang.ppdir.macro.subst}
\paragraph{}
在为函数式宏的调用确定参数之后，将进行参数替换。除非前面有\tm{\#}或\tm{\#\#}预处
理标记或后面有\tm{\#\#}预处理标记（见下文），否则替换列表中的形参，在扩展其中包
含的所有宏之后，将被相应的实参替换。在被替换之前，每个实参的预处理标记被完全宏替
换，就像它们构成了预处理文件的其余部分一样；没有其他预处理标记可用。

\paragraph{}
替换列表中出现的标识符\tm{\_\_VA\_ARGS\_\_}如同形参，变量参数应构成用于替换它的
预处理标记。

                                   \sssect{\#运算符}{lang.ppdir.macro.stringize}
\constraint
\paragraph{}
对于函数式宏，替换列表中的每个预处理标记\tm{\#}后面都应跟一个参数，作为替换列表
中的下一个预处理标记。

\semantic
\paragraph{}
如果在替换列表中，参数前面紧接着有一个\tm{\#}预处理标记，则这两个标记都将替换为
一个字符串文本预处理标记，其中包含对应实参的预处理标记序列的拼写。参数的预处理标
记之间的空白每次出现都将成为字符串文本中的单个空格字符。删除第一个预处理标记之前
和组成参数的最后一个预处理标记之后的空白。否则，参数中每个预处理标记的原始拼写将
保留在字符串文本中，但产生字符串文本和字符常量拼写的特殊处理除外：在字符常量或字
符串文本的每个\tm{\dq}和\tm{\bs}字符之前插入一个\tm{\bs}字符（包括分隔符\tm{\dq}
字符），但是否在\tm{\bs}字符开始通用字符名之前插入\tm{\bs}字符由实现定义。如果结
果的替换不是有效的字符串文本，则行为未定义。与空参数对应的字符串文本为
\tm{\dq\dq}。未指定\tm{\#}和\tm{\#\#}运算符的计算顺序。

                                    \sssect{\#\#运算符}{lang.ppdir.macro.concat}
\constraint
\paragraph{}
任何一种宏定义形式的替换列表的开头或结尾都不应出现\tm{\#\#}预处理标记。

\semantic
\paragraph{}
如果在函数式宏的的替换列表中，形参的前面或后面紧跟着一个\tm{\#\#}预处理标记，则
该形参将替换为相应实参的预处理标记序列；但是，如果实参不包含预处理标记，则该形参
将替换为\textit{占位}预处理标记。\footnote{占位预处理标记不会出现在语法中，因为
它们是仅存在于翻译阶段\ref{tpit4}中的临时实体。}

\paragraph{}
对于对象式宏调用和函数式宏调用，在重新检查替换列表以获取更多要替换的宏名称之前，
将删除替换列表（不是从实参中）中的\tm{\#\#}预处理标记的每个实例，并将前面的预处
理标记与下一个预处理标记连接。占位预处理标记特殊处理：两个占位的连接导致单个占位
预处理标记，占位与非占位的连接导致非占位预处理标记。如果结果不是有效预处理标记，
则行为未定义。生成的标记可用于进一步的宏替换。未指定运算符的计算顺序。

\paragraph{}
\ex* 以下片断中：
\begin{lstlisting}
    #define hash_hash # ## #
    #define mkstr(a) # a
    #define in_between(a) mkstr(a)
    #define join(c, d) in_between(c hash_hash d)

    char p[] = join(x, y); // equivalent to
                           // char p[] = "x ## y";
\end{lstlisting}
展开在不同阶段产生：
\begin{lstlisting}
    join(x, y)
    in_between(x hash_hash y)
    in_between(x ## y)
    mkstr(x ## y)
    "x ## y"
\end{lstlisting}
换句话说，扩展\tm{hash\_hash}会产生一个新的标记，由两个相邻的\#符号组成，但这个
新的标记不是运算符。

                            \sssect{重扫描和进一步替换}{lang.ppdir.macro.rescan}
\paragraph{}
替换列表中的所有参数被替换并且\tm{\#}和\tm{\#\#}处理完成后，所有占位预处理标记都
将被删除。然后，将重新扫描生成的预处理标记序列，以及源文件的所有后续预处理标记，
以替换更多的宏名。

\paragraph{}
如果在扫描替换列表期间找到要替换的宏的名称（不包括源文件的其余预处理标记），则不
会替换该宏。此外，如果任何嵌套替换遇到要替换的宏的名称，则不会替换该宏。这些未替
换的宏名预处理标记将不再用于进一步替换，即使这些标记稍后（重新）在宏名预处理标记
将被替换的上下文中进行检查。

\paragraph{}
生成的完全宏替换的预处理标记序列不会作为预处理指令进行处理，即使它类似于预处理指
令，但其中的所有pragma一元运算符表达式都将按照下面\ref{lang.ppdir.pragmaop}中的
规定进行处理。

\paragraph{}
\ex* 有些情况下，不清楚替换是否嵌套。例如，给定以下宏定义：
\begin{lstlisting}
    #define f(a) a*g
    #define g(a) f(a)
\end{lstlisting}
调用
\begin{lstlisting}
    f(2)(9)
\end{lstlisting}
可能展开成
\begin{lstlisting}
    2*f(9)
\end{lstlisting}
或
\begin{lstlisting}
    2*9*g
\end{lstlisting}
严格合规的程序不允许依赖于这种未指明的行为。

                                   \sssect{宏定义作用域}{lang.ppdir.macro.scope}
\paragraph{}
宏定义持续（独立于块结构）直到遇到相应的\tm{\#undef}指令，或者（如果没有遇到）直
到预处理翻译单元结束。翻译阶段\ref{tpit4}后，宏定义不再有意义。

\paragraph{}
形如                                                                          \\
\mbox{\hspace{4em}\tm{\# undef} \nt{identifier new-line}}                     \\
的预处理指令使指定的标识符不再定义为宏名。如果指定的标识符当前未定义为宏名，则忽
略此指令。

\paragraph{}
\ex 此指令的最简单用法是定义``清单常量''，如
\begin{lstlisting}
    #define TABSIZE 100
    int table[TABSIZE];
\end{lstlisting}

\paragraph{}
\ex 下面定义一个函数式宏，其值是其参数的最大值。它的优点是可以处理任何兼容类型的
参数，并且可以生成内联代码，而不需要函数调用的开销。它的缺点是，第二次计算一个或
另一个参数（包括副作用），如果多次调用，则生成的代码多于一个函数。它也不能有它的
地址，因为它没有。
\begin{lstlisting}
    #define max(a, b) ((a) > (b) ? (a) : (b))
\end{lstlisting}
括号确保参数和结果表达式正确绑定。

\paragraph{}
\ex 为了说明重定义和复检查的规则，序列
\begin{lstlisting}
    #define x         3
    #define f(a)      f(x * (a))
    #undef  x
    #define x         2
    #define g         f
    #define z         z[0]
    #define h         g(~
    #define m(a)      a(w)
    #define w         0,1
    #define t(a)      a
    #define p()       int
    #define q(x)      x
    #define r(x,y)    x ## y
    #define str(x)    # x

    f(y+1) + f(f(z)) % t(t(g)(0) + t)(1);
    g(x+(3,4)-w) | h 5) & m
          (f)^m(m);
    p() i[q()] = { q(1), r(2,3), r(4,), r(,5), r(,) };
    char c[2][6] = { str(hello), str() };
\end{lstlisting}
产生
\begin{lstlisting}
    f(2 * (y+1)) + f(2 * (f(2 * (z[0])))) % f(2 * (0)) + t(1);
    f(2 * (2+(3,4)-0,1)) | f(2 * (~ 5)) & f(2 * (0,1))^m(0,1);
    int i[] = { 1, 23, 4, 5, };
    char c[2][6] = { "hello", "" };
\end{lstlisting}

\paragraph{}
\ex 为了说明创建字符串文本和连接标记的规则，序列
\begin{lstlisting}
    #define str(s)      # s
    #define xstr(s)     str(s)
    #define debug(s, t) printf("x" # s "= %d, x" # t "= %s", \
                            x ## s, x ## t)
    #define INCFILE(n)  vers ## n
    #define glue(a, b)  a ## b
    #define xglue(a, b) glue(a, b)
    #define HIGHLOW     "hello"
    #define LOW         LOW ", world"
    debug(1, 2);
    fputs(str(strncmp("abc\0d", "abc", '\4') // this goes away
          == 0) str(: @\n), s);
    #include xstr(INCFILE(2).h)
    glue(HIGH, LOW);
    xglue(HIGH, LOW)
\end{lstlisting}
产生
\begin{lstlisting}
    printf("x" "1" "= %d, x" "2" "= %s", x1, x2);
    fputs(
      "strncmp(\"abc\\0d\", \"abc\", '\\4') == 0" ": @\n",
      s);
    #include "vers2.h" (after macro replacement, before file access)
    "hello";
    "hello" ", world"
\end{lstlisting}
或才在字符串文本连接后，
\begin{lstlisting}
    printf("x1= %d, x2= %s", x1, x2);
    fputs(
      "strncmp(\"abc\\0d\", \"abc\", '\\4') == 0: @\n",
      s);
    #include "vers2.h"
    (after macro replacement, before file access)
    "hello";
    "hello, world"
\end{lstlisting}
宏定义中，\tm{\#}和\tm{\#\#}标记周围的空格是可选的。

\paragraph{}
\ex 为了说明占位预处理标记的规则，序列
\begin{lstlisting}
    #define t(x,y,z) x ## y ## z
    int j[] = { t(1,2,3), t(,4,5), t(6,,7), t(8,9,),
                t(10,,), t(,11,), t(,,12), t(,,) };
\end{lstlisting}
产生
\begin{lstlisting}
    int j[] = { 123, 45, 67, 89,
                10, 11, 12, };
\end{lstlisting}

\paragraph{}
\ex 为演示重定义规则，以下序列是有效的。
\begin{lstlisting}
    #define OBJ_LIKE      (1-1)
    #define OBJ_LIKE      /* white space */ (1-1) /* other */
    #define FUNC_LIKE(a)  ( a )
    #define FUNC_LIKE( a )( /* note the white space */ \
                            a /* other stuff on this line
                               */ )
\end{lstlisting}
但以下重定义是非法的：
\begin{lstlisting}
    #define OBJ_LIKE     (0)      // different token sequence
    #define OBJ_LIKE     (1 - 1)  // different white space
    #define FUNC_LIKE(b) ( a )    // different parameter usage
    #define FUNC_LIKE(b) ( b )    // different parameter spelling
\end{lstlisting}

\paragraph{}
\ex 最后，为显示变量参数列表宏工具：
\begin{lstlisting}
    #define debug(...)        fprintf(stderr, __VA_ARGS__)
    #define showlist(...)     puts(#__VA_ARGS__)
    #define report(test, ...) ((test)?puts(#test):\
                printf(__VA_ARGS__))
    debug("Flag");
    debug("X = %d\n", x);
    showlist(The first, second, and third items.);
    report(x>y, "x is %d but y is %d", x, y);
\end{lstlisting}
产生
\begin{lstlisting}
    fprintf(stderr,   "Flag" );
    fprintf(stderr,   "X = %d\n", x );
    puts( "The first, second, and third items." );
    ((x>y)?puts("x>y"):
                printf("x is %d but y is %d", x, y));
\end{lstlisting}

                                                 \ssect{行控制}{lang.ppdir.line}
\constraint
\paragraph{}
\tm{\#line}指令的字符串文本（如果存在）应为字符串文本。

\semantic
\paragraph{}
当前源行的\textit{行号}比翻译阶段\ref{tpit1}（\ref{env.concept.trans.phase}）中
源文件处理到当前标记时读取或引入的新行字符数大一。

\paragraph{}
形如                                                                          \\
\mbox{\hspace{4em}\tm{\# line} \nt{digit-sequence new-line}}                  \\
的预处理指令使实现的行为类似于以下源行序列以具有由数字序列指定的行号（解释为十进
制整数）的源行开始。数字序列不得指定零，也不得指定大于2147483647的数字。

\paragraph{}
形如                                                                          \\
\mbox{\hspace{4em}\tm{\# line} \nt{digit-sequence}
  \tm{\dq}\nt{s-char-sequence\tsub{opt}}\tm{\dq} \nt{new-line}}               \\
的预处理指令类似地设置假定的行号，并将源文件的假定名称更改为字符串文本的内容。

\paragraph{}
允许形如                                                                      \\
\mbox{\hspace{4em}\tm{\# line} \nt{pp-tokens new-line}}                       \\
（与前两种格式之一不匹配）的预处理指令。指令中\tm{line}后的预处理标记的处理与普
通文本中的处理相同（当前定义为宏名的每个标识符都由其预处理标记的替换列表替换）。
所有替换后产生的指令应与前两种形式中的一种相匹配，然后视情况进行处理。

                                             \ssect{Error指令}{lang.ppdir.error}
\semantic
\paragraph{}
形如                                                                          \\
\mbox{\hspace{4em}\tm{\# error} \nt{pp-tokens\tsub{opt} new-line}}            \\
的预处理指令使实现生成包含指定的预处理标记序列的诊断消息。

                                           \ssect{Pragma指令}{lang.ppdir.pragma}
\semantic
\paragraph{}
形如                                                                          \\
\mbox{\hspace{4em}\tm{\# pragma} \nt{pp-tokens\tsub{opt} new-line}}           \\
的预处理指令，如果预处理标记\tm{STDC}没有立即跟在指令中的\tm{pragma}（在任何宏替
换之前）\footnote{实现不需要在\tm{pragma}中执行宏替换，但除了在标准\tm{pragma}中
（其中\tm{STDC}紧跟\tm{pragma}），它是允许的。如果非标准pragma中宏替换的结果与标
准pragma的形式相同，则行为仍由实现定义；允许实现的行为与标准pragma的行为相同，但
不需要这样做。}之后，则会导致实现以实现定义方式运行。这种行为可能导致翻译失败，
或者导致翻译器或结果程序的行为不一致。将忽略实现无法识别的任何此类\tm{pragma}。

\paragraph{}
如果预处理标记\tm{STDC}立即跟在指令中的pragma（在任何宏替换之前）之后，则不会对
指令执行宏替换，并且指令应具有以下形式之一，\footnote{见``未来语言方向''
（\ref{lang.dir.pragma}）。}其含义在别处描述：                                \\
\mbox{\hspace{4em}\tm{\#pragma STDC FP\_CONTRACT} \nt{on-off-switch}}         \\
\mbox{\hspace{4em}\tm{\#pragma STDC FENV\_ACCESS} \nt{on-off-switch}}         \\
\mbox{\hspace{4em}\tm{\#pragma STDC CX\_LIMITED\_RANGE} \nt{on-off-switch}}   \\
\mbox{\hspace{4em}\nt{on-off-switch:} one of}                                 \\
\mbox{\hspace{10em}\tm{ON OFF DEFAULT}}

\fwdref{7.12.2，7.6.1，7.3.4}

                                                 \ssect{空指令}{lang.ppdir.null}
\semantic
\paragraph{}
形如                                                                          \\
\mbox{\hspace{4em}\tm{\#} \nt{new-line}}                                      \\
的预处理指令无作用。

                                           \ssect{预定义宏名}{lang.ppdir.predef}
\paragraph{}
下列子章节\footnote{见``未来语言方向''（\ref{lang.dir.predef}）。}中列出的预定义
宏的值（除\tm{\_\_FILE\_\_}和\tm{\_\_LINE\_\_}外）在整个翻译单元中保持不变。

\paragraph{}
这些宏名或标识符\tm{defined}都不应是\tm{define}或\tm{undef}预处理指令的主体。任
何其他预定义的宏名称都应以前导下划线开头，后跟一个大写字母或第二个下划线。

\paragraph{}
实现不应预定义宏\tm{\_\_cplusplus}，也不应在任何标准头中定义它。

\fwdref{7.1.2}

                                     \sssect{强制定义宏}{lang.ppdir.predef.mand}
\paragraph{}
以下宏名应由实现定义：                                                        \\
{
\newcommand{\mlst}[2]{
\vspace{5pt}
\begin{minipage}[t]{0.15\textwidth}
\tm{#1}
\end{minipage}
\hfill
\begin{minipage}[t]{0.85\textwidth}
#2
\end{minipage}
}
\mlst{\_\_DATE\_\_}{预处理翻译单元的翻译日期：格式为\tm{\dq{}Mmm dd yyyy\dq}的字
符串文本，其中月份名称与\tm{ascTime}函数生成的名称相同，如果值小于10，则\tm{dd}
的第一个字符为空格字符。如果翻译日期不可用，应提供实现定义的有效日期。}
\mlst{\_\_FILE\_\_}{当前源文件的推定名称（字符串文本）。\footnotemark}
\footnotetext{\label{fn177}推定的源文件名和行号可以通过\tm{\#line}指令更改。}
\mlst{\_\_LINE\_\_}{当前源行（整型常量）的推定行号（在当前源文件中）。
\tsup{\ref{fn177}}}
\mlst{\_\_STDC\_\_}{整型常量1，用于指示合规实现。}
\mlst{\_\_STDC\_HOSTED\_\_}{\hspace{4em}如果实现是宿主实现，则为整型常量1；否则
为0。}
\mlst{\_\_STDC\_VERSION\_\_}{\hspace{4em}整型常量\tm{201}\nt{ymm}\tm{L}。
\footnotemark}\footnotetext{该宏未在ISO/IEC 9899:1990中指定，在
ISO/IEC 9899:1990/Amd.1:1995中指定为\tm{199409L}，在ISO/IEC 9899:1999中指定为
\tm{199901L}。其目的是保留一个\tm{long int}类型的整型常量，随本国际标准的修订而
增加。}
\mlst{\_\_TIME\_\_}{预处理翻译单元的翻译时间：格式为\tm{\dq{}hh:mm:ss\dq}的字符
串文本，如\tm{ascTime}函数生成的时间。如果翻译时间不可用，则应提供实现规定的有效
时间。}
}

\fwdref{7.27.3.1}

                                      \sssect{环境相关宏}{lang.ppdir.predef.env}
\paragraph{}
以下宏名称由实现有条件地定义：                                                \\
{
\newcommand{\mlst}[2]{
\vspace{10pt}
\begin{minipage}[t]{0.15\textwidth}
\tm{#1}
\end{minipage}
\hfill
\begin{minipage}[t]{0.85\textwidth}
#2
\end{minipage}
}
\mlst{\_\_STDC\_ISO\_10646\_\_}{\hspace{4.5em}格式为\tm{yyyymmL}的整型常量（例如
\tm{199712L}）。如果定义了此符号，则当Unicode所需集中的每个字符存储在
\tm{wchar\_t}类型的对象中时，都应具有与该字符的短标识符相同的值。\textit{Unicode
所需集}包括ISO/IEC 10646定义的所有字符，以及指定年份和月份的所有修订和技术勘误。
如果使用其他编码，则不应定义宏，并且应定义实际使用的编码。}
\mlst{\_\_STDC\_MB\_MIGHT\_NEQ\_WC\_\_}{\hspace{8em}整型常量1，用于指示在
\tm{wchar\_t}编码中，当用作整型字符常量中的单个字符时，基本字符集的成员不需要具
有与其值相等的代码值。}
\mlst{\_\_STDC\_UTF\_16\_\_}{\hspace{3em}整型常量1，用于指示\tm{char16\_t}类型
的值是UTF-16编码。如果使用其他编码，则不应定义宏，实际使用的编码由实现定义。}
\mlst{\_\_STDC\_UTF\_32\_\_}{\hspace{3em}整型常量1，用于指示\tm{char32\_t}类型
的值是UTF-16编码。如果使用其他编码，则不应定义宏，实际使用的编码由实现定义。}
}

\fwdref{7.19，7.28}

                                     \sssect{条件特性宏}{lang.ppdir.predef.cond}
\paragraph{}
以下宏名称由实现有条件地定义：                                                \\
{
\newcommand{\mlst}[2]{
\vspace{10pt}
\begin{minipage}[t]{0.15\textwidth}
\tm{#1}
\end{minipage}
\hfill
\begin{minipage}[t]{0.85\textwidth}
#2
\end{minipage}
}
\mlst{\_\_STDC\_ANALYZABLE\_\_}{\hspace{5em}整型常量1，用于表示符合附录
\ref{analyze}（可分析性）中的规范。}
\mlst{\_\_STDC\_IEC\_559\_\_}{\hspace{3.5em}整型常量1，用于表示符合附录
\ref{fparith}（IEC 60559符点算术）中的规范。}
\mlst{\_\_STDC\_IEC\_559\_COMPLEX\_\_}{\hspace{8em}整型常量1，用于表示符合附录
\ref{comparith}（IEC 60559兼容复算术）中的规范。}
\mlst{\_\_STDC\_LIB\_EXT1\_\_}{\hspace{4em}整型常量\tm{201}\nt{ymm}\tm{L}，用于
表示符合附录\ref{bound}（边界检查接口）中的规范。\footnotemark}\footnotetext{其
目的是保留一个\tm{long int}类型的整型常量，随本国际标准的每次修订而增加。}
\mlst{\_\_STDC\_NO\_ATOMICS\_\_}{\hspace{5em}整型常量1，用于表示实现不支持原子类
型（包括\tm{\_Atomic}类型限定符）和\tm{<stdatomic.h>}头。}
\mlst{\_\_STDC\_NO\_COMPLEX\_\_}{\hspace{5em}整型常量1，用于表示实现不支持复类型
或\tm{<complex.h>}头。}
\mlst{\_\_STDC\_NO\_THREADS\_\_}{\hspace{5em}整型常量1，用于表示实现不支持
\tm{<complex.h>}头。}
\mlst{\_\_STDC\_NO\_VLA\_\_}{\hspace{3em}整型常量1，用于表示实现不支持变长数组或
变量修改类型。}
}

\paragraph{}
定义了\tm{\_\_STDC\_NO\_COMPLEX\_\_}的实现不应定义
\tm{\_\_STDC\_IEC\_559\_COMPLEX\_\_}。

                                       \ssect{Pragma运算符}{lang.ppdir.pragmaop}
\semantic
\paragraph{}
形如                                                                          \\
\mbox{\hspace{4em}\tm{\_Pragma (} \nt{string-literal} \tm{)}}                 \\
的一元运算符表达式按如下处理：通过删除任何编码前缀、删除前导和尾随双引号、将每个
转义序列\tm{\bs\dq}替换为双引号，并将每个转义序列\tm{\bs\bs}替换为单个反斜杠，可
以将字符串文本\textit{去字符串化}。生成的字符序列通过翻译阶段\ref{tpit3}进行处理
，以生成预处理标记，这些标记在执行时就像是pragma指令中的\nt{pp-token}一样。一元
运算符表达式中原来的四个预处理标记将被删除。

\paragraph{}
\ex* 形如
\begin{lstlisting}
    #pragma listing on "..\listing.dir"
\end{lstlisting}
的指令可以写成：
\begin{lstlisting}
    _Pragma ( "listing on \"..\\listing.dir\"" )
\end{lstlisting}
后一种形式以同样的方式处理，无论所示的字面上，还是宏替换的结果，如：
\begin{lstlisting}
    #define LISTING(x) PRAGMA(listing on #x)
    #define PRAGMA(x) _Pragma(#x)

    LISTING ( ..\listing.dir )
\end{lstlisting}

                                                   \sect{未来语言方向}{lang.dir}
                                                \ssect{符点类型}{lang.dir.float}
\paragraph{}
未来的标准化可能包括额外的浮点类型，包括范围更大、精度更高或两者都比
\tm{long double}高的类型。

                                               \ssect{标识符链接}{lang.dir.link}
\paragraph{}
在没有\tm{static}存储类说明符的文件作用域内声明具有内部链接的标识符是一个过时的
特性。

                                                 \ssect{外部名称}{lang.dir.extn}
\paragraph{}
将外部名称的有效字符数限制为少于255个字符（将每个通用字符名或扩展源字符视为单个
字符）是一个过时的特性，这是对现有实现的让步。

                                           \ssect{字符转义序列}{lang.dir.escape}
\paragraph{}
小写字母作为转义序列保留以供将来标准化。其他字符可用于扩展。

                                              \ssect{存储类说明符}{lang.dir.stc}
\paragraph{}
将存储类说明符放置在声明中声明说明符的开头之外是一个过时的特性。

                                            \ssect{函数声明子}{lang.dir.fctdecl}
\paragraph{}
使用带空括号的函数声明子（不是原型格式参数类型声明子）是一个过时特性。

                                               \ssect{函数定义}{lang.dir.fctdef}
\paragraph{}
使用带有独立参数标识符和声明列表（不是原型格式参数类型和标识符声明子）的函数定义
是一个过时的特性。

                                             \ssect{Pragma指令}{lang.dir.pragma}
\paragraph{}
其第一个预处理标记是\tm{STDC}的pragma被保留用于将来的标准化。

                                             \ssect{预定义宏名}{lang.dir.predef}
\paragraph{}
以\tm{\_\_STDC\_\_}开头的宏名称保留用于将来的标准化。

