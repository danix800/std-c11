\chptr{语言}{lang}

\sect{记号}{lang.notation}
\paragraph{}
本章中所用语法记号中，语法类别（非结束符）由\textit{斜体}表示，字面单词和字符集
成员（结束符）由\tm{粗体}表示。跟在非结束符后的冒号（\texttt{:}）引入其定义。可
选定义在独立行上列出，除非前加``one of''。可选符号由下标``opt''表示，如       \\
\synprd{\tm{\{} \nt{expression$_{opt}$} \tm{\}}}
表示括号括起来的可选表达式。

\paragraph{}
在主文本中引用语法类型时不再使用斜体且单词使用空格而不是连字符分隔。

\paragraph{}
附录\ref{synsum}给出语法总结。

\sect{概念}{lang.concept}

\ssect{标识符作用域}{lang.concept.scope}
\paragraph{}
标识符可以表示对象；函数；结构，联合或枚举标签或成员；类型定义名；标号名；宏名或
宏参数。同一标识符可以在程序中不同点表示不同实体。枚举成员称作\textit{枚举常量}。
宏名和宏参数不再考虑，因为在程序分析的语义阶段源文件中任何宏名已经被构成宏定义的
预处理标记替换掉。

\paragraph{}
对一个标识符所代表的不同实体，该标识符仅在程序的一个文本段内\textit{可见}（即可
用），该文本段称作标识符的\textit{作用域}。由同一标识符所表示的不同实体要么具有
不同作用域，要么处于不同命名空间中。存在四种作用域：函数、文件、块和函数原型。
（\textit{函数原型}指定义函数类型的函数声明。）

\paragraph{}
标号名是唯一一种具有\textit{函数作用域}的标识符。它可以用于（\tm{goto}语句中）其
出现的函数中任一位置，由其语法形态（跟上\tm{:}和语句）隐式声明。

\paragraph{}
任何其他标识符由其声明（声明子或类型说明符）所处位置确定作用域。如果声明该标识符
的声明子或类型说明符处理任何块或参数列表之外，则标识符具有\textit{文件作用域}，
在翻译单元结束处结束。如果声明标识符的声明符或类型说明符出现在块内或函数定义中的
参数声明列表中，则该标识符具有\textit{块作用域}，终止于关联块的末尾。如果声明标
识符的声明符或类型说明符出现在函数原型（不是函数定义的一部分）中的参数声明列表
中，则该标识符具有\textit{函数原型作用域}，终止于函数声明符的末尾。如果标识符在
同一命名空间中指定了两个不同的实体，则作用域可能会重叠。如果是这样，一个实体的作
用域（\textit{内作用域}）将严格结束在另一个实体的作用域（\textit{外作用域}）之
前。在内作用域中，标识符指代内作用域内声明的实体；在外作用域内声明的实体在内作用
域内被\textit{隐藏}（且不可见）。

\paragraph{}
除非另有明确规定，否则本国际标准使用``标识符''一词指某个实体（与句法结构相反），
它指相关命名空间中的实体，其声明在标识符出现时可见。

\paragraph{}
当且仅当两个标识符的作用域在同一点终止时，它们才具有\textit{相同的作用域}。

\paragraph{}
结构、联合和枚举标记的作用域在声明标记的类型说明符中的标记出现之后开始。每个枚举
常量的作用域在枚举子列表中的定义枚举子出现之后开始。任何其他标识符的作用域都在其
声明符完成之后开始。

\paragraph{}
作为一种特殊情况，类型名（不是标识符的声明）被认为具有一个作用域，该作用域如同从
类型名中出现如果未被省略标识符的位置之后开始。

\fwdref{6.7，6.5.2.2，6.9.1，6.4.2，6.10.3，6.2.3，6.10.2，6.8}

\ssect{标识符链接}{lang.concept.link}
\paragraph{}
可以使在不同作用域或同一作用域中声明多次的标识符通过称为\textit{链接}的过程引用
同一对象或函数。\footnote{不同的标识符之间没有链接。} 存在三种链接：外部、内部和
无链接。

\paragraph{}
在构成整个程序的一组翻译单元和库中，具有\textit{外部链接}的特定标识符的每个声明
都表示相同的对象或函数。在一个翻译单元中，具有\textit{内部链接}的标识符的每个声
明都表示相同的对象或函数。\textit{没有链接}的标识符的每个声明都表示一个唯一的实
体。

\paragraph{}
如果对象或函数的文件作用域标识符的声明包含存储类说明符\tm{static}，则该标识符具
有内部链接。\footnote{仅当函数声明在文件作用域内时，它才能包含静态存储类说明符；
请参见\ref{lang.dcl.stc}。}

\paragraph{}
对于用存储类说明符\tm{extern}声明的标识符，在该标识符的先前声明可见的作用域内，
\footnote{如\ref{lang.concept.scope}所述，后一个声明可能隐藏前一个声明。} 如果先
前声明指定内部或外部链接，则后面声明中标识符的链接与先前声明中指定的链接相同。如
果前面的声明不可见，或者前面的声明没有指定链接，那么标识符具有外部链接。

\paragraph{}
如果函数的标识符声明没有存储类说明符，则其链接的确定与使用存储类说明符
\tm{extern}声明的链接完全相同。如果对象的标识符声明具有文件作用域，并且没有存储
类说明符，则其链接是外部的。

\paragraph{}
以下标识符没有链接：声明为对象或函数以外的任何对象的标识符；声明为函数参数的标识
符；声明为没有存储类说明符\tm{extern}的对象的块作用域标识符。

\paragraph{}
如果在翻译单元中，相同的标识符同时具有内部链接和外部链接，则行为未定义。

\ssect{标识符命名空间}{lang.concept.namespace}
\paragraph{}
如果在翻译单元的任何位置都可以看到特定标识符的多个声明，那么语法上下文将对引用不
同实体的使用消除歧义。因此不同类别的标识符具有不同\textit{命名空间}，如下所示：
\begin{itemize}
  \item{\textit{标号名}（由标号声明和使用的语法来消除歧义）；}
  \item{结构，联合和枚举\textit{标记}（\textit{tags}）（由跟在关键字\tm{struct}，
    \tm{union}或\tm{enum}\footnote{尽管存在三种可能，实际只有一种命名空间。}后面
    来消除歧义）；}
  \item{结构或联合成员；每个结构或联合成员都有单独的命名空间（由通过\tm{.}或
    \tm{->}运算符访问成员的表达式类型来消除歧义）；}
  \item{所有其他标识符，称为\textit{普通标识符}（\textit{ordinary identifiers}）
    （在普通声明子中声明或声明为枚举常量）。}
\end{itemize}

\fwdref{6.7.2.2，6.8.1，6.7.2.1，6.5.2.3，6.7.2.3，6.8.6.1}

\ssect{对象存储期}{lang.concept.storage}
\paragraph{}
对象具有\textit{存储期}，以确定其生存期。有四种存储期：静态、线程、自动和分配。
分配存储期在第\ref{lib.util.mem}节描述。

\paragraph{}
对象的生存期指程序执行的一段期间，该期间内保证为对象保留存储。在生命期内，对象存
在，有一个常量地址\footnote{术语``常量地址''意味着在不同时间创建的两个对象的指针
可能相等。同一程序的两个不同执行期间内的地址可能不同。}，并保留其最后存储的值。
\footnote{易失性对象不需要显式的最后存储值。} 如果对象在其生存期之外被引用，则行
为未定义。当指针指向的对象（或刚刚指向的对象）到达其生命周期的末尾时，指针的值将
变得不确定。

\paragraph{}
标识符声明时没有存储类说明符\tm{\_\_Thread\_local}且具有外部或内部链接或存储类说
明符\tm{static}的对象，具有\textit{静态存储期}。它的生存期是程序的整个执行过程，
它的存储值在程序启动之前仅初始化一次。

\paragraph{}
用存储类说明符\tm{\_\_Thread\_local}声明其标识符的对象具有\textit{线程存储期}。
它的生存期是创建该对象的线程的整个执行过程，其存储值在线程启动时初始化。每个线程
有一个不同的对象，在表达式中声明名称的使用指向计算该表达式的线程关联的对象。试图
从与对象关联的线程以外的线程间接访问具有线程存储期的对象的结果由实现定义。

\paragraph{}
标识符声明为不带链接且不带存储类说明符\tm{static}的对象具有\textit{自动存储期}，
某些复合字面值也是如此。试图从与对象关联的线程以外的线程间接访问具有自动存储期对
象的结果由实现定义。

\paragraph{}
对于不是变长数组类型的对象，其生存期从进入与之关联的块开始，直到该块的执行以任何
方式结束为止。（进入一个包含的块或调用一个函数会挂起但不会结束当前块的执行。）如
果以递归方式进入块，则每次都会创建一个新的对象实例。对象的初始值不确定。如果为对
象指定了初始化，则每次在块的执行中到达声明或复合字面值时都会执行初始化；否则，每
次达到声明时，值都会变得不确定。

\paragraph{}
对于具有变长数组类型的对象，它的生存期从对象的声明直到程序的执行离开声明作用域。
\footnote{离开包含声明的最内块，或者在声明之前跳到该块或嵌入块中的某个点，将离开
声明的作用域。} 如果以递归方式进入作用域，则每次都会创建对象的新实例。对象的初始
值不确定。

\paragraph{}
具有结构或联合类型的非左值表达式，其中结构或联合包含具有数组类型的成员（递归地包
括所有包含的结构和联合的成员）指向一个具有自动存储期和\textit{临时生存期}的对象。
\footnote{访问数组成员时隐式获取此类对象的地址。} 其生存期从计算表达式时开始，其
初始值为表达式的值。它的生存期在包含全表达式或完整声明子的计算结束时结束。任何修
改临时生存期对象的尝试都会导致未定义行为。

\fwdref{6.7.6.2，6.5.2.5，6.7.6，6.5.2.2，6.7.9，6.8}

\ssect{类型}{lang.concept.type}
\paragraph{}
存储在对象中或由函数返回的值的含义由用于访问该值的表达式的类型决定。（声明为对象
的标识符是最简单的此类表达式；类型在标识符声明中指定。）类型分为对象类型（描述对
象的类型）和函数类型（描述函数的类型）。在翻译单元的不同点上，对象类型可能不完整
（缺乏足够的信息来确定该类型对象的大小）或完整（具有足够的信息）。\footnote{类型
在整个翻译单元中可能是不完整的或完整的，也可能在翻译单元中的不同点改变状态。}

\paragraph{}
声明为\tm{\_Bool}类型的对象存储值$0$和$1$。

\paragraph{}
声明为\tm{char}类型的对象足够存储基本执行字符集的任何成员。如果基本执行字符集的
成员存储在\tm{char}对象中，则其值保证为非负。如果\tm{char}对象中存储了任何其他字
符，则其值由实现定义，但应在该类型可以表示的值范围内。

\paragraph{}
有五种\textit{标准有符号整型}，分别被指定为\tm{signed char}、\tm{short int}、
\tm{int}、\tm{long int}和\tm{long long int}。（这些类型和其他类型可以用其他几种
方式指定，如\ref{lang.dcl.type}所述。）也可能存在实现定义的\textit{扩展有符号整
型}。\footnote{实现定义的关键字应具有\ref{lib.intro.reserved}节所述的保留用于任
何用途的标识符形式。} 标准和扩展有符号整型统称为\textit{有符号整型}。
\footnote{因此，本标准中关于有符号整型的任何语句也适用于扩展有符号整型。}

\paragraph{}
声明为\tm{signed char}类型的对象与``普通''\tm{char}对象占用相同的存储量。
``普通''\tm{int}对象具有执行环境体系结构建议的自然大小（足够存储头
\tm{<limits.h>}中定义的\tm{INT\_MIN}到\tm{INT\_MAX}范围内的任何值）。

\paragraph{}
对于每个有符号整型，都有一个对应的（但不同的）无符号整型（用关键字\tm{unsigned}
指定），它使用相同的存储量（包括符号信息），并且具有相同的对齐要求。与标准有符号
整型相对应的\tm{\_Bool}类型和无符号整型是\textit{标准无符号整型}。与扩展有符号整
型相对应的无符号整型是\textit{扩展无符号整型}。标准和扩展无符号整数类型统称为
\textit{无符号整型}。\footnote{因此，本标准中关于无符号整型的任何语句也适用于扩
展无符号整型。}

\paragraph{}
标准有符号整型和标准无符号整型统称为\textit{标准整型}；扩展有符号整型和扩展无符
号整型统称为\textit{扩展整型}。

\paragraph{}
对具有相同符号性和不同整数转换秩的任意两个整型（见\ref{lang.conv.arith.rank}），
整数转换秩较小的类型的值范围是另一类型值的子范围。

\paragraph{}
有符号整型的非负值范围是对应无符号整型的子范围，并且每种类型中相同值的表示形式相
同。\footnote{相同的表示和对齐要求意味着作为函数参数、函数返回值和联合成员的可互
换性。} 涉及无符号操作数的计算永远不会溢出，因为如果结果不能用无符号整型表示，则
结果取比结果类型可表示最大值加一之后的模。

\paragraph{}
存在三种实浮点类型：\tm{float}、\tm{double}和\tm{long double}。\footnote{见``未
来语言方向''（\ref{lang.dir.float}）。 } \tm{float}类型的值集是\tm{double}类型值
集的子集；\tm{double}类型的值集是\tm{long double}类型值集的子集。

\paragraph{}
存在三种\textit{复类型}，分别是\tm{float \_Complex}、\tm{double \_Complex}和
\tm{long double \_Complex}。\footnote{虚数类型规范见附录\ref{comparith}。}（复类
型是条件特性，不要求实现支持；请参见\ref{lang.ppdir.predef.cond}。）实浮点类型和
复类型统称为\textit{浮点类型}。

\paragraph{}
每个浮点类型都有一个对应的实类型，它始终是一个实浮点类型。对于实浮点类型，它是相
同的类型。对于复类型，它是通过从类型名称中删除关键字\tm{\_Complex}后的类型。

\paragraph{}
复类型具有与正好包含两个对应实类型元素的数组类型相同的表示和对齐要求；第一个元素
等于复数的实数部分，第二个元素等于复数的虚数部分。

\paragraph{}
\tm{char}类型、有符号和无符号整型以及浮点类型统称为\textit{基本类型}。基本类型是
完整的对象类型。即使实现将两个或多个基本类型定义为具有相同的表示，它们仍然是不同
的类型。\footnote{ 实现可以定义新的关键字，这些关键字提供了指定基本（或任何其他）
类型的可选方法；这不会违反所有基本类型都不同的要求。实现定义的关键字应具有
\ref{lib.intro.reserved}中所述的保留用于任何用途的标识符形式。}

\paragraph{}
三种类型\tm{char}、\tm{signed char}和\tm{unsigned char}统称为\textit{字符类型}。
实现应将\tm{char}定义为与\tm{signed char}或\tm{unsigned char}具有相同的范围、表
示和行为。\footnote{\tm{<limits.h>}中定义的\tm{CHAR\_MIN}将具有值$0$或
\tm{SCHAR\_MIN}中的一个，这可用于区分这两个选项。无论做出什么选择，\tm{char}都是
与其他两个类型不同的类型，并且两者都不兼容。}

\paragraph{}
\textit{枚举}由一组命名的整型常量值组成。每个不同的枚举构成不同的\textit{枚举类
型}。

\paragraph{}
类型\tm{char}、有符号和无符号整型以及枚举类型统称为\textit{整型}。整型和实浮点类
型统称为\textit{实类型}。

\paragraph{}
整型和浮点类型统称为\textit{算术类型}。每个算术类型属于一个\textit{类型域}：
\textit{实类型域}包含实类型，\textit{复类型域}包含复类型。

\paragraph{}
\tm{void}类型值集为空；它是无法完整的不完整对象类型。

\paragraph{}
可以从对象和函数类型构造任意数量的\textit{派生类型}，如下所示：
\begin{itemize}
  \item{\textit{数组类型}描述一组连续分配的非空对象，对象具有特定成员对象类型
    （称为\textit{元素类型}）。每当指定数组类型时，元素类型应完整。数组类型由其
    元素类型和数组中的元素个数刻画。数组类型说成是从它的元素类型派生，如果它的元
    素类型是$T$，则数组类型有时称为``$T$的数组''。从元素类型构造数组类型称为``数
    组类型派生''。}
  \item{\textit{结构类型}描述了一组顺序分配的非空成员对象（在某些情况下还有一
    个不完整的数组），每个对象都有一个可选的指定名称和可能不同的类型。}
  \item{\textit{联合类型}描述了一组重叠的非空成员对象，每个成员对象都有一个可选
    的指定名称和可能不同的类型。}
  \item{\textit{函数类型}描述具有指定返回类型的函数。函数类型由其返回类型及其参
    数的数量和类型刻画。函数类型说成是从其返回类型派生，如果它的返回类型是$T$，
    则该函数类型有时称为``返回$T$的函数''。从返回类型构造函数类型称为``函数类型
    派生''。}
  \item{\textit{指针类型}可以派生自函数类型或对象类型，称为\textit{引用类型}。指
    针类型描述一个对象，该对象的值提供对被引用类型的实体的引用。从引用类型$T$派
    生的指针类型有时称为``指向$T$的指针''。从引用类型构造指针类型称为``指针类型
    派生''。指针类型是完整的对象类型。}
  \item{\textit{原子类型}描述由\tm{\_Atomic(typename)}结构指定的类型。
    （原子类型是条件特性，不要求实现支持；参见\ref{lang.ppdir.predef.cond}。）}
\end{itemize}
这些构造派生类型的方法可以递归应用。

\paragraph{}
算术类型与指针类型统称\textit{标量类型}。数组和结构类型统称\textit{聚合类型}。
\footnote{注意聚合类型不包括联合类型，因为联合类型的对象一次只能包含一个成员。}

\paragraph{}
未知大小的数组类型是不完整的类型。对于该类型的标识符，可以通过在后面的声明中指定
大小（具有内部或外部链接）来完成。未知内容的结构或联合类型（如
\ref{lang.dcl.type.tag}所述）是不完整的类型。对于该类型的所有声明，通过稍后在同
一作用域内声明具有其定义内容的同一结构或联合标记来完成。

\paragraph{}
如果类型不完整且不是可变长度数组类型，则该类型具有\textit{已知的常量大小}。

\paragraph{}
数组、函数和指针类型统称为\textit{派生声明子类型}。类型$T$的\textit{声明子类型派
生}是通过应用从$T$的数组类型、函数类型或指向$T$的指针类型派生的派生声明子类型的
构造。

\paragraph{}
类型由其\textit{类型范畴}刻画，类型范畴是派生类型的最外层派生（如上文派生类型构造
中所述），或如果类型不包含派生类型，则是类型本身。

\paragraph{}
到目前为止提到的任何类型都是\textit{未限定类型}。每个未限定类型都有其类型
\footnote{见\ref{lang.dcl.qual}中关于限定数组和函数类型。}的几个\textit{限定版
本}，对应于\tm{const}、\tm{volatile}和\tm{restrict}限定符中的一个、两个或全部三
个的组合。类型的限定或未限定版本是属于同一类型范畴且具有相同表示和对齐要求的不同
类型。\footnote{相同的表示和对齐要求意味着作为函数参数、函数返回值和联合成员的可
互换性。\label{interchg}} 派生类型不由派生它的类型的限定符（如果有）限定。

\paragraph{}
此外，还有\tm{\_Atomic}限定符。使用\tm{\_Atomic}限定符表示原子类型。原子类型的大
小、表示和对齐方式不必与相应的非限定类型相同。因此，只要允许类型的原子版本以及类
型的其他限定版本，本标准就显式使用短语``原子、限定或非限定类型''。短语``限定或非
限定类型''，未特别提及原子时，不包括原子类型。

\paragraph{}
指向\tm{void}的指针应与指向字符类型的指针具有相同的表示和对齐要求。
\textsuperscript{\ref{interchg}} 同样，指向兼容类型的限定或未限定版本的指针应具
有相同的表示和对齐要求。结构类型的所有指针应具有彼此相同的表示和对齐要求。联合类
型的所有指针应具有彼此相同的表示和对齐要求。指向其他类型的指针不需要具有相同的表
示或对齐要求。

\paragraph{}
\ex ``\tm{float *}''指类型``指向\tm{float}的指针''。其类型范畴为指针而不是浮点类
型。该类型的const限定版本为``\tm{float * const}''，而``\tm{const float *}''不是
一个限定类型 --- 其类型为``指向const限定的\tm{float}的指针''，是限定类型的指针。

\paragraph{}
\ex ``\tm{struct tag (*[5])(float)}''指类型``指向返回\tm{struct tag}的函数的指针
的数组''。数组长度为$5$，函数有一个\tm{float}类型的参数。其类型范畴为数组。

\fwdref{6.2.7，6.7}

\ssect{类型表示}{lang.concept.repr}
\sssect{概论}{lang.concept.repr.general}
\paragraph{}
除本节说明外，所有类型的表示都未指明。

\paragraph{}
除了位字段之外，对象由一个或多个连续的字节序列组成，其字节数、顺序和编码为显式指
定，或由实现定义。

\paragraph{}
存储在无符号位字段中的值和\tm{unsigned char}类型的对象应使用纯二进制记号表示。
\footnote{一种使用二进制数字$0$和$1$的整数的位置表示法，其中用连续位表示的值是相
加的，以$1$开头，并乘以$2$的连续整数幂，可能最高位除外。（改编自\textit{American
National Dictionary for Information Processing Systems}。）一个字节包含
\tm{CHAR\_BIT}位，\tm{unsigned char}类型的值在$0$到$2^{CHAR\_BIT-1}$之间。}

\paragraph{}
存储在任何其他对象类型的非位字段对象中的值包含$n\times$\texttt{CHAR\_BIT}位组成，
其中$n$是该类型对象的以字节为单位的大小。该值可以复制到
\tm{unsigned char[}$n$\tm{]}类型的对象中（例如，通过\tm{memcpy}）；生成的字节集
称为该值的\textit{对象表示}。位域中存储的值由$m$位组成，其中$m$是为位域指定的大
小。对象表示是位域包含在可寻址存储单元中的一组$m$个位。具有相同对象表示形式的两
个值（NaN除外）相等，但相等的值可能具有不同的对象表示形式。

\paragraph{}
某些对象表示不需要表示对象类型的值。如果对象的存储值具有这样的表示形式，并且由非
字符类型的左值表达式读取，则行为未定义。如果这样的表示是由一个副作用产生的，该副
作用通过非字符类型的左值表达式修改对象的全部或任何部分，则行为未定义。
\footnote{因此，可以将自动变量初始化为陷阱表示，而不会导致未定义的行为，但只有将
适当的值存储在该变量中，才能使用该变量的值。} 这种表示称为陷阱表示。

\paragraph{}
当一个值存储在一个结构或联合类型的对象（包括成员对象）中时，对应于任何填充字节的
对象表示形式的字节值未指定。\footnote{因此，例如结构分配不需要复制任何填充位。}
结构或联合对象的值绝不是陷阱表示，即使结构或联合对象的成员的值可能是陷阱表示。

\paragraph{}
当一个值存储在联合类型的对象的成员中时，不对应于该成员但确实对应于其他成员的对象
表示形式的字节值未指定。

\paragraph{}
如果一个运算符应用于具有多个对象表示的值，则该对象表示将不会影响结果的值。
\footnote{当作为有效类型\tm{T}的对象时，具有相同有效类型\tm{T}的对象\tm{x}和
\tm{y}可能具有相同的值，但在其他上下文中具有不同的值。特别是，如果为T类型定义了
\tm{==}，那么\tm{x == y}并不意味着\tm{memcmp(\&x，\&y，sizeof(T)) == 0}。此外，
\tm{x == y}不一定意味着\tm{x}和\tm{y}具有相同的值；对\tm{T}类型值的其他操作可能
会区分它们。} 如果一个值存储在一个对象中，而该对象使用的类型对此值具有多个对象表
示，则未指定使用哪种表示，但不应生成陷阱表示。

\paragraph{}
原子类型对象的存取在\tm{memory\_order\_seq\_cst}语义下进行。

\fwdref{6.7，6.5，6.3.2.1，7.17.3}

\sssect{整型}{lang.concept.repr.int}
\paragraph{}
对于\tm{unsigned char}以外的无符号整型，对象表示的位应分为两组：值位和填充位（后
者不是必须）。如果有$N$个值位，则每个位应表示$1$到$2^{N−1}$之间的$2$的不同幂，使
得该类型的对象能够使用纯二进制表示法表示$0$到$2^{N−1}$之间的值；这称为值的表示。
任何填充位的值未指定。\footnote{填充位的某些组合可能会生成陷阱表示，例如填充位是
一个奇偶校验位。无论如何，有效值的任何算术运算都不能生成除作为异常条件的一部分之
外的陷阱表示，比如溢出，而无符号类型不会发生溢出。填充位的所有其他组合都是值位指
定的值的可选对象表示形式。}

\paragraph{}
对于有符号整型，对象表示的位应分为三组：值位、填充位和符号位。填充位不是必须；
\tm{signed char}不应该有任何填充位。只有一个符号位。每个值位的值应与相应无符号类
型的对象表示中的相同位具有相同的值（如果有符号类型中有$M$个值位，无符号类型中有
$N$个值位，则$M \le N$）。如果符号位为零，则不会影响结果值。如果符号位为$1$，则
应以下列方式修改该值：
\begin{itemize}
  \item{符号位为$0$的对应值取反（\textit{符号和量值}（\textit{sign and
    magnitude}））；}
  \item{符号位值为$-(2^M)$（\textit{二补码}（\textit{two's complement}））；}
  \item{符号位值为$-(2^M-1)$（\textit{一补码}（\textit{ones' complement}））；}
\end{itemize}
应用哪一个由实现定义，如符号位为$1$和所有值位为零的值（前两个），或带符号位和所
有值位为$1$（一补码）的值是陷阱表示还是正常值。在符号、量值和一补码的情况下，如
果该表示是一个正常值，则称为\textit{负零}。

\paragraph{}
如果实现支持负零，其应该仅能通过以下生成：
\begin{itemize}
  \item{运算符\tm{\&，|，\^，~，\tl{}\tl{}}和\tm{\tg{}\tg{}}，具有产生该值的操作
    数；}
  \item{运算符\tm{+，-，*，/}和\tm{\%}，其中一个操作数为负零，结果为零；}
  \item{基于以上情形的复合赋值运算符；}
\end{itemize}
未指明这些情况产生负零还是正常的零，以及当存于对象中时负零是否变成正常的零。

\paragraph{}
如果实现不支持负零，具有产生该值的操作数的运算符\tm{\&，|，\^，~，
\tl{}\tl{}}和\tm{\tg{}\tg{}}的行为未定义。

\paragraph{}
填充位的值未指定。\footnote{填充位的某些组合可能会生成陷阱表示，例如填充位是
一个奇偶校验位。无论如何，有效值的任何算术运算都不能生成除作为异常条件的一部分之
外的陷阱表示，比如溢出。填充位的所有其他组合都是值位指定的值的可选的对象表示。}
符号位为零的有符号整型的有效（非陷阱）对象表示是对应无符号类型的有效对象表示，且
应该表示相同值。对任何整型，所有位为零的对象表示应该是该类型的值零的表示。

\paragraph{}
整型的\textit{精度}指其用于表示值的位数，不包括符号位和填充位。整型的
\textit{宽度}与精度一样，但包括符号位；因此对无符号类型这两个值一样，而有符号类
型宽度比精度多一。

\ssect{兼容类型与合成类型}{lang.concept.compat}
\paragraph{}
两个相同类型为\textit{兼容类型}。额外的确定两个类型是否兼容的规则在类型说明
\ref{lang.dcl.type}，类型限定\ref{lang.dcl.qual}和声明子\ref{lang.dcl.decl}中描
述。\footnote{两个类型不需要完全等价才能兼容。} 另外，不同翻译单元中声明的两
个结构、联合或枚举类型的标记和成员满足以下要求，则它们是兼容的：如果一个声明了标
记，则另一个应使用相同的标记声明。如果在各自的翻译单元内的某个地方是完整的，则适
用以下附加要求：成员之间应存在一一对应的关系，使得每对对应的成员声明为兼容类型；
如果配对中的一个成员使用对齐说明符来声明，则另一个成员应用等效的对齐说明符声明；
如果配对中的一个成员使用名称声明，则另一个成员应该使用相同的名称声明。对于两个结
构，对应成员应该以相同的顺序声明。对于两个结构或联合体，对应的位域应该具有相同的
宽度。对于两个枚举，对应的成员应具有相同的值。

\paragraph{}
引用同一对象或函数的所有声明都应具有兼容类型；否则行为未定义。

\paragraph{}
\textit{合成类型}可以由两种兼容的类型构造；它是一种与这两种类型都兼容并满足以下
条件的类型：
\begin{itemize}
  \item{如两个类型均为数组类型，以下规则适用：
    \begin{itemize}
      \item{如其中一个是已知常量大小的数组，合成类型为该大小的数组。}
      \item{否则，如其中一个是变长数组，大小由未求值表达式指定，则行为未定义。}
      \item{否则，如其中一个是指定大小的变长数组，合成类型为该大小的变长数组。}
      \item{否则，如其中一个是未指定大小的变长数组，合成类型为未指定大小的变长数
        组。}
      \item{否则，两个类型均为未知大小的数组，合成类型为未知大小的数组。}
    \end{itemize}
    合成类型的元素类型为两个元素类型的合成类型。}
  \item{如果仅有一个是带参数类型列表（函数原型）的函数类型，则合成类型为带参数类
    型列表的函数原型。}
  \item{如果两个类型均为带参数类型列表的函数类型，合成参数类型列表中的参数类型为
    对应参数的合成类型。}
\end{itemize}
这些规则可以递归应用于两个类型派生自的类型。

\paragraph{}
对于具有内部或外部链接的标识符，其所在作用域中该标识符一个之前的声明可见，
\footnote{如\ref{lang.concept.scope}所述，后一个声明可能隐藏前一个声明。} 如果前
面的声明指定了内部或外部链接，则后面声明中的标识符类型将成为合成类型。

\fwdref{6.7.6.2}

\paragraph{}
\ex* 给定以下两个文件作用域声明：
\begin{lstlisting}
    int f(int (*)(), double (*)[3]);
    int f(int (*)(char*), double (*)[]);
\end{lstlisting}
为函数产生的合成类型为：
\begin{lstlisting}
    int f(int (*)(char*), double (*)[3]);
\end{lstlisting}

\ssect{对象对齐}{lang.concept.align}
\paragraph{}
完整的对象类型具有对齐要求，这些要求对可分配该类型对象的地址进行了限制。对齐是一
个实现定义的整数值，表示可以分配给定对象的连续地址之间的字节数。对象类型对该类型
的每个对象都施加对齐要求：可以使用\tm{\_Alignas}关键字请求更严格的对齐。

\paragraph{}
\textit{基本对齐}表示为小于或等于所有上下文中实现所支持的最大对齐的对齐，该对齐
等于\tm{\_Alignof(max\_align\_t)}。

\paragraph{}
\textit{扩展对齐}大于\tm{\_Alignof(max\_align\_t)}。是否支持任何扩展对齐以及支持
上下文由实现定义。具有扩展对齐要求的类型是\textit{过度对齐的类型}。
\footnote{每个过度对齐的类型都是或包含一个结构或联合类型，该结构或联合类型具有应
用扩展对齐的成员。}

\paragraph{}
对齐以\tm{size\_t}类型的值表示。有效的对齐仅包括由基本类型的\tm{\_Alignof}表达式
返回的所有值，以及附加的实现定义的一组值，可能为空。每个有效值应该为二的非负整数
幂。

\paragraph{}
对齐具有从\textit{弱}到\textit{强}或\textit{更严格}的顺序。更严格的对齐具有较大
的对齐值。满足对齐要求的地址也满足任何较弱的有效对齐要求。

\paragraph{}
完整类型的对齐要求可以使用\tm{\_AlignOf}表达式查询。类型\tm{char}、
\tm{signed char}和\tm{unsigned char}的对齐要求最低。

\paragraph{}
比较对齐是有意义的且提供了明显的结果：
\begin{itemize}
  \item{数值相等的两个对齐也相等。}
  \item{数值不等的两个对齐也不等。}
  \item{较大的对齐表示更严格的对齐。}
\end{itemize}

\sect{转换}{lang.conv}
\paragraph{}
一些运算符自动将操作数值从一种类型转换为另一种类型。本章节指定此类\textit{隐式转
换}所需的结果，以及由强制转换操作（显式转换）产生的结果。第
\ref{lang.conv.arith.usualarith}节中的列表总结了大多数普通运算符执行的转换；由第
\ref{lang.expr}节中对每个运算符的讨论进行补充。

\paragraph{}
除非另有明确说明，否则将操作数值转换为兼容类型不会导致值或表示形式发生更改。

\fwdref{6.5.4}

\ssect{算术操作数}{lang.conv.arith}
\sssect{布尔，字符与整数}{lang.conv.arith.rank}
\paragraph{}
每一个整型具有\textit{整型转换阶}，定义如下：
\begin{itemize}
  \item{两个有符号整型即使表示相同，其转换阶也不一样。}
  \item{有符号整型的阶应大于精度较低的有符号整型的阶。}
  \item{阶（\tm{long long int}）$>$阶（\tm{long int}）$>$阶（\tm{int}）$>$
    阶（\tm{short int}）$>$阶（\tm{signed char}）。}
  \item{任何无符号整型的阶应等于相应有符号整型的阶（如果有）。}
  \item{任何标准整型的阶应大于任何宽度相同的扩展整型的阶。}
  \item{阶（\tm{char}）$=$阶（\tm{signed char}）$=$阶（\tm{unsigned char}）。}
  \item{\tm{\_Bool}的阶小于所有其他标准整型的阶。}
  \item{枚举类型的阶等于兼容整型的阶（见\ref{lang.dcl.type.enum}）。}
  \item{扩展有符号整型相对于另一个具有相同精度的扩展有符号整型的阶由实现定义，但
    仍受用于确定整数转换阶的其他规则的约束。}
  \item{对于所有整型\tm{T1}、\tm{T2}和\tm{T3}，如果\tm{T1}的阶大于\tm{T2}，
    \tm{T2}的阶大于\tm{T3}，则\tm{T1}的阶大于\tm{T3}。}
\end{itemize}

\paragraph{}
在可以使用\tm{int}或\tm{unsigned int}的表达式中，可以使用以下内容：
\begin{itemize}
  \item{整型（\tm{int}或\tm{unsigned int}除外）对象或表达式，其整数转换阶小于或
    等于\tm{int}和\tm{unsigned int}的阶。}
  \item{\tm{\_Bool}，\tm{int}，\tm{signed int}或\tm{unsigned int}类型的位域。}
\end{itemize}
如果\tm{int}可以表示原始类型的所有值（如同宽度受限的位域），则该值将转换为
\tm{int}；否则将转换为\tm{unsigned int}。这些称为\textit{整型提升}。\footnote{整
型提升仅适用于：作为常规算术转换的一部分，应用于某些参数表达式、一元\tm{+}、
\tm{-}、和\tm{\~}运算符的操作数以及位移运算符的两个操作数，由各自的章节指定。}
所有其他类型都不受整型提升的影响。

\paragraph{}
整型提升保留值和符号。如前所述，``普通''\tm{char}是否被视为有符号由实现定义。

\fwdref{6.7.2.2，6.7.2.1}

\sssect{布尔类型}{lang.conv.arith.bool}
\paragraph{}
任何标量值转换为\tm{\_Bool}时，如果值等于$0$，则结果为$0$；否则结果为$1$。
\footnote{NaN不等于$0$，所以转换成$1$。}

\sssect{有符号和无符号整数}{lang.conv.arith.signed}
\paragraph{}
当一个整型的值被转换为除\tm{\_Bool}的另一个整型时，如果该值可以用新类型表示，则
该值不变。

\paragraph{}
否则，如果新类型为无符号，则通过重复加或减新类型可表示的最大值加一来转换该值，直
至该值在新类型的范围内。\footnote{该规则描述数学上而不是表达类型值的算术。}

\paragraph{}
否则，新类型为有符号，且值不能在其中表示；则结果或者由实现定义，或者产生实现定义
信号。

\sssect{实浮点与整型}{lang.conv.arith.fpint}
\paragraph{}
当实浮点类型的有限值转换为除\tm{\_Bool}以外的整型时，小数部分将被丢弃（即向零截
断）。如果整型不能表示整数部分的值，则行为未定义。\footnote{当实浮点类型的值转换
为无符号类型时，整型的值转换为无符号类型时执行的剩余操作不需要执行。因此，可移植
的实浮点值范围是$(-1,$\tm{U}\textit{type}\tm{\_MAX}$+1)$。}

\paragraph{}
当整型的值转换为实浮点类型时，如果要转换的值可以在新类型中精确表示，则该值不变。
如果要转换的值在可以表示的值范围内但不能精确表示，则结果是以实现定义的方式选择的
最接近的更高或最接近的较低可表示值。如果要转换的值超出了可以表示的值的范围，则行
为未定义。某些隐式转换的结果可能比新类型所要求的范围和精度更大（见
\ref{lang.conv.arith.usualarith}和\ref{lang.stmt.jmp.ret}）。

\sssect{实浮点类型}{lang.conv.arith.double}
\paragraph{}
当实浮点类型的值转换为实浮点类型时，如果要转换的值可以在新类型中精确表示，则该值
不变。如果要转换的值在可以表示的值范围内但不能精确表示，则结果是以实现定义的方式
选择的最接近的更高或最接近的较低可表示值。如果要转换的值超出可以表示的值的范围，
则行为未定义。某些隐式转换的结果可能比新类型所要求的范围和精度更大（见
\ref{lang.conv.arith.usualarith}和\ref{lang.stmt.jmp.ret}）。

\sssect{复类型}{lang.conv.arith.cmpl}
\paragraph{}
当复类型的值转换为另一个复类型时，实部和虚部都遵循对应实类型的转换规则。

\sssect{实数与复数}{lang.conv.arith.rcmpl}
\paragraph{}
当实类型的值转换为复类型时，复数结果值的实数部分由转换为相应实数类型的规则确定，
复数结果值的虚部为正零或无符号零。

\paragraph{}
当复类型的值转换为实类型时，将丢弃复数值的虚部，并根据对应实类型的转换规则转换实
数部分的值。

\sssect{常规算术转换}{lang.conv.arith.usualarith}
\paragraph{}
许多期望算术类型的操作数的运算符以类似的方式进行转换并产生结果类型。目的是确定操
作数和结果的通用\textit{实类型}。对于指定的操作数，每个操作数都会在不改变类型域
的情况下转换为其对应的实类型是公共实类型的类型。除非另有明确说明，否则公共实类型
也是结果的对应实类型，如果它们相同，则其类型域是操作数的类型域，否则是复类型。
这种模式称为\textit{常规算术转换}：
\begin{itemize}
  \item{首先，如果其中任一操作数的对应实类型为\tm{long double}，则另一个操作数将
    在不改变类型域的情况下转换为对应实类型为\tm{long double}类型。}
  \item{否则，如果其中一个操作数的对应实类型为\tm{double}，则另一个操作数将在不
    改变类型域的情况下转换为其对应实类型为\tm{double}的类型。}
  \item{否则，如果其中任一操作数的对应实类型为\tm{float}，则另一个操作数奖在不改
    变类型域的情况下转换为其对应实类型为\tm{float}的类型。\footnote{例如，
    \tm{double \_Complex}和\tm{float}的加法只需要将\tm{float}操作数转换为
    \tm{double}（并产生\tm{double \_Complex}结果）。}}
  \item{否则，对两个操作数执行整型提升。那么以下规则将适用于提升的操作数：
    \begin{itemize}
      \item{如果两个操作数具有相同类型则不再进行转换。}
      \item{否则，如果两个操作数都为有符号整型或都为无符号整型，则具有较小整型转
        换阶类型的操作数将转换为具有较大阶的操作数类型。}
      \item{否则，如果无符号整型的操作数的阶大于或等于另一个操作数类型的阶，则有
        符号整型的操作数将转换为无符号整型的操作数类型。}
      \item{否则，如果有符号整型的操作数类型可以表示无符号整型的操作数类型的所有
        值，则无符号整型的操作将转换为有符号整型的操作数类型。}
      \item{否则，两个操作数都转换为无符号整型，对应于有符号整型的操作数类型。}
    \end{itemize}}
\end{itemize}

\paragraph{}
浮点操作数的值和浮点表达式的结果可以表示在比类型所需的范围和精度更大的范围和精度
上；因此不改变类型。\footnote{转换和赋值操作符仍然需要删除额外的范围和精度。}

\ssect{其他操作数}{lang.conv.other}
\sssect{左值，数组和函数}{lang.conv.other.desig}
\paragraph{}
\textit{左值}是一个表达式（对象类型不是\tm{void}），可能指定一个对象；
\footnote{名称``左值''最初来自赋值表达式\tm{E1 = E2}，其中左操作数\tm{E1}需要是
（可修改的）左值。把它视为表示对象的``定位器''可能更好。有时被称为``右值''的东西
在本国际标准中被描述为``表达式的值''。\linebreak
左值的一个明显示例是对象的标识符。另一示例是，如果\tm{E}是作为指向对象的指针的一
元表达式，则\tm{*E}是指代\tm{E}所指向的对象的左值。} 如果左值在求值时没有指代对
象，则行为未定义。当一个对象被称为具有特定类型时，该类型由用于指定该对象的左值指
定。\textit{可修改左值}指非数组类型，非不完整的类型，非const限定类型，且如果是结
构或联合，则没有任何成员（递归地包括所包含聚合或联合的任何成员或元素）具有常限定
类型。

\paragraph{}
除作为\tm{sizeof}运算符的操作数，一元\tm{\&}运算符，\tm{++}运算符，\tm{-}运算符
或作为\tm{.}运算符或赋值运算符的左操作数，非数组类型的左值被转换为存储在指定对象
中的值（并且不再是左值）；称为\textit{左值转换}。如果左值具有限定类型，则该值具
有左值类型的非限定版本；另外，如果左值具有原子类型，则该值具有左值类型的非原子版
本；否则，该值具有左值的类型。如果左值具有不完整类型且不是数组类型则行为未定义。
如果左值指定了一个自动存储期的对象，该对象可以使用\tm{register}存储类声明（从不
使用其地址），并且该对象未初始化（未使用初始化声明，并且在使用之前未对其进行任何
赋值）），则行为未定义。

\paragraph{}
除作为\tm{sizeof}运算符或一元\tm{\&}运算符的操作数，或者是用于初始化数组的字符串
文字，否则将类型为``...类型的数组''的表达式转换成类型为``指向...类型的指针''的表
达式，指向数组对象的初始元素，且不是左值。如果数组对象具有寄存器存储类，则行为未
定义。

\paragraph{}
\textit{函数指示符}指具有函数类型的表达式。除作为\tm{sizeof}运算符\footnote{由于
不会发生此转换，因此\tm{sizeof}运算符的操作数仍然是函数指示符，并且违反了
\ref{lang.expr.unary.sizeof}中的约束。} 或一元\tm{\&}运算符的操作数，类型为``返
回...类型的函数''的函数指示符将转换成类型为``指向返回...类型的函数的指针''的表达
式。

\fwdref{6.5.3.2，6.5.16，7.19，6.7.9，6.5.2.4，6.5.3.1，6.5.3.4，6.5.2.3}

\sssect{void}{lang.conv.other.void}
\paragraph{}
\textit{void表达式}（具有\tm{void}类型的表达式）的（不存在）值不得以任何方式使用
，并且隐式或显式转换（除转换成\tm{void}）不应用于此类表达式。如果将任何其他类型
的表达式计算为\tm{void}表达式，则会丢弃其值或指示符。（\tm{void}表达式为其副作用
而求值。）

\sssect{指针}{lang.conv.other.ptr}
\paragraph{}
指向\tm{void}的指针可以转换为指向任何对象类型的指针。指向任何对象类型的指针可以
转换为指向\tm{void}的指针，然后再转回；结果应该等于原指针。

\paragraph{}
对于任何限定符$q$，指向非$q$限定类型的指针可以转换为指向该类型的$q$限定版本的指
针；存储在原指针和转换指针中的值应相等。

\paragraph{}
值为$0$的整型常量表达式或转换为\tm{void *}类型的这种表达式，称为\textit{空指针常
量}。\footnote{\tm{<stddef.h>}（或其他头）中的宏\tm{NULL}定义为零指针常量；见
\ref{lib.def}。} 如果将零指针常量转换为指针类型，则结果指针，称为\textit{零指针}
，与指向任何对象或函数的指针进行比较将保证不等。

\paragraph{}
将零指针转换为另一种指针类型会产生该类型的零指针。任何两个零指针都应该相等。

\paragraph{}
整数可以转换为任何指针类型。除之前指定，结果由实现定义，可能未正确对齐，可能不指
向引用类型的实体，或者可能是陷阱表示。\footnote{用于将指针转换为整数或整数到指针
的映射函数旨在与执行环境的寻址结构一致。}

\paragraph{}
任何指针类型都可以转换为整数类型。除之前指定外，结果由实现定义。如果结果无法以整
数类型表示，则行为未定义。结果不必在任何整数类型的值范围内。

\paragraph{}
指向对象类型的指针可以转换为指向不同对象类型的指针。如果对于引用的类型，结果指针
未正确对齐\footnote{通常，``正确对齐''这个概念是传递性的：如果指向类型A的指针正
确对齐地指向类型B的指针，而B指针又指向类型C的指针，则指向类型A的指针是正确对齐指
向类型C的指针}，则行为未定义。否则，当再次转换回时，结果将等于原指针。当指向对象
的指针转换为指向字符类型的指针时，结果指向对象的最低寻址字节。结果的连续增量（直
到对象的大小）产生指向对象的剩余字节的指针。

\paragraph{}
指向一种类型的函数的指针可以被转换为指向另一种类型的函数的指针并且再次返回；结果
应该等于原指针。如果转换的指针用于调用类型与引用类型不兼容的函数，则行为未定义。

\fwdref{6.5.4，6.5.9，7.20.1.4，6.5.16.1}

\sect{词法元素}{lang.lex}
\syntax
\paragraph{}
\synsym{token}
  \synprd{\nt{keyword}}
  \synprd{\nt{identifier}}
  \synprd{\nt{constant}}
  \synprd{\nt{string-literal}}
  \synprd{\nt{punctuator}}
\synsym{preprocessing-token}
  \synprd{\nt{header-name}}
  \synprd{\nt{identifier}}
  \synprd{\nt{pp-number}}
  \synprd{\nt{character-constant}}
  \synprd{\nt{string-literal}}
  \synprd{\nt{punctuator}}
  \synprd[]{除以上所列的每一个非空白字符}

\constraint
\paragraph{}
转换为标记的每个预处理标记应具有关键字，标识符，常量，字符串文本或标点符号的词法
形式。

\semantic
\paragraph{}
\textit{标记}（\textit{token}）是翻译阶段\ref{tpit7}和\ref{tpit8}中语言的最小词
法元素。标记的类别是包括关键字，标识符，常量，字符串文本和标点符号。预处理标记是
翻译阶段\ref{tpit3}到\ref{tpit6}中语言最小的词法元素。预处理标记的类别是包括头名
称，标识符，预处理数字，字符常量，字符串文本，标点符号和词法上不匹配其他预处理标
记类别的单个非空白字符。\footnote{在翻译阶段\ref{tpit4}内部使用了另一类别，即占
位标记（见\ref{lang.ppdir.macro.concat}）；它不能出现在源文件中。} 如果\tm{\sq}
或\tm{\dq}字符匹配最后一个类别，则行为未定义。预处理标记可以用\textit{空格}分隔
；这包括注释（稍后描述）或\textit{空白字符}（空格，水平制表符，换行符，垂直制表
符或换页符）或两者均有。如\ref{lang.ppdir}所述，在翻译阶段\ref{tpit4}的某些情况
下，空格（或不存在）不仅仅是预处理标记分隔。空格可能只出现在预处理标记中作为头名
称的一部分或在字符常量或字符串文本中的引号字符之间。

\paragraph{}
如果输入流到达某个的字符被解析为预处理标记，下一个预处理标记是可能构成一个预处理
标记的最长序列。此规则有一个例外：头名称预处理标记仅在\tm{\#include}预处理指令
和\tm{\#pragma}指令内的实现定义位置中被识别。在这样的上下文中，可以是头名称或字
符串文字的字符序列被识别为前者。

\paragraph{}
\ex 程序片段\tm{1Ex}被解析为预处理数字标记（不是一个有效的浮点或整型常量标记），
即使解析为预处理标记\tm{1}和\tm{Ex}可能产生有效表达式（例如，如果\tm{Ex}是定义为
\tm{+1}的宏。类似地，程序片段\tm{1E1}被解析为预处理数字（一个是有效的浮点常量标
记），无论\tm{E}是否是宏名。

\paragraph{}
\ex 程序片断\tm{x+++++y}被分析成\tm{x ++ ++ + y}，违背了自增运算符约束，即使分析
成\tm{x ++ + ++ y}可以产生正确的表达式。

\fwdref{6.4.4.4，6.4.9，6.5，6.4.4.2，6.4.7，6.10.3，6.5.2.4，6.5.3.1，6.10，
6.4.8，6.4.5}

\ssect{关键字}{lang.lex.keyword}
\syntax
\paragraph{}
\synsym[one of]{keyword}
\bgroup
\newcommand{\kwgrp}[4][\linebreak]{\synprd[#1]{\makebox[24em]{
      \makebox[8em][l]{\tm{#2}}
      \makebox[8em][l]{\tm{#3}}
      \makebox[8em][l]{\tm{#4}}}}}
  \kwgrp{auto}      {if}        {unsigned}
  \kwgrp{break}     {inline}    {void}
  \kwgrp{case}      {int}       {volatile}
  \kwgrp{char}      {long}      {while}
  \kwgrp{const}     {register}  {\_Alignas}
  \kwgrp{continue}  {restrict}  {\_Alignof}
  \kwgrp{default}   {return}    {\_Atomic}
  \kwgrp{do}        {short}     {\_Bool}
  \kwgrp{double}    {signed}    {\_Complex}
  \kwgrp{else}      {sizeof}    {\_Generic}
  \kwgrp{enum}      {static}    {\_Imaginary}
  \kwgrp{extern}    {struct}    {\_Noreturn}
  \kwgrp{float}     {switch}    {\_Static\_assert}
  \kwgrp{for}       {typedef}   {\_Thread\_local}
  \kwgrp[]{goto}    {union}     {}
\egroup

\semantic
\paragraph{}
上述标记（大小写敏感）保留用作关键字（翻译阶段\ref{tpit7}和\ref{tpit8}），不得另
行使用。关键字\tm{\_Imaginary}为指定虚类型而保留。\footnote{虚类型的一种可能的规
范见附录\ref{comparith}。}

\ssect{标识符}{lang.lex.id}
\sssect{概论}{lang.lex.id.general}
\syntax
\paragraph{}
\synsym{identifier}
\synprd{\nt{identifier-nondigit}}
\synprd{\nt{identifier identifier-nondigit}}
\synprd{\nt{identifier digit}}
\synsym{identifier-nondigit}
\synprd{\nt{nondigit}}
\synprd{\nt{universal-character-name}}
\synprd{其他实现定义字符}
\synsym[one of]{nondigit}
\synprd{\tm{\_  a b c d e f g h i j k l m}}
\synprd{\tm{\ \ n o p q r s t u v w x y z}}
\synprd{\tm{\ \ A B C D E F G H I J K L M}}
\synprd{\tm{\ \ N O P Q R S T U V W X Y Z}}
\synsym[one of]{digit}
\synprd[]{\tm{0 1 2 3 4 5 6 7 8 9}}

\semantic
\paragraph{}
标识符是由非数字字符（包括下划线\tm{\_}、小写和大写拉丁字母以及其他字符）和数字
组成的序列，用于指定\ref{lang.concept.scope}中所述的一个或多个实体。小写和大写字
母是不同的。标识符的最大长度没有特定限制。

\paragraph{}
标识符中的每个通用字符名称应指定一个字符，其ISO/IEC 10646中的编码属于
\ref{uchar.range}中规定的范围之一。\footnote{在链接器不能接受扩展字符的系统上，
可以使用通用字符名的编码来形成有效的外部标识符。例如，某些未使用的字符或字符序列
可用于将\tm{\bs{}u}编码为通用字符名。扩展字符可能产生一个长的外部标识符。} 初始
字符不应是表示字符编码属于\ref{uchar.disallowed}规定范围之一的通用字符名。实现可
能允许不属于基本源字符集的多字节字符出现在标识符中；允许哪些字符及其与通用字符名
的对应关系由实现定义。

\paragraph{}
当预处理标记在翻译阶段\ref{tpit7}转换为标记时，如果预处理标记可以转换为关键字或
标识符，则它将转换为关键字。

\implimit
\paragraph{}
如\ref{env.env.limit.trans}中所讨论的，实现可以限制标识符中有意义的初始字符的数
量；\textit{外部名称}（具有外部链接的标识符）的限制可能比\textit{内部名称}（宏名
称或没有外部链接的标识符）的限制更严格。标识符中有意义的字符数由实现定义。

\paragraph{}
任何有意义字符不同的标识符都是不同的标识符。如果两个标识符仅在无意义字符上不同，
则行为未定义。

\fwdref{6.4.3，6.10.3}

\sssect{预定义标识符}{lang.lex.id.predef}
\semantic
\paragraph{}
翻译器应该隐式声明标识符\tm{\_\_func\_\_}，如同每一个函数定义的起始花括号紧跟上
声明
\begin{lstlisting}
    static const char __func__[] = "function-name";
\end{lstlisting}
这里\textit{function-name}为词法包含函数名。\footnote{由于名称\tm{\_\_func\_\_}
保留给实现（\ref{lib.intro.reserved}）使用，如果使用名称\tm{\_\_func\_\_}显式声
明任何其他标识符，则行为未定义。}

\paragraph{}
此名称如同隐式声明用源字符集书写然后转换为执行字符集进行编码，如翻译阶段
\ref{tpit5}所示。

\paragraph{}
\ex* 考虑代码段：
\begin{lstlisting}
    #include <stdio.h>
    void myfunc(void) {
      printf("%s\n", __func__);
      /* ... */
    }
\end{lstlisting}
每次调用函数将向标准输出流打印：
\begin{lstlisting}
    myfunc
\end{lstlisting}

\fwdref{6.9.1}

\ssect{通用字符名}{lang.lex.univ}
\syntax
\paragraph{}
\synsym{universal-character-name}
  \synprd{\tm{\bs{}u} \nt{hex-quad}}
  \synprd{\tm{\bs{}U} \nt{hex-quad hex-quad}}
\synsym{hex-quad}
  \synprd[]{\nt{hexadecimal-digit hexadecimal-digit hexadecimal-digit
                hexadecimal-digit}}

\constraint
\paragraph{}
通用字符名不应指定短标识符小于00A0的字符，除0024（\tm{\$}）、0040（\tm{@}）或
0060（\tm{\sq}）外，也不应指定D800到DFFF范围内的字符。\footnote{这些禁止的字符是
基本字符集中的字符以及ISO/IEC 10646为控制字符、DELETE字符和S区域（保留供UTF-16使
用）保留的代码位置。}

\desc
\paragraph{}
通用字符名可用于标识符，字符常量和字符串文本中，以表示不属于基本字符集中的字符。

\semantic
\paragraph{}
通用字符名\tm{\bs{}U}\textit{nnnnnnnn}表示8位数字短标识符（由ISO/IEC 10646指定）
为\linebreak\textit{nnnnnnnn}\footnote{字符的短标识符首次在ISO/IEC
10646-1:1993/Amd.9:1997中指定。}的字符。类似的，通用字符名
\tm{\bs{}u}\textit{nnnn}表示4位数字短标识符为\textit{nnnn}的字符（其8位数字短标
识符为0000\textit{nnnn}）。

\ssect{常量}{lang.lex.const}
\syntax
\paragraph{}
\synsym{constant}
  \synprd{\nt{integer-constant}}
  \synprd{\nt{floating-constant}}
  \synprd{\nt{enumeration-constant}}
  \synprd[]{\nt{character-constant}}

\constraint
\paragraph{}
每个常量应具有类型且常量值应在其类型可表示值范围内。

\semantic
\paragraph{}
每个常量具有类型，由其形式和值确定，如后文详述。

\sssect{整数常量}{lang.lex.const.int}
\syntax
\paragraph{}
\synsym{integer-constant}
  \synprd{\nt{decimal-constant integer-suffix$_{opt}$}}
  \synprd{\nt{octal-constant integer-suffix$_{opt}$}}
  \synprd{\nt{hexadecimal-constant integer-suffix$_{opt}$}}
\synsym{decimal-constant}
  \synprd{\nt{nonzero-digit}}
  \synprd{\nt{decimal-constant digit}}
\synsym{octal-constant}
  \synprd{\tm{0}}
  \synprd{\nt{octal-constant octal-digit}}
\synsym{hexadecimal-constant}
  \synprd{\nt{hexadecimal-prefix hexadecimal-digit}}
  \synprd{\nt{hexadecimal-constant hexadecimal-digit}}
\synsym[one of]{hexadecimal-prefix}
  \synprd{\tm{0x 0X}}
\synsym[one of]{nonzero-digit}
  \synprd{\tm{0 1 2 3 4 5 6 7 8 9}}
\synsym[one of]{octal-digit}
  \synprd{\tm{0 1 2 3 4 5 6 7}}
\synsym[one of]{hexadecimal-digit}
  \synprd{\tm{0 1 2 3 4 5 6 7 8 9}}
  \synprd{\tm{a b c d e f}}
  \synprd{\tm{A B C D E F}}
\synsym{integer-suffix}
  \synprd{\nt{unsigned-suffix long-suffix$_{opt}$}}
  \synprd{\nt{unsigned-suffix long-long-suffix}}
  \synprd{\nt{long-suffix unsigned-suffix$_{opt}$}}
  \synprd{\nt{long-long-suffix unsigned-suffix$_{opt}$}}
\synsym[one of]{unsigned-suffix}
  \synprd{\tm{u U}}
\synsym[one of]{long-suffix}
  \synprd{\tm{l L}}
\synsym[one of]{long-long-suffix}
  \synprd[]{\tm{ll LL}}

\desc
\paragraph{}
整数常量以数字开始，但没有小数点或指数部分。可能有前缀指定其基和后缀指定其类型。

\paragraph{}
十进制常数以非零数字开头，由一系列十进制数字组成。八进制常量由前缀\tm{0}（可选）
和数字\tm{0}到\tm{7}的序列组成。十六进制常量由前缀\tm{0x}或\tm{0X}后跟十进制数字
序列和字母\tm{a}（或\tm{A}）到\tm{f}（或\tm{F}）组成，分别具有值10到15。

\semantic
\paragraph{}
十进制常量的值以10为基数计算；八进制常量的值以8为基数计算；十六进制常量的值以16
为基数计算。词法上第一个数字是最高位。

\paragraph{}
整数常量的类型是对应列表中可以表示其值的第一个。
\begin{table}
  \newcommand{\li}{\tm{long int}}
  \newcommand{\lli}{\tm{long long int}}
  \newcommand{\ui}{\tm{unsigned int}}
  \newcommand{\uli}{\tm{unsigned long int}}
  \newcommand{\ulli}{\tm{unsigned long long int}}
  \centering
  \begin{tabular}{l||l|l}
    后缀 & 十进制常量 & 八进制或十六进制常量                                  \\
    \hline\hline
    无 & \tm{int} & \tm{int}                                                  \\
       & \li      & \lli                                                      \\
       & \lli     & \li                                                       \\
       &          & \uli                                                      \\
       &          & \lli                                                      \\
       &          & \ulli                                                     \\
    \hline
    \tm{u}或\tm{U} & \ui   & \ui                                              \\
                   & \uli  & \uli                                             \\
                   & \ulli & \ulli                                            \\
    \hline
    \tm{l}或\tm{L} & \li  & \li                                               \\
                   & \lli & \uli                                              \\
                   &      & \lli                                              \\
                   &      & \ulli                                             \\
    \hline
    \tm{u}或\tm{U}和 & \uli  & \uli                                           \\
    \tm{l}或\tm{L}   & \ulli & \ulli                                          \\
    \hline
    \tm{ll}或\tm{LL} & \lli & \lli                                            \\
                     &      & \ulli                                           \\
    \hline
    \tm{u}或\tm{U}和 & \ulli & \ulli                                          \\
    \tm{ll}或\tm{LL} &       &
  \end{tabular}
\end{table}

\paragraph{}
如果整数常量不能由其列表中的任何类型表示，它可能具有扩展整型，如果扩展整型可以表
示其值的话。如果常量列表中的所有类型都有符号，则扩展整型应有符号。如果常量列表中
的所有类型都是无符号的，则扩展整型应是无符号的。如果列表同时包含有符号和无符号类
型，则扩展整型可以是有符号或无符号类型。如果整数常量不能由其列表中的任何类型表示
且没有扩展的整型，则整数常量没有类型。

\pagebreak

\sssect{浮点常量}{lang.lex.const.float}
\syntax
\paragraph{}
\synsym{floating-constant}
  \synprd{\nt{decimal-floating-constant}}
  \synprd{\nt{hexadecimal-floating-constant}}
\synsym{decimal-floating-constant}
  \synprd{\nt{fractional-constant exponent-part$_{opt}$
              floating-suffix$_{opt}$}}
  \synprd{\nt{digit-sequence exponent-part floating-suffix$_{opt}$}}
\synsym{hexadecimal-floating-constant}
  \synprd{\nt{hexadecimal-prefix hexadecimal-fractional-constant}}
    \synprd{\hspace{6em}\nt{binary-exponent-part floating-suffix$_{opt}$}}
  \synprd{\nt{hexadecimal-prefix hexadecimal-digit-sequence}}
    \synprd{\hspace{6em}\nt{binary-exponent-part floating-suffix$_{opt}$}}
\synsym{fractional-constant}
  \synprd{\nt{digit-sequence$_{opt}$} \tm{.} \nt{digit-sequence}}
  \synprd{\nt{digit-sequence} \tm{.}}
\synsym{exponent-part}
  \synprd{\tm{e} \nt{sign$_{opt}$ digit-sequence}}
  \synprd{\tm{E} \nt{sign$_{opt}$ digit-sequence}}
\synsym[one of]{sign}
  \synprd{\tm{+ -}}
\synsym{digit-sequence}
  \synprd{\nt{digit}}
  \synprd{\nt{digit-sequence digit}}
\synsym{hexadecimal-fractional-constant}
  \synprd{\nt{hexadecimal-digit-sequence$_{opt}$} \tm{.}
          \nt{hexadecimal-digit-sequence}}
  \synprd{\nt{hexadecimal-digit-sequence$_{opt}$} \tm{.}}
\synsym{binary-exponent-part}
  \synprd{\tm{p} \nt{sign$_{opt}$ digit-sequence}}
  \synprd{\tm{P} \nt{sign$_{opt}$ digit-sequence}}
\synsym{hexadecimal-digit-sequence}
  \synprd{\nt{hexadecimal-digit}}
  \synprd{\nt{hexadecimal-digit-sequence hexadecimal-digit}}
\synsym[one of]{floating-suffix}
  \synprd{\tm{f l F L}}

\desc
\paragraph{}
浮点常量有一个\textit{有效位部分}，后面可能跟一个\textit{指数部分}和一个指定其类
型的后缀。有效位部分的组成可以包括表示整数部分的数字序列，后跟句点（\tm{.}），后
跟表示小数部分的数字序列。指数部分的组成由一个\tm{e}、\tm{E}、\tm{p}或\tm{P}后跟
一个由可选有符号数字序列组成的指数。整数部分或小数部分必须存在；对于十进制浮点常
量，句点部分或指数部分必须存在。

\semantic
\paragraph{}
有效位部分被解释为（十进制或十六进制）有理数；指数部分中的数字序列被解释为十进制
整数。对于十进制浮点常量，指数表示有效位部分的10次幂。对于十六进制浮点常量，指数
表示有效位部分的2的幂。对于十进制浮点常量，以及十六进制浮点常量（当
\textit{FLT\_RADIX}不是2的幂时），结果要么是最近的可表示值，要么是以实现定义的方
式选择紧邻最近的可表示值的较大或较小的可表示值。对于十六进制浮点常量，当
\textit{FLT\_RADIX}为2的幂时，结果正确四舍五入。

\paragraph{}
无后缀浮点常量具有类型\tm{double}。如有后缀\tm{f}或\tm{F}，则有类型\tm{float}。
如有后缀\tm{l}或\tm{L}，则具有类型\tm{long double}。

\paragraph{}
浮点常量在翻译时转换为内部格式。浮点常量的转换在执行时不应引发异常情况或浮点异常
。同一源形式\footnote{\tm{1.23, 1.230, 123e-2, 123e-02}和\tm{1.23L}都是不同源形
式，因此不需要转换成相同内部格式和值。}的所有浮动常量应转换为具有相同值的相同内
部格式。

\recprac
\paragraph{}
如果十六进制常量不能以其求值格式准确表示，则实现应生成诊断消息；然后应继续转换程
序。

\paragraph{}
给定适用于两种转换，相同的结果格式和默认的执行时舍入的匹配输入，浮点常量的转换时
间应与库函数（如\tm{strtod}）对字符串的执行时转换相匹配。\footnote{库函数的规范
建议比浮点常量更精确的转换（见7.22.1.3）。}

\sssect{枚举常量}{lang.lex.const.enum}
\syntax
\paragraph{}
\synsym{enumeration-constant}
  \synprd[]{\nt{identifier}}

\semantic
\paragraph{}
声明为枚举常量的标识符具有类型\tm{int};

\fwdref{6.7.2.2}

\sssect{字符常量}{lang.lex.const.char}
\syntax
\paragraph{}
\synsym{character-constant}
\synprd{\tm{\sq} \nt{c-char-sequence} \tm{\sq}}
\synprd{\tm{L\sq} \nt{c-char-sequence} \tm{\sq}}
\synprd{\tm{u\sq} \nt{c-char-sequence} \tm{\sq}}
\synprd{\tm{U\sq} \nt{c-char-sequence} \tm{\sq}}
\synsym{c-char-sequence}
  \synprd{\nt{c-char}}
  \synprd{\nt{c-char-sequence c-char}}
\synsym{c-char}
  \synprd{源字符集中除单引号\tm{\sq}，反斜杠\tm{\bs}或新行字符外的任何成员}
  \synprd{\nt{escape-sequence}}
\synsym{escape-sequence}
  \synprd{\nt{simple-escape-sequence}}
  \synprd{\nt{octal-escape-sequence}}
  \synprd{\nt{hexadecimal-escape-sequence}}
  \synprd{\nt{universal-character-name}}
\synsym[one of]{simple-escape-sequence}
  \synprd{\tm{\bs\sq\ \bs\dq\ \bs{}?\ \bs\bs}}
  \synprd{\tm{\bs{}a \bs{}b \bs{}f \bs{}n \bs{}r \bs{}t \bs{}v}}
\synsym{octal-escape-sequence}
  \synprd{\tm{\bs} \nt{octal-digit}}
  \synprd{\tm{\bs} \nt{octal-digit octal-digit}}
  \synprd{\tm{\bs} \nt{octal-digit octal-digit octal-digit}}
\synsym{hexadecimal-escape-sequence}
  \synprd{\tm{\bs{}x} \nt{hexadecimal-digit}}
  \synprd[]{\nt{hexadecimal-escape-sequence hexadecimal-digit}}

\desc
\paragraph{}
整型字符常量是一个或多个多字节字符的序列，用单引号括起来，如\tm{\sq{}x\sq}。宽字
符常量是相同的，除前缀字母\tm{L}、\tm{u}或\tm{U}之外。除后面详细介绍的一些例外，
序列的元素是源字符集的任何成员；它们以实现定义的方式映射到执行字符集的成员。

\paragraph{}
根据以下转义表，单引号\tm{\sq}，双引号\tm{\dq}，问号\tm{?}，反斜杠\tm{\bs}和任意
整数值都可以表示：
\begin{table}[h!]
  \centering
  \begin{tabular}{ll}
    单引号\tm{\sq} & \tm{\bs\sq}                                              \\
    双引号\tm{\dq} & \tm{\bs\dq}                                              \\
    问号\tm{?}     & \tm{\bs ?}                                               \\
    反斜杠\tm{\bs} & \tm{\bs\bs}                                              \\
    八进制字符     & \tm{\bs}\textit{八进制数字}                              \\
    十六进制字符   & \tm{\bs{}x}\textit{十六进制数字}
  \end{tabular}
\end{table}

\paragraph{}
双引号\tm{\dq}和问号\tm{?}或可用其自身或可用转义序列\tm{\bs\dq}和\tm{\bs ?}对应
的表示，但单引号\tm{\sq}和反斜杠\tm{\bs}应使用转义序列\tm{\bs\sq}和\tm{\bs\bs}对
应的表示。

\paragraph{}
在八进制转义序列中，跟在反斜杠后面的八进制数字被视为整数字符常量的单个字符或宽字
符常量的单个宽字符构造的一部分。这样形成的八进制整数的数值指定所需字符或宽字符的
值。

\paragraph{}
十六进制转义序列中反斜杠后面的十六进制数字和字母\tm{x}被视为整数字符常量的单个字
符或宽字符常量的单个宽字符构造的一部分。这样形成的十六进制整数的数值指定所需字符
或宽字符的值。

\paragraph{}
每个八进制或十六进制转义序列是构成转义序列的最长字符序列。

\paragraph{}
此外，不在基本字符集中的字符可以用通用字符名表示，某些非图形字符可以用转义序列表
示，转义序列由反斜杠\tm{\bs}后跟小写字母\tm{\bs a}、\tm{\bs b}、\tm{\bs f}、
\tm{\bs n}、\tm{\bs r}、\tm{\bs t}和\tm{\bs v}组成。\footnote{这些字符的语义在
\ref{env.env.display}中进行了讨论。如果反斜杠后面有任何其他字符，则结果不是标记，
需要进行诊断。见``未来语言方向''（\ref{lang.dir.escape}）。}

\constraint
\paragraph{}
八进制或十六进制转义序列的值应在相应类型的可表示值范围内：
\begin{table}[h!]
  \centering
  \begin{tabular}{l|l}
    前缀   & 对应类型                                                         \\
    \hline
    无     & \tm{unsigned char}                                               \\
    \tm{L} & 对应\tm{wchar\_t}的无符号类型                                    \\
    \tm{u} & \tm{char16\_t}                                                   \\
    \tm{U} & \tm{char32\_t}
  \end{tabular}
\end{table}

\semantic
\paragraph{}
整数字符常量具有\tm{int}类型。包含映射到单字节执行字符的单个字符的整数字符常量的
值是被解释为整数的映射字符表示的数值。包含多个字符（例如\tm{\sq ab\sq}）或包含不
映射到单字节执行字符的字符或转义序列的整型字符常量的值由实现定义。如果整型字符常
量包含单个字符或转义序列，则其值是将值为单个字符或转义序列的\tm{char}类型的对象
转换为\tm{int}类型时的结果。

\paragraph{}
以字母\tm{L}为前缀的宽字符常量具有\tm{wchar\_t}类型，这是在\tm{<stddef.h>}头中定
义的整型；以字母\tm{u}或\tm{U}为前缀的宽字符常量具有\tm{char16\_t}或
\tm{char32\_t}类型，分别是在\tm{<uchar.h>}头中定义的无符号整型。包含映射到扩展执
行字符集的单个成员的单个多字节字符的宽字符常量的值是与该多字节字符对应的宽字符，
由\tm{mbtowc}、\tm{mbrtoc16}或\tm{mbrtoc32}函数根据其类型定义，由实现定义了当前
的区域设置。实现定义了包含多个多字节字符的宽字符常量的值，或映射到扩展执行字符集
的多个成员的单个多字节字符的值，或包含扩展执行字符集中未表示的多字节字符或转义序
列的值。

\paragraph{}
\ex 结构\tm{\sq\bs 0\sq}通常用于表示零字符。

\paragraph{}
\ex 考虑整数使用二补码，\tm{char}类型对象为八位表示的实现。在类型\tm{char}的值范
围与\tm{signed char}相同的实现中，整型字符常量\tm{\sq\bs xFF\sq}的值为$-1$；如果
类型\tm{char}的值范围与\tm{unsigned char}相同，则字符常量\tm{\sq\bs xFF\sq}的值
为$+255$。

\paragraph{}
\ex 即使8位用于\tm{char}类型的对象，构造\tm{\sq\bs x123\sq}也指定只包含一个字符
的整型字符常量，因为十六进制转义序列仅由非十六进制字符终止。要指定一个包含值为
\tm{\sq\bs x12\sq}和\tm{\sq3\sq}的两字符的整型字符常量，可以使用构造\tm{\sq\b
0223\sq}，因为八进制转义序列在三个八进制数字后终止。（此双字符整型字符常量的值由
实现定义。）

\paragraph{}
\ex 即使12位或更多位用于具有\tm{wchar\_t}类型的对象，构造\tm{L\sq\bs 1234\sq}指
定由值\tm{0123}和\tm{\sq 4\sq}组合产生的实现定义值。

\fwdref{7.19，7.22.7.2，7.28}

\ssect{字符串字面值}{lang.lex.str}
\syntax
\paragraph{}
\synsym{string-literal}
  \synprd{\nt{encoding-prefix$_{opt}$}\tm{\dq}
          \nt{s-char-sequence$_{opt}$}\tm{\dq}}
\synsym{encoding-prefix}
  \synprd{\tm{u8}}
  \synprd{\tm{u}}
  \synprd{\tm{U}}
  \synprd{\tm{L}}
\synsym{s-char-sequence}
  \synprd{\nt{s-char}}
  \synprd{\nt{s-char-sequence s-char}}
\synsym{s-char}
  \synprd{源字符集中除双引号\tm{\dq}，反斜杠\tm{\bs}或新行字符外的任何成员}
  \synprd[]{\nt{escape-sequence}}

\constraint
\paragraph{}
相邻字符串文本标记的序列不应同时包含宽字符串文字和UTF-8字符串文本。

\desc
\paragraph{}
\textit{字符串文本}是用双引号括起来的零个或多个多字节字符的序列，如
\tm{\dq xyz\dq}。除前缀为\tm{u8}，\textit{UTF-8字符串文本}是相同的。
除前缀字母\tm{L}、\tm{u}或\tm{U}，\textit{宽字符串文本}是相同的。

\paragraph{}
同样的考虑也适用于字符串文本中序列的每个元素，就好像它是一个整型字符常量（对于字
符或UTF-8字符串文本）或一个宽字符常量（对于宽字符串文本），除了单引号\tm{\sq}可
以由其自身或转义序列\tm{\bs\sq}来表示，而双引号\tm{\dq}除外，应以转义序列
\tm{\bs\dq}表示。

\semantic
\paragraph{}
在翻译阶段\ref{tpit6}中，由任何相邻字符序列和相同前缀的字符串文本标记指定的多字
节字符序列被连接成单个多字节字符序列。如果任何标记具有编码前缀，则生成的多字节字
符序列将被视为具有相同的前缀；否则，将被视为（character）字符串文本。是否可以连
接不同前缀的宽字符串文本标记以及如果可以，对生成的多字节字符序列进行的处理由实现
定义。

\paragraph{}
在翻译阶段\ref{tpit7}中，值为零的字节或代码被附加到每个多字节字符序列中，这些字
符序列是由字符串文本或文本产生的。\footnote{字符串文本不必是字符串（见
\ref{lib.intro.term}），因为可以通过转义序列\tm{\bs 0}将空字符嵌入其中。}  然后
使用多字节字符序列初始化静态存储期和长度刚好足以包含序列的数组。对于字符串文本，
数组元素具有\tm{char}类型，并用多字节字符序列的单个字节初始化。对于UTF-8字符串文
本，数组元素具有\tm{char}类型，并用以UTF-8编码的多字节字符序列的字符初始化。对于
以字母\tm{L}为前缀的宽字符串文本，数组元素的类型为\tm{wchar\_t}，并使用与多字节
字符序列相对应的宽字符序列进行初始化，如\tm{mbstowcs}函数使用实现定义的当前区域
设置所定义的那样。对于以字母\tm{u}或\tm{U}为前缀的宽字符串文本，数组元素分别具有
\tm{char16\_t}或\tm{char32\_t}类型，并使用与多字节字符序列相对应的宽字符序列进行
初始化，该序列由对\tm{mbroc16}或\tm{mbroc32}函数（视其类型而定）的连续调用定义，
并带有一个实现定义当前区域设置。包含未在执行字符集中表示的多字节字符或转义序列的
字符串文本的值由实现定义。

\paragraph{}
这些数组的元素具有适当值的情况下，不确定它们是否是不同。如果程序试图修改这样的数
组，则行为未定义。

\paragraph{}
\ex 相邻字符串文本对
\begin{lstlisting}
    "\x12" "3"
\end{lstlisting}
生成一个包含两个字符的单字符串文本，值分别为\tm{\sq\bs x12\sq}和\tm{\sq 3\sq}，
因为转义序列在相邻字符串文本串联之前被转换为执行字符集的单个成员。

\paragraph{}
\ex 相邻字符串文字标记的每个序列
\begin{lstlisting}
    "a" "b" L"c"
    "a" L"b" "c"
    L"a" "b" L"c"
    L"a" L"b" L"c"
\end{lstlisting}
都等价于字符串文本
\begin{lstlisting}
    L"abc"
\end{lstlisting}
同样，每个序列
\begin{lstlisting}
    "a" "b" u"c"
    "a" u"b" "c"
    u"a" "b" u"c"
    u"a" u"b" u"c"
\end{lstlisting}
都等价于
\begin{lstlisting}
    u"abc"
\end{lstlisting}

\fwdref{7.19，7.22.8.1，7.28}

\ssect{标点}{lang.lex.punct}
\syntax
\paragraph{}
\synsym[one of]{punctuator}
  \synprd{\tm{[ ] ( ) \{ \} .\ ->}}
  \synprd{\tm{++ -\dsh\ \& * + - \~\ !}}
  \synprd{\tm{/ \% \tl{}\tl\ \tg{}\tg\ < > <= >= == != \^\ | \&\& ||}}
  \synprd{\tm{?\ :\ ; ...}}
  \synprd{\tm{= *= /= \%= += -= \tl{}\tl{}= \tg{}\tg{}= \&= \^{}= |=}}
  \synprd{\tm{, \# \#\#}}
  \synprd[]{\tm{<:\ :> <\% \%> \%:\ \%:\%:}}

\semantic
\paragraph{}
标点符号是一种具有独立的语法和语义的符号。根据上下文的不同，它可以指定要执行的操
作（相应地可能生成值或函数指示符，产生副作用或其组合），这种情况下被称为
\textit{运算符}（在某些上下文中也存在其他形式的运算符）。\textit{操作数}是运算符
作用于其上的实体。

\paragraph{}
在语言的所有方面，六个标记\footnote{这些标记有时称作``双字母序列''。}         \\
\synprd[]{\tm{<:\ :> <\% \%> \%:\ \%:\%:}}                                    \\
与六个标记                                                                    \\
\synprd[]{\tm{[ ] \{ \} \# \#\#}}                                             \\
除拼写不同外，对应的行为一致。\footnote{因此\tm{[}和\tm{<:}在``字符化''（见
\ref{lang.ppdir.macro.stringize}）时行为不同，但除此外可以自由互换。}

\fwdref{6.5，6.7，6.10，6.8}

\ssect{头名称}{lang.lex.header}
\syntax
\paragraph{}
\synsym{header-name}
  \synprd{\tm{<} \nt{h-char-sequence} \tm{>}}
  \synprd{\tm{\dq} \nt{q-char-sequence} \tm{\dq}}
\synsym{h-char-sequence}
  \synprd{\nt{h-char}}
  \synprd{\nt{h-char-sequence h-char}}
\synsym{h-char}
  \synprd{源字符集中除新行字符和\tm{>}以外的任何成员}
\synsym{q-char-sequence}
  \synprd{\nt{q-char}}
  \synprd{\nt{q-char-sequence q-char}}
\synsym{q-char}
  \synprd[]{源字符集中除新行字符和\tm{\dq}以外的任何成员}

\semantic
\paragraph{}
两种形式的头名称序列都以实现定义的方式映射到\ref{lang.ppdir.inc}中指定的头名称或
外部源文件名。

\paragraph{}
如果字符\tm{\sq}，\tm{\bs}，\tm{\dq}，\tm{\bs\bs}或\tm{/*}出现在分隔符\tm{<}和
\tm{>}之间的序列中则行为未定义。相应的，如果字符\tm{\sq}，\tm{\bs}，\tm{\bs\bs}
或\tm{/*}出现在\tm{\dq}分隔符之间的序列中则行为未定义。\footnote{因此，类似转义
序列的字符序列会导致未定义的行为。} 头名称预处理标记只能在\tm{\#include}预处理指
令和\tm{\#pragma}指令内的实现定义的位置中识别。\footnote{有关在\tm{\#pragma}指令
中使用头名称预处理标记的示例见\ref{lang.ppdir.pragmaop}。}

\paragraph{}
\ex* 以下字符序列
\begin{lstlisting}
    0x3<1/a.h>1e2
    #include <1/a.h>
    #define const.member@$
\end{lstlisting}
构成以下的预处理标记（每个预处理标记使用\tm{\{}和\tm{\}}分隔。
\begin{lstlisting}
    {0x3}{<}{1}{/}{a}{.}{h}{>}{1e2}
    {#}{include} {<1/a.h>}
    {#}{define} {const}{.}{member}{@}{$}
\end{lstlisting}

\fwdref{6.10.2}

\ssect{预处理数字}{lang.lex.ppnum}
\syntax
\paragraph{}
\synsym{pp-number}
  \synprd{\nt{digit}}
  \synprd{\tm{.} \nt{digit}}
  \synprd{\nt{pp-number digit}}
  \synprd{\nt{pp-number identifier-nondigit}}
  \synprd{\nt{pp-number} \tm{e} \nt{sign}}
  \synprd{\nt{pp-number} \tm{E} \nt{sign}}
  \synprd{\nt{pp-number} \tm{p} \nt{sign}}
  \synprd{\nt{pp-number} \tm{P} \nt{sign}}
  \synprd[]{\nt{pp-number} \tm{.}}

\desc
\paragraph{}
一个预处理数字以一个数字开头，前面有可选的小数点（\tm{.}），后面可能跟有有效的标
识符字符和字符序列\tm{e+}、\tm{e-}、\tm{E+}、\tm{E-}、\tm{p+}、\tm{p-}、\tm{P+}
、或\tm{P-}。

\paragraph{}
预处理数字标记词法上包括所有浮点和整数常量标记。

\semantic
\paragraph{}
预处理数字没有类型或值；在成功转换（作为翻译阶段\ref{tpit7}的一部分）为浮点常量
标记或整数常量标记后获取这两个值。

\ssect{注释}{lang.lex.comment}
\paragraph{}
除了在字符常量、字符串文本或注释里之外，字符\tm{/*}引入注释。检查此类注释的内容
只是为了识别多字节字符并查找终止注释的字符\tm{*/}。\footnote{因此注释
\tm{/* ... */}不能嵌套。}

\paragraph{}
除了在字符常量、字符串文本或注释里之外，字符\tm{//}引入一个注释，该注释包含直到
下一个新行字符（但不包括）的所有多字节字符。这种注释的内容仅用于识别多字节字符和
查找终止新行字符。

\paragraph{}
\ex*
\begin{lstlisting}
    "a//b"                    // four-character string literal
    #include "//e"            // undefined behavior
    // */                     // comment, not syntax error
    f = g/**//h;              // equivalent to f = g / h;
    //\
    i();                      // part of a two-line comment
    /\
    / j();                    // part of a two-line comment
    #define glue(x,y) x##y
    glue(/,/) k();            // syntax error, not comment
    /*//*/ l();               // equivalent to l();
    m = n//**/o
      + p;                    // equivalent to m = n + p;
\end{lstlisting}

\sect{表达式}{lang.expr}
\paragraph{}
\textit{表达式}指一系列运算符和操作数，用于指定值的计算，或指定对象或函数，或生
成副作用，或执行其组合。对运算符的操作数的值计算前序于运算符结果进行值计算。

\paragraph{}
如果一个标量对象的副作用相对于同一个标量对象的另一个副作用或使用同一个标量对象的
值进行的值计算无序，则行为未定义。如果一个表达式的子表达式有多个允许的顺序，那么
如果在任何顺序中出现这样一个无序的副作用，那么该行为未定义。\footnote{该段落说明
未定义语句表达式如                                                            \\
\mbox{\hspace{4em}\tm{i = ++i + 1;}}                                          \\
\mbox{\hspace{4em}\tm{a[i++] = i;}}                                           \\
而允许                                                                        \\
\mbox{\hspace{4em}\tm{i = i + 1;}}                                            \\
\mbox{\hspace{4em}\tm{a[i] = i;}}}

\paragraph{}
运算符和操作数的分组由语法指示。\footnote{该语法指定表达式计算中运算符的优先级，
该优先级与该章节的主要子章节顺序相同，首先是最高优先级。因此，例如，允许作为二元
\tm{+}运算符（\ref{lang.expr.add}）的操作数的表达式是\ref{lang.expr.prim}到
\ref{lang.expr.add}中定义的表达式。例外情况是将表达式（\ref{lang.expr.cast}）转
换为一元运算符（\ref{lang.expr.unary}）的操作数，以及包含在以下任意一对运算符之
间的操作数：分组括号\tm{()}（\ref{lang.expr.prim}）、下标括号\tm{[]}
（\ref{lang.expr.post.sub}）、函数调用括号\tm{()}（\ref{lang.expr.post.call}）和
条件运算符\tm{?:}（\ref{lang.expr.cond}）。\vspace{0.2cm}

\ \ 在每个主要子章节中，运算符具有相同的优先级。在每个子章节中，通过其中讨论的表
达式的语法来表示左关联性或右关联性。} 除非后面另有规定，否则子表达式的副作用和值
计算是无序的。\footnote{在程序执行期间多次计算的表达式中，不必在不同的计算中一致
地执行其子表达式的无序和不确定性有序的计算。}

\paragraph{}
某些运算符（一元运算符\tm{\~}和二元运算符\tm{\tl{}\tl}，\tm{\tg{}\tg}，\tm{\&}，
\tm{\^}和\tm{|}统称为\textit{位运算符}）需要具有整型操作数。这些运算符产生的值依
赖于整数的内部表示，并实现定义和未定义的有符号类型。

\paragraph{}
如果在表达式的计算过程中出现\textit{异常情况}（即，如果结果没有数学定义或不在其
类型的可表示值范围内），则行为未定义。

\paragraph{}
用于访问存储值的对象\textit{有效类型}是声明的对象类型（如果有）。\footnote{分配
对象无类型。} 如果通过具有非字符类型的左值将值存储到没有声明类型的对象中，则左值
的类型将成为该访问和不修改存储值的后续访问的对象的有效类型。如果使用\tm{memcpy}
或\tm{memmove}将某个值复制到没有声明类型的对象中，或将该值复制为字符类型的数组，
则对于该访问和不修改该值的后续访问，被修改对象的有效类型是从中复制该值的对象的有
效类型（如果它有）。对于没有声明类型的对象的所有其他访问，对象的有效类型只是用于
访问的左值的类型。

\paragraph{}
对象的存储值只能由具有以下类型之一的左值表达式访问：\footnote{此列表的目的是指定
对象可能有别名，也可能没有别名的情况。}
\begin{itemize}
  \item{对象有效类型的兼容类型，}
  \item{对象有效类型的兼容类型的限定版本，}
  \item{对象有效类型对应的有符号或无符号类型，}
  \item{对象有效类型限定版本对应的有符号或无符号类型，}
  \item{聚合或联合类型，在其成员中包含上述类型之一（递归地包括子聚合或包含的联合
    的成员）。}
  \item{字符类型。}
\end{itemize}

\paragraph{}
浮动表达式可以\textit{压缩}，也就是说，像单个操作一样对其进行计算，从而省略源代
码和表达式计算方法所隐含的舍入错误。\footnote{压缩表达式中的中间操作的计算范围和
精度都是无限的，而最终操作的计算格式则由表达式计算方法确定。压缩表达式还可以省略
引发浮点异常。} \tm{<math.h>}中的\tm{FP\_CONTRACT} pragma提供了一种禁止压缩表达
式的方法。否则，表达式是否压缩以及如何压缩由实现定义。\footnote{此许可专门用于允
许实现利用结合多个C运算符的快速机器指令。由于压缩可能会破坏可预测性，甚至会降低
包含表达式的准确性，因此需要对其使用进行明确定义并清楚地记录。}

\fwdref{7.12.2，7.24.2}

\ssect{主表达式}{lang.expr.prim}
\syntax
\paragraph{}
\synsym{primary-expression}
  \synprd{\nt{identifier}}
  \synprd{\nt{constant}}
  \synprd{\nt{string-literal}}
  \synprd{\tm{(} \nt{expression} \tm{)}}
  \synprd[]{\nt{generic-selection}}

\semantic
\paragraph{}
标识符是主表达式，前提是它已声明为指定对象（在这种情况下它是左值）或函数（在这种
情况下它是函数指示符）。\footnote{因此，未声明的标识符违反语法。}

\paragraph{}
常量是主表达式。其类型取决于其形式和值，如\ref{lang.lex.const}所述。

\paragraph{}
字符串文字是主表达式。它是一个左值，类型如\ref{lang.lex.str}所述。

\paragraph{}
带圆括号的表达式是主表达式。它的类型和值与未加括号表达式的类型和值相同。如果未加
括号的表达式分别是左值、函数指示符或\tm{void}表达式，则它是左值、函数指示符或
\tm{void}表达式。

\paragraph{}
泛型选择是主表达式。它的类型和值取决于所选的泛型关联，后文详述。

\fwdref{6.7}

\sssect{泛型选择}{lang.expr.prim.generic}
\syntax
\paragraph{}
\synsym{generic-selection}
  \synprd{\tm{\_Generic (} \nt{assignment-expression} \tm{,}
    \nt{generic-assoc-list} \tm{)}}
\synsym{generic-assoc-list}
  \synprd{\nt{generic-association}}
  \synprd{\nt{generic-assoc-list} \tm{,} \nt{generic-association}}
\synsym{generic-association}
  \synprd{\nt{generic-association} \tm{:} \nt{association-expression}}
  \synprd[]{\tm{default} \tm{:} \nt{assignment-expression}}

\constraint
\paragraph{}
一个泛型选择应具有不超过一个\tm{default}泛型关联。泛型关联中的类型名应指定一个完
整的对象类型，而不是可变修改类型。同一个泛型选择中两个泛型关联不得指定兼容类型。
泛型选择的控制表达式的类型应至少与其泛型关联列表中指定的一种类型兼容。如果泛型选
择没有\tm{default}泛型关联，则其控制表达式的类型应仅与泛型关联列表中指定的类型之
一兼容。

\semantic
\paragraph{}
不计算泛型选择的控制表达式。如果泛型选择具有与控制表达式的类型兼容的类型名的泛型
关联，则泛型选择的结果表达式就是该泛型关联中的表达式。否则，泛型选择的结果表达式
是\tm{default}泛型关联中的表达式。不计算来自泛型选择的任何其他泛型关联的表达式。

\paragraph{}
泛型选择的类型和值与其结果表达式的类型和值相同。如果结果表达式分别是左值、函数指
示符或\tm{void}表达式，则它是左值、函数指示符或\tm{void}表达式。

\paragraph{}
\ex* \tm{cbrt}泛类型宏可能按如下实现：
\begin{lstlisting}
    #define cbrt(X) _Generic((X)),                \
                            long double: cbrtl, \
                            default: cbrt,        \
                            float: cbrtf          \
                            )(X)
\end{lstlisting}

\ssect{后缀运算符}{lang.expr.post}
\syntax
\paragraph{}
\synsym{postfix-expression}
  \synprd{\nt{primary-expression}}
  \synprd{\nt{postfix-expression} \tm{[} \nt{expression} \tm{]}}
  \synprd{\nt{postfix-expression} \tm{(} \nt{argument-expression-list$_{opt}$}
    \tm{)}}
  \synprd{\nt{postfix-expression} \tm{.} \nt{identifier}}
  \synprd{\nt{postfix-expression} \tm{->} \nt{identifier}}
  \synprd{\nt{postfix-expression} \tm{++}}
  \synprd{\nt{postfix-expression} \tm{-\dsh}}
  \synprd{\tm{(} \nt{type-name} \tm{) \{} \nt{initializer-list} \tm{\}}}
  \synprd{\tm{(} \nt{type-name} \tm{) \{} \nt{initializer-list} \tm{, \}}}
\synsym{argument-expression-list}
  \synprd{\nt{argument-expression}}
  \synprd[]{\nt{argument-expression-list} \tm{,} \nt{argument-expression}}

\sssect{数组下标}{lang.expr.post.sub}
\constraint
\paragraph{}
其中一个表达式的类型应为``指向完整对象\nt{type}的指针''，另一个表达式的类型应为
整数，结果的类型应为``\nt{type}''。

\semantic
\paragraph{}
后缀表达式后跟方括号\tm{[]}中的表达式是数组对象元素的下标指定。下标运算符\tm{[]}
的定义是\tm{E1[E2]}与\tm{(*((E1)+(e2)))}相同。由于应用于二元\tm{+}运算符的转换规
则，如果\tm{E1}是数组对象（相当于数组对象的初始元素的指针），\tm{E2}是整数，
\tm{E1[E2]}指定\tm{E1}的第\tm{E2}个元素（从零开始计数）。

\paragraph{}
连续的下标运算符指定多维数组对象的元素。如果\tm{E}是大小为$i\times j\times\cdots
\times k$的$n$维数组（$n\ge 2$），那么将\tm{E}（用作左值以外的值）转换为指向大小
为$j\times\cdots\times k$的$(n-1)$维数组的指针。如果一元\tm{*}运算符显式或由于下
标隐式应用于此指针，则结果是引用的$(n-1)$维数组，如果将其用作除左值外，则该数组
本身会转换为指针。由此可知数组按行主顺序存储（最后一个下标变化最快）。

\paragraph{}
\ex 考虑由以下声明定义的数组对象
\begin{lstlisting}
    int x[3][5];
\end{lstlisting}
这里\tm{x}是一个$3\times 5$的\tm{int}数组；准确地说，\tm{x}是由三个元素对象组成
的数组，每个元素对象都是一个由五个\tm{int}组成的数组。在表达式\tm{x[i]}中，相当
于\tm{(*((x)+(i)))}，\tm{x}首先被转换为指向初始$5$个\tm{int}数组的指针。然后根据
\tm{x}的类型来调整\tm{i}，概念上需要将\tm{i}乘以指针指向的对象的大小，即一个由五
个\tm{int}对象组成的数组。将结果相加，并应用间接取值生成一个五个\tm{int}的数组。
当在表达式\tm{x[i][j]}中使用时，该数组转换为指向第一个\tm{int}的指针，因此
\tm{x[i][j]}生成一个\tm{int}。

\fwdref{6.5.6，6.5.3.2，6.7.6.2}

\sssect{函数调用}{lang.expr.post.call}
\constraint
\paragraph{}
表示被调用函数\footnote{通常情况下是转换作为函数指示符的标识符的结果。}的表达式
的类型应该是指向返回\tm{void}的函数的指针，或指向返回除数组类型以外的完整对象类
型的函数指针。

\paragraph{}
如果表示被调用函数的表达式具有包含原型的类型，则实参的数量应与形参的数量一致。每
个实参的类型应使其值可以赋给具有相应形参类型的非限定版本的对象。

\semantic
\paragraph{}
后缀表达式后跟括号\tm{()}，其中包含可能为空的逗号分隔的表达式列表，是一个函数调
用。后缀表达式表示被调用的函数。表达式列表指定函数的实参。

\paragraph{}
实参可以是任何完整对象类型的表达式。在准备对函数的调用时，将计算实参值，并将实参
的值赋给每个对应的形参。\footnote{函数可以更改其形参的值，但这些更改不会影响实参
的值。另一方面，可以将指针传递给对象，并且函数可以更改所指向对象的值。声明为具有
数组或函数类型的参数被调整为具有如\ref{lang.extn.fct}所述的指针类型。}

\paragraph{}
如果表示被调用函数的表达式具有指向返回对象类型的函数指针类型，则该函数调用表达式
与该对象类型具有相同的类型，并且具有\ref{lang.stmt.jmp.ret}中指定的值。否则，函
数调用的类型为\tm{void}。

\paragraph{}
如果表示被调用函数的表达式具有不包含原型的类型，则对每个参数执行整数提升，并且将
具有\tm{float}类型的实参提升为\tm{double}。这些被称为\textit{缺省参数提升}。如果
实数个数不等于形参个数，则行为未定义。如果函数是用包含原型的类型定义的，并且原型
以省略号\tm{(, \ldots)}结尾，或者提升后的实参类型与形参类型不兼容，则行为未定义。
如果函数是用不包含原型的类型定义的，并且提升后实参的类型与形参的类型不兼容，则行
为未定义，但以下情况除外：
\begin{itemize}
  \item{其中一个提升后类型为有符号整型，另一个提升后的类型为对应的无符号整型，且
    值均可用两个类型表示；}
  \item{两个类型均为指向字符类型或\tm{void}类型的限定或未限定版本的指针。}
\end{itemize}

\paragraph{}
如果表示被调用函数的表达式具有包含原型的类型，则实参将隐式转换为相应形参的类型，
如同通过赋值一样，将每个形参的类型作为其声明类型的非限定版本。函数原型声明符中的
省略号表示法导致参数类型转换在最后一个声明的参数之后停止。缺省参数提升对随后的参
数执行。

\paragraph{}
不会隐式执行其他转换；特别是，实参的数量和类型不会与不包含函数原型声明符的函数定
义中的形参进行比较。

\paragraph{}
如果函数定义的类型与表示被调用函数的表达式所指向的类型（表达式的类型）不兼容，则
行为未定义。

\paragraph{}
在函数指示符和实参的计算之后，但在实际调用之前有一个序列点。调用函数（包括其他函
数调用）中的每个计算，如在被调用函数体执行之前或之后没有以其他方式进行特殊排序，
则相对被调用函数的执行是不确定性有序的。\footnote{换句话说函数执行不会彼此
``交错''。}

\paragraph{}
允许通过任何其他函数链直接或间接进行递归函数调用。

\paragraph{}
\ex* 函数调用
\begin{lstlisting}
    (*pf[f1()]) (f2(), f3() + f4())
\end{lstlisting}
函数\tm{f1}，\tm{f2}，\tm{f3}和\tm{f4}可能以任何顺序调用。所有副作用必须在由
\tm{pf[f1()]}所指向的函数调用之前完成。

\fwdref{6.7.6.3，6.9.1，6.8.6.4，6.5.16.1}

\sssect{结构与联合成员}{lang.expr.post.mem}
\constraint
\paragraph{}
运算符\tm{.}的第一操作数应具有原子、限定或未限定的结构或联合类型，第二操作数应命
名该类型的成员。

\paragraph{}
运算符\tm{->}的第一操作数应具有``指向原子、限定或未限定结构的指针''或``指向原子
、限定或未限定联合的指针''类型，第二操作数应命名指向的类型的成员。

\semantic
\paragraph{}
后缀表达式后跟\tm{.}运算符和标识符指定结构或联合对象成员。其值是所命名成员的值，
\footnote{如果用于读取联合对象内容的成员与上次用于在对象中存储值的成员不同，则该
值的对象表示的适当部分将重新解释为\ref{lang.concept.repr}中所述的新类型中的对象
表示（有时称为``类型双关''）。这可能是一个陷阱表示。} 如果第一个表达式是左值，则
该值是左值。如果第一个表达式具有限定类型，则结果具有指定成员类型的限定版本。

\paragraph{}
后缀表达式后跟\tm{->}运算符和标识符指定结构或联合对象的成员。其值是第一个表达式
指向的对象的命名成员的值，并且是左值。\footnote{如果\tm{\&E}是有效的指针表达式
（其中\tm{\&}是``取地址''运算符，该运算符生成指向其操作数的指针），则表达式
\tm{(\&E)->MOS}与\tm{E.MOS}相同。} 如果第一个表达式是指向限定类型的指针，则结果
具有指定成员类型的限定版本。

\paragraph{}
访问原子结构或联合对象的成员会导致未定义行为。\footnote{例如，如果对一个线程中的
整个结构或联合的访问与对另一个线程中的成员的访问发生冲突，则会发生数据争用，其中
至少有一个访问是修改。可以使用分配给原子对象或从原子对象分配的非原子对象安全地访
问成员。}

\paragraph{}
为了简化联合的使用，有一个特殊保证：如果联合包含多个共享公共初始序列的结构（见下
文），并且如果联合对象当前包含这些结构中的一个，则允许访问任何联合完全类型的声明
可见的地方其中任何一个结构的公共初始部分。如果对应成员对一个或多个初始成员的序列
具有兼容类型（对于位字段，宽度相同），则两个结构共享一个\textit{公共的初始序列}。

\paragraph{}
\ex 如果\tm{f}是返回结构或联合的函数，而\tm{x}是该结构或联合的成员，则\tm{f{}.x}
是有效的后缀表达式，但不是左值。

\paragraph{}
\ex 以下代码中
\begin{lstlisting}
    struct s { int i; const int ci; };
    struct s s;
    const struct s cs;
    volatile struct s vs;
\end{lstlisting}
多个成员的类型为：
\begin{lstlisting}
    s.i     int
    s.ci    const int
    cs.i    const int
    cs.ci   const int
    vs.i    volatile int
    vs.ci   volatile const int
\end{lstlisting}

\paragraph{}
\ex 以下为合法片断：
\begin{lstlisting}
    union {
      struct {
        int alltypes;
      } n;
      struct {
        int type;
        int intnode;
      } ni;
      struct {
        int type;
        double doublenode;
      } nf;
    } u;
    u.nf.type = 1;
    u.nf.doublenode = 3.14;
    /* ... */
    if (u.n.alltypes == 1)
      if (sin(u.nf.doublenode) == 0.0)
        /* ... */
\end{lstlisting}
以下片断不合法（因为在函数\tm{f}内联合类型不可见）：
\begin{lstlisting}
    struct t1 { int m; };
    struct t2 { int m; };
    int f(struct t1 *p1, struct t2 *p2)
    {
      if (p1->m < 0)
      p2->m = -p2->m;
      return p1->m;
    }
    int g()
    {
      union {
        struct t1 s1;
        struct t2 s2;
      } u;
      /* ... */
      return f(&u.s1, &u.s2);
    }
\end{lstlisting}

\fwdref{6.5.3.2，6.7.2.1}

\sssect{后自增与自减}{lang.expr.post.incr}
\constraint
\paragraph{}
后缀递增或递减运算符的操作数应具有原子、限定或不限定的实数或指针类型，并且应为可
修改的左值。

\semantic
\paragraph{}
后缀\tm{++}运算符的结果是操作数的值。作为副作用，操作数对象的值递增（即，将适当
类型的值\tm{1}添加到该对象中）。有关约束、类型和转换以及操作对指针的影响的信息见
加法运算符和复合赋值的讨论。结果的值计算前序于更新操作数存储值的副作用。对于不确
定有序的函数调用，后缀\tm{++}的操作是单个计算。原子类型对象的后缀\tm{++}是一个读
-修改-写操作，具有\tm{memory\_order\_seq\_cst}语义。\footnote{如果可以形成指向原
子对象的指针，并且\tm{E}具为整型，则\tm{E++}相当于以下代码序列，其中\tm{T}是
\tm{E}的类型：                                                                \\
  \newcommand{\mbx}[2][4em]{\mbox{\hspace{#1}\tm{#2}}}
  \mbx{T *addr = \&E;}                                                        \\
  \mbx{T old = *addr;}                                                        \\
  \mbx{T new;}                                                                \\
  \mbx{do \{;}                                                                \\
  \mbx[6em]{new = old + 1;}                                                   \\
  \mbx{\} while (!atomic\_compare\_exchange\_strong(addr, \&old, new));}      \\
\tm{old}为操作结果。                                                          \\
如果\tm{E}为浮点类型则必须进行特别处理；见\ref{lang.expr.assign.cmpd}。}

\paragraph{}
后缀\tm{-\dsh}运算符类似于后缀\tm{++}运算符，只是操作数的值是递减的（即从
中减去相应类型的值$1$）。

\fwdref{6.5.6，6.5.12.2}

\sssect{复合字面值}{lang.expr.post.cmpd}
\constraint
\paragraph{}
类型名应指定完整的对象类型或未知大小的数组，但不能指定可变长度的数组类型。

\paragraph{}
\ref{lang.dcl.init}中初始化列表的所有约束也适用于复合字面值。

\semantic
\paragraph{}
由带圆括号的类型名后跟括号的初始值设定项列表组成的后缀表达式是\textit{复合字面
值}。它提供一个未命名的对象，其值由初始化列表给定。\footnote{注意这与强制转换表
达式不同。例如，强制转换仅指定到标量类型或\tm{void}的转换，并且强制转换表达式的
结果不是左值。}

\paragraph{}
如果类型名指定了一个大小未知的数组，则该大小由初始化列表确定，如
\ref{lang.dcl.init}中所指定，并且复合字面值的类型是完整数组类型的类型。否则（当
类型名指定对象类型时），复合字面值的类型是由类型名指定的类型。在这两种情况下，结
果都是左值。

\paragraph{}
复合字面值的值为初始化列表初始化的未命名对象的值。如复合字面值出现在函数体外部，
则对象具有静态存储期；否则，它具有与包含块关联的自动存储期。

\paragraph{}
\ref{lang.dcl.init}中初始化列表的所有语义规则也适用于复合字面值。\footnote{比如
无显式初始化的子对象初始化成零。}

\paragraph{}
字符串文本和具有常限定类型的复合字面值不需要指定不同的对象。\footnote{这允许实现
共享具有相同或重叠表示形式的字符串文本和常复合字面值的存储。}

\paragraph{}
\ex 文件作用域定义
\begin{lstlisting}
    int *p = (int []){2, 4};
\end{lstlisting}
初始化\tm{p}指向两个\tm{int}数组的第一个元素，第一个元素的值为$2$，第二个元素的
值为$4$。此复合字面值中的表达式必须是常量。未命名对象具有静态存储持续时间。

\paragraph{}
\ex 相比之下，以下片断中
\begin{lstlisting}
    void f(void)
    {
      int *p;
      /*...*/
      p = (int [2]){*p};
      /*...*/
    }
\end{lstlisting}
\tm{p}被赋以两个\tm{int}数组的第一个元素的地址，第一个元素的值以前被\tm{p}指向，
第二个元素的值为零。此复合字面值中的表达式不必是常量。未命名对象具有自动存储期。

\paragraph{}
\ex 指定初始化可以与复合字面值组合。使用复合字面值创建的结构对象可以传递给函数，
而不依赖于成员顺序：
\begin{lstlisting}
    drawline((struct point){.x=1, .y=1},
             (struct point){.x=3, .y=4});
\end{lstlisting}
或者如果\tm{drawline}期望的是\tm{struct point}的指针：
\begin{lstlisting}
    drawline(&(struct point){.x=1, .y=1},
             &(struct point){.x=3, .y=4});
\end{lstlisting}

\paragraph{}
\ex 只读复合字面值可通过以下结构指定：
\begin{lstlisting}
    (const float []){1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6}
\end{lstlisting}

\paragraph{}
\ex 以下三个表达式具有不同语义：
\begin{lstlisting}
    "/tmp/fileXXXXXX"
    (char []){"/tmp/fileXXXXXX"}
    (const char []){"/tmp/fileXXXXXX"}
\end{lstlisting}
第一个始终具有静态存储期，并且具有\tm{char}类型数组，但不需要可修改；最后两个在
函数体中时具有自动存储期，两个中的第一个可修改。

\paragraph{}
\ex 与字符串文本一样，常限定的复合字面值可以放置在只读内存中，甚至可以共享。如，
\begin{lstlisting}
    (const char []){"abc"} == "abc"
\end{lstlisting}
如果字面值共享存储则可能产生$1$。

\paragraph{}
\ex 由于复合字面值未命名，单个复合字面值不能指定循环链接的对象。例如，无法编写可
用作函数参数的自引用复合字面值，而不是下面的命名对象\tm{endless\_zeros}：
\begin{lstlisting}
    struct int_list { int car; struct int_list *cdr; };
    struct int_list endless_zeros = {0, &endless_zeros};
    eval(endless_zeros);
\end{lstlisting}

\paragraph{}
\ex 每一个复合字面值在给定作用域中仅创建一个对象：
\begin{lstlisting}
    struct s { int i; };
    int f (void)
    {
      struct s *p = 0, *q;
      int j = 0;
    again:
      q = p, p = &((struct s){ j++ });
      if (j < 2) goto again;
      return p == q && q->i == 1;
    }
\end{lstlisting}
函数\tm{f()}总是返回$1$。

\paragraph{}
\notes* 如果使用迭代语句而不是显式\tm{goto}和带标签的语句，则未命名对象的生存期
将仅为循环体，并且在下次进入时\tm{p}将有一个不确定的值，将导致未定义的行为。

\fwdref{6.7.7，6.7.9}

\ssect{一元运算符}{lang.expr.unary}
\syntax
\paragraph{}
\synsym{unary-expression}
  \synprd{\nt{postfix-expression}}
  \synprd{\tm{++} \nt{unary-expression}}
  \synprd{\tm{-\dsh{}} \nt{unary-expression}}
  \synprd{\nt{unary-operator cast-expression}}
  \synprd{\tm{sizeof} \nt{unary-expression}}
  \synprd{\tm{sizeof (} \nt{type-name} \tm{)}}
  \synprd{\tm{\_Alignof (} \nt{type-name} \tm{)}}
\synsym[one of]{unary-operator}
  \synprd[]{\tm{\&\ \ *\ \ +\ \ -\ \ \~\ \ !}}

\sssect{前缀自增与自减}{lang.expr.unary.incr}
\constraint
\paragraph{}
前缀自增或自减运算符的操作数应为原子、限定或不限定的实类型或指针类型，并且应为可
修改左值。

\semantic
\paragraph{}
前缀\tm{++}运算符的操作数的值递增。结果是递增后操作数的新值。表达式\tm{++E}等价于
\tm{(E+=1)}。有关约束、类型、副作用和转换以及操作对指针的影响的信息，请参阅加法
运算符和复合赋值的讨论。

\paragraph{}
前缀\tm{-\dsh}运算符类似于\tm{++}运算符，只是操作数的值是递减的。

\fwdref{6.5.6，6.5.16.2}

\sssect{地址与间接寻址}{lang.expr.unary.addr}
\constraint
\paragraph{}
一元运算符\tm{\&}的操作数应为函数、\tm{[]}或一元\tm{*}运算符的结果，或指代非位字
段且未用\tm{register}存储类说明符声明的对象的左值。

\paragraph{}
一元\tm{*}运算符的操作数应为指针类型。

\semantic
\paragraph{}
一元运算符\tm{\&}产生其操作数的地址。如果操作数的类型为``\nt{type}''，则结果的类
型为``指向\nt{type}的指针''。如果操作数是一元\tm{*}运算符的结果，则既不计算该运
算符，也不计算\tm{\&}运算符，并且结果就像两者都被省略一样，除对运算符的约束仍然
适用且结果不是左值。同样，如果操作数是\tm{[]}运算符的结果，则不计算\tm{[]}所隐含
的一元\tm{\&}或\tm{*}运算符，结果就像删除了\tm{\&}运算符而将\tm{[]}运算符更改为
\tm{+}运算符一样。否则，结果是指向由其操作数指定的对象或函数的指针。

\paragraph{}
一元\tm{*}运算符表示间接寻址。如果操作数指向函数，则结果为函数指示符；如果指向对
象，则结果为指定对象的左值。如果操作数的类型为``指向\nt{type}的指针''，则结果的
类型为``\nt{type}''。如果为指针分配了无效值，则一元\tm{*}运算符的行为未定义。
\footnote{因此，\tm{\&*E}等于\tm{E}（即使\tm{E}是零指针），\tm{\&(E1[E2])}等于
\tm{((E1)+(E2))}。如\tm{E}是作为一元\tm{\&}运算符有效操作数的函数指示符或左值，
\tm{*\&E}是一个等于\tm{E}的函数指示符或左值则总是正确的。如果\tm{*P}是左值，
\tm{T}是对象指针类型的名称，\tm{*(T)P}是一个左值，其类型与\tm{T}指向的类型兼容。

一元\tm{*}运算符解指针引用的无效值包括零指针、所指对象类型不适当对齐的地址，以及
对象生存期结束后的地址。}

\fwdref{6.7.1，6.7.2.1}

\sssect{一元算术运算符}{lang.expr.unary.arith}
\constraint
\paragraph{}
一元\tm{+}或\tm{-}运算符的操作数应具有算术类型；\tm{\~}运算符的操作数应为整型；
\tm{!}运算符操作数应为标量类型。

\semantic
\paragraph{}
一元\tm{+}运算符的结果是其（提升后）操作数的值。对操作数执行整型提升，结果具有提
升后的类型。

\paragraph{}
一元\tm{-}运算符的结果是其（提升后）操作数的负数。对操作数执行整型提升，结果具有
提升后的类型。

\paragraph{}
\tm{\~}运算符的结果是其（提升后）操作数的按位补（当且仅当转换操作数中的相应位未
设置的情况下才会设置对应位）。对操作数执行整型提升，结果具有提升后的类型。如果提
升后的类型是无符号类型，则表达式\tm{\~E}等于该类型中可表示的最大值减去\tm{E}.

\paragraph{}
如果逻辑取反运算符\tm{!}的操作数值不等于0，则结果为0；如果操作数值等于0，则结果
为1。结果的类型为\tm{int}。表达式\tm{!E}等于\tm{(0==E)}。

\sssect{sizeof和\_Alignof}{lang.expr.unary.sizeof}
\constraint
\paragraph{}
\tm{sizeof}运算符不应用于具有函数类型或不完整类型的表达式、此类类型的带圆括号的
名称或指代位域成员的表达式。\tm{\_Alignof}运算符不应用于函数类型或不完整类型。

\semantic
\paragraph{}
\tm{sizeof}运算符生成其操作数的大小（以字节为单位），该大小可以是表达式或类型的
带括号名称。大小由操作数的类型决定。结果是一个整数。如果操作数的类型是可变长度数
组类型，则计算该操作数；否则，不计算该操作数，结果为整数常量。

\paragraph{}
\tm{\_Alignof}运算符生成其操作数类型的对齐要求。不计算操作数，结果为整数常量。当
用于数组类型时，结果是元素类型的对齐要求。

\paragraph{}
当\tm{sizeof}应用于类型为\tm{char}、\tm{unsigned char}或\tm{signed char}（或其限
定版本）的操作数时，结果为1。当用于具有数组类型的操作数时，结果是数组中的字节总
数。\footnote{当用于声明为数组或函数类型的参数时，\tm{sizeof}运算符生成调整（指
针）类型的大小（见\ref{lang.extn.fct}）。} 当用于具有结构或联合类型的操作数时，
结果是此类对象中的字节总数，包括内部填充和尾部填充。

\paragraph{}
这两个运算符的结果值都是实现定义的，其类型（无符号整型）是\tm{size\_t}，在
\tm{<stddef.h>}（和其他头）中定义。

\paragraph{}
\ex \tm{sizeof}运算符的主要用途是与存储分配器和I/O系统等例程通信。存储分配函数可
以接受待分配对象的大小（以字节为单位），并返回指向\tm{void}的指针。例如：
\begin{lstlisting}
    extern void *alloc(size_t);
    double *dp = alloc(sizeof *dp);
\end{lstlisting}
\tm{alloc}函数的实现应确保其返回值适当对齐，以便转换为指向\tm{double}的指针。

\paragraph{}
\ex \tm{sizeof}运算符的另一个用途是计算数组中的元素个数：
\begin{lstlisting}
    sizeof array / sizeof array[0]
\end{lstlisting}

\paragraph{}
\ex 本例中，计算可变长度数组的大小并从函数返回：
\begin{lstlisting}
    #include <stddef.h>
    size_t fsize3(int n)
    {
      char b[n+3];
      return sizeof b;
    }
    // variable length array
    // execution time sizeof
    int main()
    {
      size_t size;
      size = fsize3(10); // fsize3 returns 13
      return 0;
    }
\end{lstlisting}

\fwdref{7.19，6.7，6.7.2.1，6.7.7，6.7.6.2}

\ssect{转换运算符}{lang.expr.cast}
\syntax
\paragraph{}
\synsym{cast-expression}
  \synprd{unary-expression}
  \synprd[]{\tm{(} \nt{type-name} \tm{)} \nt{cast-expression}}

\constraint
\paragraph{}
除非类型名指定了\tm{void}类型，否则类型名应指定原子、限定或非限定的标量类型，且
操作数应具有标量类型。

\paragraph{}
涉及指针的转换（\ref{lang.expr.assign.simple}的约束允许的除外）应通过显式强制转
换进行。

\paragraph{}
指针类型不应转换为任何浮点类型。浮点类型不应转换为任何指针类型。

\semantic
\paragraph{}
在表达式前面加上带括号的类型名，可以将表达式的值转换为命名类型。这种结构称做
\textit{强制转换}（\textit{cast}）。\footnote{强制转换不产生左值。因此，对限定类
型的强制转换与对该类型的非限定版本的强制转换具有相同的效果。} 不指定转换
（conversion）的强制转换对表达式的类型或值没有影响。

\paragraph{}
如果表达式的值表示的范围或精度大于由强制转换命名的类型
（\ref{lang.conv.arith.usualarith}）所要求的范围或精度，则强制转换将指定转换，
即使表达式的类型与命名的类型相同，并删除任何额外的范围和精度。

\fwdref{6.5.9，6.7.6.3，6.5.16.1，6.7.7}

\ssect{乘法运算符}{lang.expr.mul}
\syntax
\paragraph{}
\synsym{multiplicative-expression}
  \synprd{\nt{cast-expression}}
  \synprd{\nt{multiplicative-expression} \tm{*} \nt{cast-expression}}
  \synprd{\nt{multiplicative-expression} \tm{/} \nt{cast-expression}}
  \synprd[]{\nt{multiplicative-expression} \tm{\%} \nt{cast-expression}}

\constraint
\paragraph{}
每个操作数应具有算术类型。\tm{\%}运算符的操作数应为整数类型。

\semantic
\paragraph{}
常规算术转换作用于操作数。

\paragraph{}
二元\tm{*}运算符的结果是操作数的乘积。

\paragraph{}
运算符\tm{/}的结果是第一个操作数除以第二个操作数所得的商；运算符tm{\%}的结果是余
数。在这两个操作中，如果第二个操作数的值为零，则行为未定义。

\paragraph{}
当整数相除时，\tm{/}运算符的结果是代数商，去掉任何小数部分。\footnote{这通常被称
为``向零截断''。} 如果商\tm{a/b}是可表示的，则表达式\tm{(a/b)*b+a\%b}应等于
\tm{a}；否则，\tm{a/b}和\tm{a\%b}的行为均未定义。

\ssect{加法运算符}{lang.expr.add}
\syntax
\paragraph{}
\synsym{additive-expression}
  \synprd{\nt{multiplicative-expression}}
  \synprd{\nt{additive-expression} \tm{+} \nt{multiplicative-expression}}
  \synprd[]{\nt{additive-expression} \tm{-} \nt{multiplicative-expression}}

\constraint
\paragraph{}
对于加法，两个操作数都应具有算术类型，或者一个操作数应为指向完整对象类型的指针，
另一个操作数应为整型。（递增等价于加1。）

\paragraph{}
对于减法，以下之一应该成立：
\begin{itemize}
  \item{两个操作数均具有算术类型；}
  \item{两个操作数均为指向完整对象类型的限定或未限定版本；或}
  \item{左操作数为指向完整对象类型的指针，右操作数具有整型。}
\end{itemize}
（递减等价于减1。）

\semantic
\paragraph{}
如果两个操作数都有算术类型，则通常对它们执行常规算术转换。

\paragraph{}
二元\tm{+}运算符的结果为操作数的和。

\paragraph{}
二元\tm{-}运算符的结果是第一个操作数减去第二个操作数所得的差。

\paragraph{}
就这些运算符而言，指向不是数组元素的对象的指针的行为与指向长度为一的数组的第一个
元素的指针的行为相同，对象的类型作为其元素类型。

\paragraph{}
当一个整型表达式被加到指针或从指针中减去时，结果具有指针操作数的类型。如果指针操
作数指向数组对象的元素，并且数组足够大，则结果指向元素与起始元素的偏移量，使得结
果元素和起始数组元素的下标的差等于整数表达式。换句话说，如果表达式\tm{P}指向数组
对象的第$i$个元素，则表达式\tm{(P)+N}（等价地，\tm{N+(P)}）和\tm{(P)-N}（其中
\tm{N}的值为$n$）分别指向数组对象的第$i+n$个元素和第$i-n$个元素，前提是它们存在。
此外，如果表达式\tm{P}指向数组对象的最后一个元素，则表达式\tm{(P)+1}指向数组对象
的最后一个元素之后的第一个元素，如果表达式\tm{Q}指向数组对象的最后一个元素之后的
第一个元素，则表达式\tm{(Q)-1}指向数组对象的最后一个元素。如果指针操作数和结果都
指向同一数组对象的元素，或指向数组对象的最后一个元素之后的第一个元素，则计算结果
不应产生溢出；否则行为未定义。如果结果指向数组对象最后一个元素之后的第一个元素，
则不应将其用作被计算的一元\tm{*}运算符的操作数。

\paragraph{}
当两个指针相减时，两个指针都应指向同一数组对象的元素，或指向数组对象最后一个元素
之后的第一个元素；结果是两个数组元素下标的差。结果大小由实现定义，其类型（有符号
整型）是在\tm{<stddef.h>}头中定义的\tm{ptrdiff\_t}。如果结果在该类型的对象中不可
表示，则行为未定义。换句话说，如果表达式\tm{P}和\tm{Q}分别指向数组对象的第$i$和
第$j$个元素，则表达式\tm{(P)-(Q)}的值为${i-j}$，前提是该值可由\tm{ptrdiff\_t}类
型的对象表示。此外，如果表达式\tm{P}指向数组对象的元素或数组
对象最后一个元素之后的第一个元素，且表达式\tm{Q}指向同一数组对象的最后一个元素，
表达式\tm{((Q+1)-(P)}的值与\tm{((Q)-(P))+1}和\tm{-((P)-((Q+1))}的值相同，如果表
达式\tm{P}指向数组对象最后一个元素之后的第一个元素，则该表达式的值为零，即使表达
式\tm{(Q)+1}没有指向数组对象的元素。\footnote{另一种处理指针算术的方法是首先将指
针转换为字符指针：在此方案中，对转换后的指针进行加法或减法运算的整数表达式首先乘
以最初指向的对象的大小，然后将得到的指针转换回原始类型。对于指针减法，字符指针之
间的差异的结果同样除以最初指向的对象的大小。\\
当以这种方式看时，实现只需要在对象结束后提供一个额外的字节（可能与程序中的另一个
对象重叠），以满足``最后一个元素之后的第一个''要求。}

\paragraph{}
\ex 变长数组类型指针算术定义明确。
\begin{lstlisting}
    {
      int n = 4, m = 3;
      int a[n][m];
      int (*p)[m] = a;  // p == &a[0]
      p += 1;            // p == &a[1]
      (*p)[2] = 99;      // a[1][2] == 99
      n = p - a;         // n == 1
    }
\end{lstlisting}

\paragraph{}
如果上述示例中的数组\tm{a}声明为已知常大小的数组，而指针\tm{p}声明为指向相同已知
常大小的数组（指向\tm{a}）的指针，则结果将相同。

\fwdref{6.7.6.2，7.19}

\pagebreak
\ssect{位移运算符}{lang.expr.shift}
\syntax
\paragraph{}
\synsym{shift-expression}
  \synprd{\nt{additive-expression}}
  \synprd{\nt{shift-expression} \tm{\tl{}\tl} \nt{additive-expression}}
  \synprd[]{\nt{shift-expression} \tm{\tg{}\tg} \nt{additive-expression}}

\constraint
\paragraph{}
每一个操作数都应为整型。

\semantic
\paragraph{}
对每个操作数执行整型提升。结果的类型是提升后的左操作数的类型。如果右操作数的值为
负或大于等于提升后的左操作数的宽度，则行为未定义。

\paragraph{}
\tm{E1 \tl{}\tl{} E2}的结果是\tm{E1}左移\tm{E2}位；空出的位用零填充。如果\tm{E1}
为无符号类型，则结果的值为\tm{E1\ttim 2\tsup{E2}}，按结果类型中可表示的最大值加
一取模。如果\tm{E1}具有有符号类型和非负值，且\tm{E1\ttim 2\tsup{E2}}在结果类型中
是可表示的，那么这就是结果值；否则行为未定义。

\paragraph{}
\tm{E1\tg{}\tg E2}的结果是\tm{E1}右移\tm{E2}位。如果\tm{E1}为无符号类型，或者
\tm{E1}为有符号类型和非负值，则结果值是\tm{E1/2\tsup{E2}}商的整数部分。如果
\tm{E1}为有符号类型和负值，则结果值由实现定义。

\ssect{关系运算符}{lang.expr.rel}
\syntax
\paragraph{}
\synsym{relational-expression}
  \synprd{\nt{shift-expression}}
  \synprd{\nt{relational-expression} \tm{\tl} \nt{shift-expression}}
  \synprd{\nt{relational-expression} \tm{\tg} \nt{shift-expression}}
  \synprd{\nt{relational-expression} \tm{\tl=} \nt{shift-expression}}
  \synprd[]{\nt{relational-expression} \tm{\tg=} \nt{shift-expression}}

\constraint
\paragraph{}
以下之一应该成立：
\begin{itemize}
  \item{两个操作数均为实类型；或}
  \item{两个操作数均为指向兼容对象类型的限定或未限定版本的指针。}
\end{itemize}

\semantic
\paragraph{}
如果两操作数均为算术类型，则进行常规算术转换。

\paragraph{}
就这些运算符而言，指向不是数组元素对象的指针的行为与指向长度为一的数组的第一个
元素的指针的行为相同，对象的类型作为其元素类型。

\paragraph{}
当比较两个指针时，结果取决于所指向对象的地址空间中的相对位置。如果指向对象类型的
两个指针都指向同一对象，或者都指向同一数组对象的最后一个元素之后的第一个元素，则
它们相等。如果指向的对象是同一聚合对象的成员，则指向稍后声明的结构成员的指针比指
向结构中较早声明的成员的指针大，指向下标值较大的数组元素的指针比指向下标值较低的
同一数组元素的指针大。指向同一联合对象成员的所有指针相等。如果表达式\tm{P}指向数
组对象的元素，而表达式\tm{Q}指向同一数组对象的最后一个元素，则指针表达式\tm{Q+1}
比\tm{P}大。所有其他情况下行为未定义。

\paragraph{}
如果指定的关系为真，则运算符\tm{\tl}（小于）、\tm{\tg}（大于）、\tm{\tl=}（小于
等于）和\tm{\tg=}（大于等于）应生成1，如果为假，则生成0。\footnote{表达式
\tm{a<b<c}不按常规数学方式解释。如语法所示，它意味着\tm{(a<b)<c}；换句话说，
``如果\tm{a}小于\tm{b}，将\tm{1}与\tm{c}比较；否则，将\tm{0}与\tm{c}比较''。}
结果类型为\tm{int}。

\ssect{等性运算符}{lang.expr.eq}
\syntax
\paragraph{}
\synsym{equality-expression}
\synprd{\nt{relational-expression}}
  \synprd{\nt{equality-expression} \tm{==} \nt{relational-expression}}
  \synprd[]{\nt{equality-expression} \tm{!=} \nt{relational-expression}}

\constraint
\paragraph{}
以下之一应该成立：
\begin{itemize}
  \item{两个操作数均为算术类型；}
  \item{两个操作数均为指向兼容类型的限定或未限定版本的指针；}
  \item{其中一个操作数为指向对象类型的指针，另一个为指向\tm{void}类型限定或未限
    定版本的指针，或}
  \item{其中一个操作数是指针，另一个为零指针常量。}
\end{itemize}

\semantic
\paragraph{}
\tm{==}（等于）和\tm{!=}（不等于）运算符与关系运算符类似，但优先级较低。
\footnote{由于优先级，当\tm{a<b}和\tm{c<d}具有相同真值时，\tm{a<b == c<d}为1。}
如果指定的关系为真，则每个运算符生成1；如果指定的关系为假，则生成0。结果的类型为
\tm{int}。对于任何一对操作数，只有一个关系为真。

\paragraph{}
如果两个操作数都有算术类型，则执行常规算术转换。当且仅当实部和虚部相等时，复数类
型的值才相等。来自不同类型域的算术类型的任意两个值相等当且仅当它们转换为由常规算
术转换确定的（复数）结果类型的结果是相等的。

\paragraph{}
否则，至少有一个操作数是指针。如果一个操作数是指针，另一个操作数是零指针常量，则
零指针常量将转换为指针类型。如果一个操作数是指向对象类型的指针，而另一个操作数是
指向\tm{void}限定或不限定版本的指针，则前者将转换为后者的类型。

\paragraph{}
如果两个指针都是零指针，两个指针都是指向同一对象（包括指向对象的指针和位于其开头
的子对象）或函数的指针，两个指针都是指向同一数组对象的最后一个元素之后的第一个元
素的指针，或者一个指针指向一个数组对象最后一个元素之后的第一个元素，另一个指针指
向地址空间中恰好紧跟在第一个数组对象之后的不同数组对象的开始。\footnote{两个对象
在内存中可能是相邻的，因为它们是较大数组的相邻元素，或者结构的相邻成员之间没有填
充，或者是因为实现选择了将它们放置在一起，即使它们是不相关的。如果先前的无效指针
操作（如访问数组边界外）产生未定义行为，则随后的比较也会产生未定义的行为。}

\paragraph{}
就这些运算符而言，指向不是数组元素对象的指针行为与指向长度为1的数组的第一个元素
的指针行为相同，对象类型作为其元素类型。

\pagebreak
\ssect{按位与运算符}{lang.expr.and}
\syntax
\paragraph{}
\synsym{AND-expression}
  \synprd{\nt{equality-expression}}
  \synprd[]{\nt{AND-expression} \tm{\&} \nt{equality-expression}}

\constraint
\paragraph{}
每一个操作数均应该具有整型。

\semantic
\paragraph{}
常规算术转换作用于操作数。

\paragraph{}
二元\tm{\&}运算符的结果是操作数的按位与（即当且仅当转换后操作数中的对应位都置位
时，才会设置结果中的对应位）。

\ssect{按位异或运算符}{lang.expr.xor}
\syntax
\paragraph{}
\synsym{exclusive-OR-expression}
  \synprd{\nt{AND-expression}}
  \synprd[]{\nt{exclusive-OR-expression} \tm{\^} \nt{AND-expression}}

\constraint
\paragraph{}
每一个操作数均应该具有整型。

\semantic
\paragraph{}
常规算术转换作用于操作数。

\paragraph{}
二元运算符\tm{\^}的结果是操作数的按位异或（即当且仅当转换后操作数中对应位上仅有
一个置位时，才会设置结果中的对应位）。

\ssect{按位或运算符}{lang.expr.or}
\syntax
\paragraph{}
\synsym{inclusive-OR-expression}
\synprd{\nt{exclusive-OR-expression}}
  \synprd[]{\nt{inclusive-OR-expression} \tm{|} \nt{exclusive-OR-expression}}

\constraint
\paragraph{}
每一个操作数均应该具有整型。

\semantic
\paragraph{}
常规算术转换作用于操作数。

\paragraph{}
运算符\tm{|}的结果为操作数的按位或（即当且仅当转换后操作数中的至少一个对应位置位
时，才会设置结果中的对应位）。

\ssect{逻辑与运算符}{lang.expr.land}
\syntax
\paragraph{}
\synsym{logical-AND-expression}
  \synprd{\nt{inclusive-OR-expression}}
  \synprd[]{\nt{logical-AND-expression} \tm{\&\&} \nt{inclusive-OR-expression}}

\constraint
\paragraph{}
每一个操作数均应该为标量类型。

\semantic
\paragraph{}
如果\tm{\&\&}运算符的两个操作数的比较结果都不等于0则应生成1；否则将生成0。结果类
型为\tm{int}。

\paragraph{}
与按位二元\tm{\&}运算符不同，\tm{\&\&}运算符保证从左向右计算；如果计算第二个操作
数，则在第一个操作数和第二个操作数的计算之间有一个序列点。如果第一个操作数比较等
于0，则不计算第二个操作数。

\ssect{逻辑或运算符}{lang.expr.lor}
\syntax
\paragraph{}
\synsym{logical-OR-expression}
  \synprd{\nt{inclusive-AND-expression}}
  \synprd[]{\nt{logical-OR-expression} \tm{||} \nt{inclusive-AND-expression}}

\constraint
\paragraph{}
每一个操作数均应该为标量类型。

\semantic
\paragraph{}
如果\tm{||}运算符的两个操作数中任一个的比较结果不等于0则应生成1；否则将生成0。结
果类型为\tm{int}。

\paragraph{}
与按位二元\tm{|}运算符不同，\tm{||}运算符保证从左向右计算；如果计算第二个操作
数，则在第一个操作数和第二个操作数的计算之间有一个序列点。如果第一个操作数比较不
等于0，则不计算第二个操作数。

\ssect{条件运算符}{lang.expr.cond}
\syntax
\paragraph{}
\synsym{conditional-expression}
  \synprd{\nt{logical-OR-expression}}
  \synprd[]{\nt{logical-OR-expression} \tm{?} \nt{expression} \tm{:}
    \nt{conditional-expression}}

\constraint
\paragraph{}
第一操作数应具有标量类型。

\paragraph{}
对第二和第三操作数以下之一应该成立：
\begin{itemize}
  \item{两操作数均为算术类型；}
  \item{两操作数均为相同结构或联合类型；}
  \item{两操作数均为void类型。}
  \item{两操作数均为指向兼容类型的限定或未限定版本的指针；}
  \item{其中一个操作数为指针，另一个为零指针常量；或}
  \item{其中一个操作数为对象类型指针，另一个为指向\tm{void}类型限定或未限定版本
    的指针。}
\end{itemize}

\semantic
\paragraph{}
对第一个操作数求值；在其计算和第二个或第三个操作数的计算之间有一个序列点（无论哪
一个）。第二个操作数仅在第一个比较不等于0时计算；第三个操作数仅在第一个比较等于0
时计算；结果是第二个或第三个操作数的值（以计算值为准），转换为下面描述的类型。
\footnote{条件表达式不产生左值。}

\paragraph{}
如果第二个和第三个操作数都具有算术类型，且由常规算术转换确定的结果类型，如果应用
的话，则是结果类型是转换的结果类型。如果两个操作数都具有结构或联合类型，则结果具
有该类型。如果两个操作数都具有\tm{void}类型，则结果具有\tm{void}类型。

\paragraph{}
如果第二个和第三个操作数都是指针，或者一个是零指针常量，另一个是指针，则结果类型
是指向使用两个操作数引用类型的所有类型限定符所限定类型的指针。此外，如果两个操作
数都是指向兼容类型或兼容类型的不同限定版本的指针，则结果类型是指向合成类型的适当
限定版本的指针；如果一个操作数是零指针常量，则结果具有另一个操作数的类型；否则，
一个操作数是指向\tm{void}或\tm{void}的限定版本，在这种情况下，结果类型是指向适当
限定版本的\tm{void}指针。

\paragraph{}
\ex* 当第二个和第三个操作数是指针时产生的公共类型在两个独立的阶段中确定。例如，
适当的限定符不依赖于两个指针是否具有兼容的类型。

\paragraph{}
给定以下声明
\begin{lstlisting}
    const void *c_vp;
    void *vp;
    const int *c_ip;
    volatile int *v_ip;
    int *ip;
    const char *c_cp;
\end{lstlisting}
下表中的第三列是条件表达式结果的通用类型，前两列是第二个和第三个操作数（任意顺
序）：
\begin{table}[h!]
  \begin{tabular}{lll}
    \tm{c\_vp} & \tm{c\_ip} & \tm{const void *} \\
    \tm{v\_ip} & \tm{0}     & \tm{volatile int *} \\
    \tm{c\_ip} & \tm{v\_ip} & \tm{const volatile int *} \\
    \tm{vp}    & \tm{c\_cp} & \tm{const void *} \\
    \tm{ip}    & \tm{c\_ip} & \tm{const int *} \\
    \tm{vp}    & \tm{ip}    & \tm{void *}
  \end{tabular}
\end{table}

\ssect{赋值运算符}{lang.expr.assign}
\syntax
\paragraph{}
\synsym{assignment-expression}
  \synprd{\nt{conditional-expression}}
  \synprd{\nt{unary-expression assignment-operator assignment-expression}}
\synsym[one of]{assignment-operator}
  \synprd[]{\tm{= *= /= \%= += -= \tl{}\tl= \tg{}\tg= \&= \^{}= |=}}

\constraint
\paragraph{}
赋值运算符的左操作数应为可修改的左值。

\semantic
\paragraph{}
赋值运算符将值存储在左操作数指定的对象中。赋值表达式在赋值之后具有左操作数的值，
\footnote{实现允许读取对象以确定值，但不需要这样做，即使对象具有\tm{volatile}限
定类型。} 但不是左值。赋值表达式的类型是左操作数在左值转换后的类型。更新左操作数
的存储值的副作用后序于左操作数和右操作数的值计算。操作数的计算无序。

\sssect{简单赋值}{lang.expr.assign.simple}
\constraint
\paragraph{}
以下之一应该成立：\footnote{对于类型限定符，这些约束的不对称性是由于转换（在
\ref{lang.conv.other.desig}中指定）导致的，该转换将左值更改为``表达式的值''，从
而删除应用于表达式类型范畴的任何类型限定符（例如，它从类型
\tm{int volatile * const}中删除\tm{const}而不删除\tm{volatile}）。}
\begin{itemize}
  \item{左操作数具有原子，限定或未限定算术类型，右操作数具有算术类型；}
  \item{左操作数具有与右操作数兼容的结构或联合类型的原子，限定或未限定版本；}
  \item{左操作数具有原子，限定或未限定指针类型，且（考虑左值转换后的左操作数将具
    有的类型）两操作数均为指向兼容类型的限定或未限定版本的指针，并且左操作数具有
    右操作数所指类型的所有限定符。}
  \item{左操作数具有原子，限定或未限定的指针类型，并且（考虑到左操作数在左值转换
    后将具有的类型）一个操作数是指向对象类型的指针，另一个操作数是指向\tm{void}
    类型的限定或未限定版本的指针，并且左侧指向的类型具有右操作数所指的类型的所有
    限定符；}
  \item{左操作数是原子，限定指针或未限定指针，右操作数是零指针常量；或}
  \item{左操作数为原子，限定或未限定\tm{\_Bool}类型，右操作数是指针。}
\end{itemize}

\semantic
\paragraph{}
在\textit{简单赋值}（\tm{=}）中，右操作数的值转换为赋值表达式的类型，并替换存储
在左操作数指定的对象中的值。

\paragraph{}
如果从任何与第一个对象存储重叠的另一个对象读取存储在第一个对象中的值，则重叠应准
确，并且两个对象应具有兼容类型的限定或未限定版本；否则行为未定义。

\paragraph{}
\ex 以下程序片断中
\begin{lstlisting}
    int f(void);
    char c;
    /* ... */
    if ((c = f()) == -1)
      /* ... */
\end{lstlisting}
函数返回的\tm{int}值存储在\tm{char}中时可能会被截断，然后在比较前转换回\tm{int}
的宽度。在一个实现中，``普通''\tm{char}的值范围与\tm{unsigned char}的值范围相同
（\tm{char}比\tm{int}更窄），转换的结果不能是负数，因此比较的操作数永远不相等。
因此，对于完全可移植性，变量\tm{c}应该声明为\tm{int}。

\paragraph{}
\ex 以下片断中：
\begin{lstlisting}
    char c;
    int i;
    long l;

    l = (c = i);
\end{lstlisting}
\tm{i}的值转换为赋值表达式\tm{c = i}的类型，即\tm{char}类型。然后将括号中的表达
式值转换为外层赋值表达式的类型，即\tm{long int}类型。

\paragraph{}
\ex 考虑以下片断：
\begin{lstlisting}
    const char **cpp;
    char *p;
    const char c = 'A';

    cpp = &p;   // constraint violation
    *cpp = &c;  // valid
    *p = 0;     // valid
\end{lstlisting}
第一个赋值不安全，因为它将允许后面的有效代码尝试更改常量对象\tm{c}的值。

\sssect{复合赋值}{lang.expr.assign.cmpd}
\constraint
\paragraph{}
对\tm{+=}和\tm{-=}运算符，左操作数应为指向完整对象类型的原子指针、限定指针或未限
定指针，右操作数应为整型；或左操作数为原子、限定指针或未限定指针，右操作数为算术
类型。

\paragraph{}
对于其他运算符，左操作数应具有原子、限定或未限定算术类型，并且（考虑到左操作数在
左值转换后的类型），每个操作数应具有与相应的二元运算符允许的算术类型一致的算术类
型。

\semantic
\paragraph{}
形如\tm{E1} \nt{op}\tm{= E2}的\textit{复合赋值}等价于简单赋值表达式\tm{E1 = E1}
\nt{op} \tm{(E2)}，但左值\tm{E1}只计算一次，并且对于不确定性有序的函数调用，复合
赋值的操作是单个（single）计算。如果\tm{E1}具有原子类型，则复合赋值是读-修改-写
操作，具有\tm{memory\_order\_seq\_cst}的内存顺序语义。\footnote{
\newcommand{\lbox}[2][4em]{\\ \mbox{\hspace{#1}#2}}
如果可以形成指向原子对象的指针，并且\tm{E1}和\tm{E2}具有整型，则相当于以下代码序
列，其中\nt{T1}是\tm{E1}的类型，\nt{T2}是\tm{E2}的类型：
\lbox{\nt{T1} \tm{*addr = \&E1;}}
\lbox{\nt{T2} \tm{val = (E1);}}
\lbox{\nt{T1} \tm{odl = *addr;}}
\lbox{\nt{T1} \tm{new;}}
\lbox{\tm{do \{}}
\lbox[6em]{\tm{new = old} \nt{op} \tm{val;}}
\lbox{\tm{\} while (!atomic\_compare\_exchange\_strong(addr, \&old, new));}}  \\
\tm{new}为操作的结果。                                                        \\
如果\tm{E1}或\tm{E2}具有浮点类型，则在丢弃的\tm{new}求值过程中遇到的异常条件或浮
点异常也应丢弃，以满足\tm{E1} \nt{op}\tm{= E2}和\tm{E1 = E1} \nt{op} \tm{(E2)}的
等效性。例如，如果附录\ref{fparith}有效，所涉及的浮点类型具有IEC 60559格式，且
\tm{FLT\_EVAL\_METHOD}为0，则等效代码为
\lbox{\tm{\#include <fenv.h>}}
\lbox{\tm{\#pragma STDC FENV\_ACCESS ON}}
\lbox{\tm{/* ... */}}
\lbox[6em]{\tm{fenv\_t fenv;}}
\lbox[6em]{\nt{T1} \tm{*addr = \&E1;}}
\lbox[6em]{\nt{T2} \tm{val = E2;}}
\lbox[6em]{\nt{T1} \tm{old = *addr;}}
\lbox[6em]{\nt{T1} \tm{new;}}
\lbox[6em]{\tm{feholdexcept(\&fenv);}}
\lbox[6em]{\tm{for (;;) \{}}
\lbox[8em]{\tm{new = old} \nt{op} \tm{val;}}
\lbox[8em]{\tm{if (!atomic\_compare\_exchange\_strong(addr, \&old, new))}}
\lbox[10em]{\tm{break;}}
\lbox[8em]{\tm{feclearexcept(FE\_ALL\_EXCEPT);}}
\lbox[6em]{\tm{\}}}
\lbox[6em]{\tm{feupdateenv(\&fenv);}} \\
如果\tm{FLT\_EVAL\_METHOD}不是0，那么\tm{T2}必须具有计算\tm{E2}所需范围和精度的
类型，以便满足等效性。}

\ssect{逗号运算符}{lang.expr.comma}
\syntax
\paragraph{}
\synsym{expression}
  \synprd{\nt{assignment-expression}}
  \synprd[]{\nt{expression} \tm{,} \nt{assignment-expression}}

\semantic
\paragraph{}
逗号运算符的左操作数被计算为空表达式；它的计算值与右操作数的计算值之间有一个序列
点。然后计算右操作数；结果有其类型和值。\footnote{逗号表达式不产生左值。}

\paragraph{}
\ex* 如语法所示，逗号运算符（如本节所述）不能出现在使用逗号分隔列表中项目的上下
文中（如函数参数或初始化列表）。另一方面，它可以在带圆括号的表达式中使用，也可以
在条件运算符的第二个表达式中使用。在函数调用
\begin{lstlisting}
    f(a, (t=3, t+2), c)
\end{lstlisting}
中函数有三个参数，第二个参数的值为5。

\fwdref{6.7.9}

\sect{常量表达式}{lang.constexpr}
\syntax
\paragraph{}
\synsym{constant-expression}
  \synprd[]{\nt{conditional-expression}}

\desc
\paragraph{}
常量表达式可以在翻译期间而不是运行时进行计算，因此可以在常量可能存在的任何位置使
用。

\constraint
\paragraph{}
常量表达式不应包含赋值、递增、递减、函数调用或逗号运算符，除非它们包含在未计算的
子表达式中。\footnote{通常不计算\tm{sizeof}或\tm{\_Alignof}运算符的操作数
（\ref{lang.expr.unary.sizeof}）。}

\paragraph{}
每个常量表达式的计算结果应为其类型的可表示值范围内的常量。

\semantic
\paragraph{}
在多个上下文中需要计算为常量的表达式。如果在翻译环境中对浮点表达式进行求值，则算
术范围和精度至少应与在执行环境中对表达式进行求值时一样大。\footnote{使用由
\tm{FLT\_EVAL\_METHOD}确定的求值格式也适用于翻译环境中的求值。}

\paragraph{}
整型\textit{常量表达式}\footnote{整型常量表达式在许多上下文中都是必需的，例如结
构的位字段成员的大小、枚举常量的值和非可变长度数组的大小。
\ref{lang.ppdir.condinc}中讨论了适用于条件包含预处理指令中使用的整数常量表达式的
其他约束。}应具有整型，并且只能具有整型常量、枚举常量、字符常量、结果为整型常量
的sizeof表达式、表达式对齐和浮点常量，这些常量是强制转换的直接操作数。整数常量表
达式中的强制转换运算符只能将算术类型转换为整数类型，但作为操作数的一部分转换为
\tm{sizeof}或\tm{\_Alignof}运算符的情况除外。

\paragraph{}
初始化中的常量表达式允许有更多的纬度。此类常量表达式应为或计算为以下其中之一：
\begin{itemize}
  \item{算术常量表达式，}
  \item{零指针常量，}
  \item{地址常量，或}
  \item{完整对象类型的地址常量加或减一个整数常量表达式。}
\end{itemize}

\paragraph{}
\textit{算术常量表达式}应具有算术类型，且只能具有整数常量、浮点常量、枚举常量、
字符常量、结果为整数常量的\tm{sizeof}表达式以及\tm{\_Alignof}表达式等操作数。算
术常量表达式中的强制转换运算符只能将算术类型转换为算术类型，但作为操作数的一部分
转换为\tm{sizeof}或\tm{\_Alignof}运算符的情况除外。

\paragraph{}
\textit{地址常量}是一个空指针、一个指向指定静态存储期对象的左值的指针或一个指向
函数指示符的指针；它应使用一元运算符\tm{\&}或整数常量转换为指针类型来显式创建，
或通过使用数组或函数类型的表达式来隐式创建。数组下标\tm{[]}，成员访问\tm{.}和
\tm{-\tg}运算符、地址\tm{\&}和间接寻址\tm{*}一元运算符和指针强制转换可用于创建地
址常量，但不能使用这些运算符访问对象的值。

\paragraph{}
实现可能接受其他形式的常量表达式。

\paragraph{}
计算常量表达式的语义规则和非常量表达式一样。\footnote{因此，以下初始化中，    \\
\mbox{\hspace{4em}\tm{static int i = 2 || 1 / 0;}}                            \\
表达式是值为一的有效整数常量表达式。}

\fwdref{6.7.6.2，6.7.9}

\sect{声明}{lang.dcl}
\syntax
\paragraph{}<++>

\constraint
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\fwdref{<++>}

\ssect{存储类说明}{lang.dcl.stc}
\syntax
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\fwdref{<++>}

\ssect{类型说明符}{lang.dcl.type}
\syntax
\paragraph{}<++>

\constraint
\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\fwdref{<++>}

\sssect{结构与联合说明符}{lang.dcl.type.struct}
\syntax
\paragraph{}<++>

\constraint
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\fwdref{<++>}

\sssect{枚举说明符}{lang.dcl.type.enum}
\syntax
\paragraph{}<++>

\constraint
\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\fwdref{<++>}

\sssect{标签Tags}{lang.dcl.type.tag}
\constraint
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\fwdref{<++>}

\sssect{原子类型说明符}{lang.dcl.type.atom}
\syntax
\paragraph{}<++>

\constraint
\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\ssect{类型限定}{lang.dcl.qual}
\syntax
\paragraph{}<++>

\constraint
\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\sssect{restrict的形式定义}{lang.dcl.qual.restrict}
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\ssect{函数说明}{lang.dcl.fct}
\syntax
\paragraph{}<++>

\constraint
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\recprac
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\fwdref{<++>}

\ssect{对齐说明符}{lang.dcl.align}
\syntax
\paragraph{}<++>

\constraint
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\ssect{声明子}{lang.dcl.decl}
\syntax
\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\implimit
\paragraph{}<++>

\fwdref{<++>}

\sssect{指针声明子}{lang.dcl.decl.ptr}
\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\sssect{数组声明子}{lang.dcl.decl.array}
\constraint
\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\fwdref{<++>}

\sssect{函数声明子（含原型）}{lang.dcl.decl.fct}
\constraint
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\fwdref{<++>}

\ssect{类型名}{lang.dcl.typename}
\syntax
\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\ssect{类型定义}{lang.dcl.typedef}
\syntax
\paragraph{}<++>

\constraint
\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\ssect{初始化}{lang.dcl.init}
\syntax
\paragraph{}<++>

\constraint
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\fwdref{<++>}

\ssect{静态断言}{lang.dcl.assert}
\syntax
\paragraph{}<++>

\constraint
\paragraph{}<++>

\semantic
\paragraph{}<++>

\fwdref{<++>}

\sect{语句与块}{lang.stmt}
\syntax
\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\fwdref{<++>}

\ssect{标号语句}{lang.stmt.label}
\syntax
\paragraph{}<++>

\constraint
\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\fwdref{<++>}

\ssect{复合语句}{lang.stmt.cmpd}
\syntax
\paragraph{}<++>

\semantic
\paragraph{}<++>

\ssect{表达式与空语句}{lang.stmt.expr}
\syntax
\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\fwdref{<++>}

\ssect{选择语句}{lang.stmt.sel}
\syntax
\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\sssect{if语句}{lang.stmt.sel.if}
\constraint
\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\sssect{switch语句}{lang.stmt.sel.switch}
\constraint
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\implimit
\paragraph{}<++>

\paragraph{}<++>

\ssect{迭代语句}{lang.stmt.iter}
\syntax
\paragraph{}<++>

\constraint
\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\sssect{while语句}{lang.stmt.iter.while}
\paragraph{}<++>

\sssect{do语句}{lang.stmt.iter.do}
\paragraph{}<++>

\sssect{for语句}{lang.stmt.iter.for}
\paragraph{}<++>

\paragraph{}<++>

\ssect{跳转语句}{lang.stmt.jmp}
\syntax
\paragraph{}<++>

\semantic
\paragraph{}<++>

\sssect{goto语句}{lang.stmt.jmp.goto}
\constraint
\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\sssect{continue语句}{lang.stmt.jmp.cont}
\constraint
\paragraph{}<++>

\semantic
\paragraph{}<++>

\sssect{break语句}{lang.stmt.jmp.brk}
\constraint
\paragraph{}<++>

\semantic
\paragraph{}<++>

\sssect{return语句}{lang.stmt.jmp.ret}
\constraint
\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\sect{外部定义}{lang.extn}
\syntax
\paragraph{}<++>

\constraint
\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\ssect{函数定义}{lang.extn.fct}
\syntax
\paragraph{}<++>

\constraint
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\ssect{外部对象定义}{lang.extn.obj}
\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\sect{预处理指令}{lang.ppdir}
\syntax
\paragraph{}<++>

\desc
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\constraint
\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\ssect{条件包含}{lang.ppdir.condinc}
\constraint
\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\fwdref{<++>}

\ssect{源文件包含}{lang.ppdir.inc}
\constraint
\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\fwdref{<++>}

\ssect{宏替换}{lang.ppdir.macro}
\constraint
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\sssect{参数替换}{lang.ppdir.macro.subst}
\paragraph{}<++>

\paragraph{}<++>

\sssect{\#运算符}{lang.ppdir.macro.stringize}
\constraint
\paragraph{}<++>

\semantic
\paragraph{}<++>

\sssect{\#\#运算符}{lang.ppdir.macro.concat}
\constraint
\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\sssect{重扫描和进一步替换}{lang.ppdir.macro.rescan}
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\sssect{宏定义作用域}{lang.ppdir.macro.scope}
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\ssect{行控制}{lang.ppdir.line}
\constraint
\paragraph{}<++>

\semantic
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\ssect{Error指令}{lang.ppdir.error}
\semantic
\paragraph{}<++>

\ssect{Pragma指令}{lang.ppdir.pragma}
\semantic
\paragraph{}<++>

\paragraph{}<++>

\fwdref{<++>}

\ssect{空指令}{lang.ppdir.null}
\semantic
\paragraph{}<++>

\ssect{预定义宏名}{lang.ppdir.predef}
\paragraph{}<++>

\paragraph{}<++>

\paragraph{}<++>

\fwdref{<++>}

\sssect{强制定义的宏}{lang.ppdir.predef.mand}
\paragraph{}<++>

\fwdref{<++>}

\sssect{环境相关宏}{lang.ppdir.predef.env}
\paragraph{}<++>

\fwdref{<++>}

\sssect{条件特性宏}{lang.ppdir.predef.cond}
\paragraph{}<++>

\paragraph{}<++>

\ssect{Pragma运算符}{lang.ppdir.pragmaop}
\semantic
\paragraph{}<++>

\paragraph{}<++>

\sect{未来语言方向}{lang.dir}
\ssect{符点类型}{lang.dir.float}
\paragraph{}<++>

\ssect{标识符链接}{lang.dir.link}
\paragraph{}<++>

\ssect{外部名称}{lang.dir.extn}
\paragraph{}<++>

\ssect{字符转义序列}{lang.dir.escape}
\paragraph{}<++>

\ssect{存储类说明}{lang.dir.stc}
\paragraph{}<++>

\ssect{函数声明子}{lang.dir.fctdecl}
\paragraph{}<++>

\ssect{函数定义}{lang.dir.fctdef}
\paragraph{}<++>

\ssect{Pragma指令}{lang.dir.pragma}
\paragraph{}<++>

\ssect{预定义宏名}{lang.dir.predef}
\paragraph{}<++>

